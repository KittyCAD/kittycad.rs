#![doc = r" This module contains the generated types for the library."]
use tabled::Tabled;
pub mod base64 {
    #![doc = " Base64 data that encodes to url safe base64, but can decode from multiple"]
    #![doc = " base64 implementations to account for various clients and libraries. Compatible"]
    #![doc = " with serde and JsonSchema."]
    use serde::de::{Error, Unexpected, Visitor};
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::convert::TryFrom;
    use std::fmt;
    static ALLOWED_DECODING_FORMATS: &[data_encoding::Encoding] = &[
        data_encoding::BASE64,
        data_encoding::BASE64URL,
        data_encoding::BASE64URL_NOPAD,
        data_encoding::BASE64_MIME,
        data_encoding::BASE64_NOPAD,
    ];
    #[derive(Debug, Clone, PartialEq, Eq)]
    #[doc = " A container for binary that should be base64 encoded in serialisation. In reverse"]
    #[doc = " when deserializing, will decode from many different types of base64 possible."]
    pub struct Base64Data(pub Vec<u8>);
    impl Base64Data {
        #[doc = " Return is the data is empty."]
        pub fn is_empty(&self) -> bool {
            self.0.is_empty()
        }
    }

    impl fmt::Display for Base64Data {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", data_encoding::BASE64URL_NOPAD.encode(&self.0))
        }
    }

    impl From<Base64Data> for Vec<u8> {
        fn from(data: Base64Data) -> Vec<u8> {
            data.0
        }
    }

    impl From<Vec<u8>> for Base64Data {
        fn from(data: Vec<u8>) -> Base64Data {
            Base64Data(data)
        }
    }

    impl AsRef<[u8]> for Base64Data {
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    }

    impl TryFrom<&str> for Base64Data {
        type Error = anyhow::Error;
        fn try_from(v: &str) -> Result<Self, Self::Error> {
            for config in ALLOWED_DECODING_FORMATS {
                if let Ok(data) = config.decode(v.as_bytes()) {
                    return Ok(Base64Data(data));
                }
            }
            anyhow::bail!("Could not decode base64 data: {}", v);
        }
    }

    struct Base64DataVisitor;
    impl<'de> Visitor<'de> for Base64DataVisitor {
        type Value = Base64Data;
        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            write!(formatter, "a base64 encoded string")
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: Error,
        {
            for config in ALLOWED_DECODING_FORMATS {
                if let Ok(data) = config.decode(v.as_bytes()) {
                    return Ok(Base64Data(data));
                }
            }
            Err(serde::de::Error::invalid_value(Unexpected::Str(v), &self))
        }
    }

    impl<'de> Deserialize<'de> for Base64Data {
        fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
        where
            D: Deserializer<'de>,
        {
            deserializer.deserialize_str(Base64DataVisitor)
        }
    }

    impl Serialize for Base64Data {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            let encoded = data_encoding::BASE64URL_NOPAD.encode(&self.0);
            serializer.serialize_str(&encoded)
        }
    }

    impl schemars::JsonSchema for Base64Data {
        fn schema_name() -> String {
            "Base64Data".to_string()
        }

        fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
            let mut obj = gen.root_schema_for::<String>().schema;
            obj.format = Some("byte".to_string());
            schemars::schema::Schema::Object(obj)
        }

        fn is_referenceable() -> bool {
            false
        }
    }

    #[cfg(test)]
    mod tests {
        use super::Base64Data;
        use std::convert::TryFrom;
        #[test]
        fn test_base64_try_from() {
            assert!(Base64Data::try_from("aGVsbG8=").is_ok());
            assert!(Base64Data::try_from("abcdefghij").is_err());
        }
    }
}

pub mod paginate {
    #![doc = " Utility functions used for pagination."]
    use anyhow::Result;
    #[doc = " A trait for types that allow pagination."]
    pub trait Pagination {
        #[doc = " The item that is paginated."]
        type Item: serde::de::DeserializeOwned;
        #[doc = " Returns true if the response has more pages."]
        fn has_more_pages(&self) -> bool;
        #[doc = " Modify a request to get the next page."]
        fn next_page(
            &self,
            req: reqwest::Request,
        ) -> Result<reqwest::Request, crate::types::error::Error>;
        #[doc = " Get the items from a page."]
        fn items(&self) -> Vec<Self::Item>;
    }
}

pub mod phone_number {
    #![doc = " A library to implement phone numbers for our database and JSON serialization and deserialization."]
    use schemars::JsonSchema;
    use std::str::FromStr;
    #[doc = " A phone number."]
    #[derive(Debug, Default, Clone, PartialEq, Hash, Eq)]
    pub struct PhoneNumber(pub Option<phonenumber::PhoneNumber>);
    impl From<phonenumber::PhoneNumber> for PhoneNumber {
        fn from(id: phonenumber::PhoneNumber) -> PhoneNumber {
            PhoneNumber(Some(id))
        }
    }

    impl AsRef<Option<phonenumber::PhoneNumber>> for PhoneNumber {
        fn as_ref(&self) -> &Option<phonenumber::PhoneNumber> {
            &self.0
        }
    }

    impl std::ops::Deref for PhoneNumber {
        type Target = Option<phonenumber::PhoneNumber>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl serde::ser::Serialize for PhoneNumber {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            serializer.serialize_str(&self.to_string())
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PhoneNumber {
        fn deserialize<D>(deserializer: D) -> Result<PhoneNumber, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let s = String::deserialize(deserializer).unwrap_or_default();
            PhoneNumber::from_str(&s).map_err(serde::de::Error::custom)
        }
    }

    impl std::str::FromStr for PhoneNumber {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            if s.trim().is_empty() {
                return Ok(PhoneNumber(None));
            }
            let s = if !s.trim().starts_with('+') {
                format!("+1{}", s)
                    .replace('-', "")
                    .replace('(', "")
                    .replace(')', "")
                    .replace(' ', "")
            } else {
                s.replace('-', "")
                    .replace('(', "")
                    .replace(')', "")
                    .replace(' ', "")
            };
            Ok(PhoneNumber(Some(phonenumber::parse(None, &s).map_err(
                |e| anyhow::anyhow!("invalid phone number `{}`: {}", s, e),
            )?)))
        }
    }

    impl std::fmt::Display for PhoneNumber {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let s = if let Some(phone) = &self.0 {
                phone
                    .format()
                    .mode(phonenumber::Mode::International)
                    .to_string()
            } else {
                String::new()
            };
            write!(f, "{}", s)
        }
    }

    impl JsonSchema for PhoneNumber {
        fn schema_name() -> String {
            "PhoneNumber".to_string()
        }

        fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
            let mut obj = gen.root_schema_for::<String>().schema;
            obj.format = Some("phone".to_string());
            schemars::schema::Schema::Object(obj)
        }

        fn is_referenceable() -> bool {
            false
        }
    }

    #[cfg(test)]
    mod test {
        use super::PhoneNumber;
        use pretty_assertions::assert_eq;
        #[test]
        fn test_parse_phone_number() {
            let mut phone = "+1-555-555-5555";
            let mut phone_parsed: PhoneNumber =
                serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            let mut expected = PhoneNumber(Some(phonenumber::parse(None, phone).unwrap()));
            assert_eq!(phone_parsed, expected);
            let mut expected_str = "+1 555-555-5555";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "555-555-5555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "+1 555-555-5555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "5555555555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "(510) 864-1234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            expected = PhoneNumber(Some(phonenumber::parse(None, "+15108641234").unwrap()));
            assert_eq!(phone_parsed, expected);
            expected_str = "+1 510-864-1234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "(510)8641234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            expected_str = "+1 510-864-1234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, PhoneNumber(None));
            assert_eq!("", serde_json::json!(phone_parsed));
            phone = "+49 30  1234 1234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            expected = PhoneNumber(Some(phonenumber::parse(None, phone).unwrap()));
            assert_eq!(phone_parsed, expected);
            expected_str = "+49 30 12341234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
        }
    }
}

pub mod error {
    #![doc = " Error methods."]
    #[doc = " Error produced by generated client methods."]
    pub enum Error {
        #[doc = " The request did not conform to API requirements."]
        InvalidRequest(String),
        #[doc = " A server error either due to the data, or with the connection."]
        CommunicationError(reqwest::Error),
        #[doc = " An expected response whose deserialization failed."]
        SerdeError {
            #[doc = " The error."]
            error: format_serde_error::SerdeError,
            #[doc = " The response status."]
            status: reqwest::StatusCode,
        },
        #[doc = " An expected error response."]
        InvalidResponsePayload {
            #[doc = " The error."]
            error: reqwest::Error,
            #[doc = " The full response."]
            response: reqwest::Response,
        },
        #[doc = " A response not listed in the API description. This may represent a"]
        #[doc = " success or failure response; check `status().is_success()`."]
        UnexpectedResponse(reqwest::Response),
    }

    impl Error {
        #[doc = " Returns the status code, if the error was generated from a response."]
        pub fn status(&self) -> Option<reqwest::StatusCode> {
            match self {
                Error::InvalidRequest(_) => None,
                Error::CommunicationError(e) => e.status(),
                Error::SerdeError { error: _, status } => Some(*status),
                Error::InvalidResponsePayload { error: _, response } => Some(response.status()),
                Error::UnexpectedResponse(r) => Some(r.status()),
            }
        }

        #[doc = " Creates a new error from a response status and a serde error."]
        pub fn from_serde_error(
            e: format_serde_error::SerdeError,
            status: reqwest::StatusCode,
        ) -> Self {
            Self::SerdeError { error: e, status }
        }
    }

    impl From<reqwest::Error> for Error {
        fn from(e: reqwest::Error) -> Self {
            Self::CommunicationError(e)
        }
    }

    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Error::InvalidRequest(s) => {
                    write!(f, "Invalid Request: {}", s)
                }
                Error::CommunicationError(e) => {
                    write!(f, "Communication Error: {}", e)
                }
                Error::SerdeError { error, status: _ } => {
                    write!(f, "Serde Error: {}", error)
                }
                Error::InvalidResponsePayload { error, response: _ } => {
                    write!(f, "Invalid Response Payload: {}", error)
                }
                Error::UnexpectedResponse(r) => {
                    write!(f, "Unexpected Response: {:?}", r)
                }
            }
        }
    }

    trait ErrorFormat {
        fn fmt_info(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
    }

    impl std::fmt::Debug for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            std::fmt::Display::fmt(self, f)
        }
    }

    impl std::error::Error for Error {
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            match self {
                Error::CommunicationError(e) => Some(e),
                Error::SerdeError { error, status: _ } => Some(error),
                Error::InvalidResponsePayload { error, response: _ } => Some(error),
                _ => None,
            }
        }
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Root {
    pub current_user_url: String,
    pub current_user_authorizations_html_url: String,
    pub authorizations_url: String,
    pub code_search_url: String,
    pub commit_search_url: String,
    pub emails_url: String,
    pub emojis_url: String,
    pub events_url: String,
    pub feeds_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub hub_url: String,
    pub issue_search_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub label_search_url: String,
    pub notifications_url: String,
    pub organization_url: String,
    pub organization_repositories_url: String,
    pub organization_teams_url: String,
    pub public_gists_url: String,
    pub rate_limit_url: String,
    pub repository_url: String,
    pub repository_search_url: String,
    pub current_user_repositories_url: String,
    pub starred_url: String,
    pub starred_gists_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic_search_url: Option<String>,
    pub user_url: String,
    pub user_organizations_url: String,
    pub user_repositories_url: String,
    pub user_search_url: String,
}

impl std::fmt::Display for Root {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Root {
    const LENGTH: usize = 33;
    fn fields(&self) -> Vec<String> {
        vec![
            self.current_user_url.clone(),
            self.current_user_authorizations_html_url.clone(),
            self.authorizations_url.clone(),
            self.code_search_url.clone(),
            self.commit_search_url.clone(),
            self.emails_url.clone(),
            self.emojis_url.clone(),
            self.events_url.clone(),
            self.feeds_url.clone(),
            self.followers_url.clone(),
            self.following_url.clone(),
            self.gists_url.clone(),
            self.hub_url.clone(),
            self.issue_search_url.clone(),
            self.issues_url.clone(),
            self.keys_url.clone(),
            self.label_search_url.clone(),
            self.notifications_url.clone(),
            self.organization_url.clone(),
            self.organization_repositories_url.clone(),
            self.organization_teams_url.clone(),
            self.public_gists_url.clone(),
            self.rate_limit_url.clone(),
            self.repository_url.clone(),
            self.repository_search_url.clone(),
            self.current_user_repositories_url.clone(),
            self.starred_url.clone(),
            self.starred_gists_url.clone(),
            if let Some(topic_search_url) = &self.topic_search_url {
                format!("{:?}", topic_search_url)
            } else {
                String::new()
            },
            self.user_url.clone(),
            self.user_organizations_url.clone(),
            self.user_repositories_url.clone(),
            self.user_search_url.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "current_user_url".to_string(),
            "current_user_authorizations_html_url".to_string(),
            "authorizations_url".to_string(),
            "code_search_url".to_string(),
            "commit_search_url".to_string(),
            "emails_url".to_string(),
            "emojis_url".to_string(),
            "events_url".to_string(),
            "feeds_url".to_string(),
            "followers_url".to_string(),
            "following_url".to_string(),
            "gists_url".to_string(),
            "hub_url".to_string(),
            "issue_search_url".to_string(),
            "issues_url".to_string(),
            "keys_url".to_string(),
            "label_search_url".to_string(),
            "notifications_url".to_string(),
            "organization_url".to_string(),
            "organization_repositories_url".to_string(),
            "organization_teams_url".to_string(),
            "public_gists_url".to_string(),
            "rate_limit_url".to_string(),
            "repository_url".to_string(),
            "repository_search_url".to_string(),
            "current_user_repositories_url".to_string(),
            "starred_url".to_string(),
            "starred_gists_url".to_string(),
            "topic_search_url".to_string(),
            "user_url".to_string(),
            "user_organizations_url".to_string(),
            "user_repositories_url".to_string(),
            "user_search_url".to_string(),
        ]
    }
}

#[doc = "Simple User"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableSimpleUser {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub login: String,
    pub id: i64,
    pub node_id: String,
    pub avatar_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gravatar_id: Option<String>,
    pub url: url::Url,
    pub html_url: url::Url,
    pub followers_url: url::Url,
    pub following_url: String,
    pub gists_url: String,
    pub starred_url: String,
    pub subscriptions_url: url::Url,
    pub organizations_url: url::Url,
    pub repos_url: url::Url,
    pub events_url: String,
    pub received_events_url: url::Url,
    #[serde(rename = "type")]
    pub type_: String,
    pub site_admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub starred_at: Option<String>,
}

impl std::fmt::Display for NullableSimpleUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableSimpleUser {
    const LENGTH: usize = 21;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email)
            } else {
                String::new()
            },
            self.login.clone(),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.avatar_url),
            format!("{:?}", self.gravatar_id),
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.followers_url),
            self.following_url.clone(),
            self.gists_url.clone(),
            self.starred_url.clone(),
            format!("{:?}", self.subscriptions_url),
            format!("{:?}", self.organizations_url),
            format!("{:?}", self.repos_url),
            self.events_url.clone(),
            format!("{:?}", self.received_events_url),
            self.type_.clone(),
            format!("{:?}", self.site_admin),
            if let Some(starred_at) = &self.starred_at {
                format!("{:?}", starred_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "email".to_string(),
            "login".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "avatar_url".to_string(),
            "gravatar_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "followers_url".to_string(),
            "following_url".to_string(),
            "gists_url".to_string(),
            "starred_url".to_string(),
            "subscriptions_url".to_string(),
            "organizations_url".to_string(),
            "repos_url".to_string(),
            "events_url".to_string(),
            "received_events_url".to_string(),
            "type_".to_string(),
            "site_admin".to_string(),
            "starred_at".to_string(),
        ]
    }
}

#[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Integration {
    #[doc = "Unique identifier of the GitHub app"]
    pub id: i64,
    #[doc = "The slug name of the GitHub app"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slug: Option<String>,
    pub node_id: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    #[doc = "The name of the GitHub app"]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub external_url: url::Url,
    pub html_url: url::Url,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The set of permissions for the GitHub app"]
    pub permissions: Permissions,
    #[doc = "The list of events for the GitHub app"]
    pub events: Vec<String>,
    #[doc = "The number of installations associated with the GitHub app"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installations_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub webhook_secret: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pem: Option<String>,
}

impl std::fmt::Display for Integration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Integration {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            if let Some(slug) = &self.slug {
                format!("{:?}", slug)
            } else {
                String::new()
            },
            self.node_id.clone(),
            format!("{:?}", self.owner),
            self.name.clone(),
            format!("{:?}", self.description),
            format!("{:?}", self.external_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.permissions),
            format!("{:?}", self.events),
            if let Some(installations_count) = &self.installations_count {
                format!("{:?}", installations_count)
            } else {
                String::new()
            },
            if let Some(client_id) = &self.client_id {
                format!("{:?}", client_id)
            } else {
                String::new()
            },
            if let Some(client_secret) = &self.client_secret {
                format!("{:?}", client_secret)
            } else {
                String::new()
            },
            if let Some(webhook_secret) = &self.webhook_secret {
                format!("{:?}", webhook_secret)
            } else {
                String::new()
            },
            if let Some(pem) = &self.pem {
                format!("{:?}", pem)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "slug".to_string(),
            "node_id".to_string(),
            "owner".to_string(),
            "name".to_string(),
            "description".to_string(),
            "external_url".to_string(),
            "html_url".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "permissions".to_string(),
            "events".to_string(),
            "installations_count".to_string(),
            "client_id".to_string(),
            "client_secret".to_string(),
            "webhook_secret".to_string(),
            "pem".to_string(),
        ]
    }
}

#[doc = "Basic Error"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BasicError {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

impl std::fmt::Display for BasicError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for BasicError {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(message) = &self.message {
                format!("{:?}", message)
            } else {
                String::new()
            },
            if let Some(documentation_url) = &self.documentation_url {
                format!("{:?}", documentation_url)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{:?}", status)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "message".to_string(),
            "documentation_url".to_string(),
            "url".to_string(),
            "status".to_string(),
        ]
    }
}

#[doc = "Validation Error Simple"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ValidationErrorSimple {
    pub message: String,
    pub documentation_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<String>>,
}

impl std::fmt::Display for ValidationErrorSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ValidationErrorSimple {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.message.clone(),
            self.documentation_url.clone(),
            if let Some(errors) = &self.errors {
                format!("{:?}", errors)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "message".to_string(),
            "documentation_url".to_string(),
            "errors".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
)]
pub enum WebhookConfigInsecureSsl {
    String(String),
    f64(f64),
}

#[doc = "Configuration object of the webhook"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WebhookConfig {
    #[doc = "The URL to which the payloads will be delivered."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<url::Url>,
    #[doc = "The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,
    #[doc = "If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure_ssl: Option<WebhookConfigInsecureSsl>,
}

impl std::fmt::Display for WebhookConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WebhookConfig {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(content_type) = &self.content_type {
                format!("{:?}", content_type)
            } else {
                String::new()
            },
            if let Some(secret) = &self.secret {
                format!("{:?}", secret)
            } else {
                String::new()
            },
            if let Some(insecure_ssl) = &self.insecure_ssl {
                format!("{:?}", insecure_ssl)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "content_type".to_string(),
            "secret".to_string(),
            "insecure_ssl".to_string(),
        ]
    }
}

#[doc = "Delivery made by a webhook, without request and response information."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct HookDeliveryItem {
    #[doc = "Unique identifier of the webhook delivery."]
    pub id: i64,
    #[doc = "Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event)."]
    pub guid: String,
    #[doc = "Time when the webhook delivery occurred."]
    pub delivered_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Whether the webhook delivery is a redelivery."]
    pub redelivery: bool,
    #[doc = "Time spent delivering."]
    pub duration: f64,
    #[doc = "Describes the response returned after attempting the delivery."]
    pub status: String,
    #[doc = "Status code received when delivery was made."]
    pub status_code: i64,
    #[doc = "The event that triggered the delivery."]
    pub event: String,
    #[doc = "The type of activity for the event that triggered the delivery."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    #[doc = "The id of the GitHub App installation associated with this event."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation_id: Option<i64>,
    #[doc = "The id of the repository associated with this event."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_id: Option<i64>,
}

impl std::fmt::Display for HookDeliveryItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for HookDeliveryItem {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.guid.clone(),
            format!("{:?}", self.delivered_at),
            format!("{:?}", self.redelivery),
            format!("{:?}", self.duration),
            self.status.clone(),
            format!("{:?}", self.status_code),
            self.event.clone(),
            format!("{:?}", self.action),
            format!("{:?}", self.installation_id),
            format!("{:?}", self.repository_id),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "guid".to_string(),
            "delivered_at".to_string(),
            "redelivery".to_string(),
            "duration".to_string(),
            "status".to_string(),
            "status_code".to_string(),
            "event".to_string(),
            "action".to_string(),
            "installation_id".to_string(),
            "repository_id".to_string(),
        ]
    }
}

#[doc = "Scim Error"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ScimError {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<i64>,
    #[serde(rename = "scimType", default, skip_serializing_if = "Option::is_none")]
    pub scim_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schemas: Option<Vec<String>>,
}

impl std::fmt::Display for ScimError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ScimError {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(message) = &self.message {
                format!("{:?}", message)
            } else {
                String::new()
            },
            if let Some(documentation_url) = &self.documentation_url {
                format!("{:?}", documentation_url)
            } else {
                String::new()
            },
            if let Some(detail) = &self.detail {
                format!("{:?}", detail)
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{:?}", status)
            } else {
                String::new()
            },
            if let Some(scim_type) = &self.scim_type {
                format!("{:?}", scim_type)
            } else {
                String::new()
            },
            if let Some(schemas) = &self.schemas {
                format!("{:?}", schemas)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "message".to_string(),
            "documentation_url".to_string(),
            "detail".to_string(),
            "status".to_string(),
            "scim_type".to_string(),
            "schemas".to_string(),
        ]
    }
}

#[doc = "Validation Error"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ValidationError {
    pub message: String,
    pub documentation_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<Errors>>,
}

impl std::fmt::Display for ValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ValidationError {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.message.clone(),
            self.documentation_url.clone(),
            if let Some(errors) = &self.errors {
                format!("{:?}", errors)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "message".to_string(),
            "documentation_url".to_string(),
            "errors".to_string(),
        ]
    }
}

#[doc = "Delivery made by a webhook."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct HookDelivery {
    #[doc = "Unique identifier of the delivery."]
    pub id: i64,
    #[doc = "Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event)."]
    pub guid: String,
    #[doc = "Time when the delivery was delivered."]
    pub delivered_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Whether the delivery is a redelivery."]
    pub redelivery: bool,
    #[doc = "Time spent delivering."]
    pub duration: f64,
    #[doc = "Description of the status of the attempted delivery"]
    pub status: String,
    #[doc = "Status code received when delivery was made."]
    pub status_code: i64,
    #[doc = "The event that triggered the delivery."]
    pub event: String,
    #[doc = "The type of activity for the event that triggered the delivery."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    #[doc = "The id of the GitHub App installation associated with this event."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation_id: Option<i64>,
    #[doc = "The id of the repository associated with this event."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_id: Option<i64>,
    #[doc = "The URL target of the delivery."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    pub request: Request,
    pub response: Response,
}

impl std::fmt::Display for HookDelivery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for HookDelivery {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.guid.clone(),
            format!("{:?}", self.delivered_at),
            format!("{:?}", self.redelivery),
            format!("{:?}", self.duration),
            self.status.clone(),
            format!("{:?}", self.status_code),
            self.event.clone(),
            format!("{:?}", self.action),
            format!("{:?}", self.installation_id),
            format!("{:?}", self.repository_id),
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            format!("{:?}", self.request),
            format!("{:?}", self.response),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "guid".to_string(),
            "delivered_at".to_string(),
            "redelivery".to_string(),
            "duration".to_string(),
            "status".to_string(),
            "status_code".to_string(),
            "event".to_string(),
            "action".to_string(),
            "installation_id".to_string(),
            "repository_id".to_string(),
            "url".to_string(),
            "request".to_string(),
            "response".to_string(),
        ]
    }
}

#[doc = "Simple User"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SimpleUser {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub login: String,
    pub id: i64,
    pub node_id: String,
    pub avatar_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gravatar_id: Option<String>,
    pub url: url::Url,
    pub html_url: url::Url,
    pub followers_url: url::Url,
    pub following_url: String,
    pub gists_url: String,
    pub starred_url: String,
    pub subscriptions_url: url::Url,
    pub organizations_url: url::Url,
    pub repos_url: url::Url,
    pub events_url: String,
    pub received_events_url: url::Url,
    #[serde(rename = "type")]
    pub type_: String,
    pub site_admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub starred_at: Option<String>,
}

impl std::fmt::Display for SimpleUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SimpleUser {
    const LENGTH: usize = 21;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email)
            } else {
                String::new()
            },
            self.login.clone(),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.avatar_url),
            format!("{:?}", self.gravatar_id),
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.followers_url),
            self.following_url.clone(),
            self.gists_url.clone(),
            self.starred_url.clone(),
            format!("{:?}", self.subscriptions_url),
            format!("{:?}", self.organizations_url),
            format!("{:?}", self.repos_url),
            self.events_url.clone(),
            format!("{:?}", self.received_events_url),
            self.type_.clone(),
            format!("{:?}", self.site_admin),
            if let Some(starred_at) = &self.starred_at {
                format!("{:?}", starred_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "email".to_string(),
            "login".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "avatar_url".to_string(),
            "gravatar_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "followers_url".to_string(),
            "following_url".to_string(),
            "gists_url".to_string(),
            "starred_url".to_string(),
            "subscriptions_url".to_string(),
            "organizations_url".to_string(),
            "repos_url".to_string(),
            "events_url".to_string(),
            "received_events_url".to_string(),
            "type_".to_string(),
            "site_admin".to_string(),
            "starred_at".to_string(),
        ]
    }
}

#[doc = "An enterprise account"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Enterprise {
    #[doc = "A short description of the enterprise."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub html_url: url::Url,
    #[doc = "The enterprise's website URL."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub website_url: Option<url::Url>,
    #[doc = "Unique identifier of the enterprise"]
    pub id: i64,
    pub node_id: String,
    #[doc = "The name of the enterprise."]
    pub name: String,
    #[doc = "The slug url identifier for the enterprise."]
    pub slug: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub avatar_url: url::Url,
}

impl std::fmt::Display for Enterprise {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Enterprise {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(description) = &self.description {
                format!("{:?}", description)
            } else {
                String::new()
            },
            format!("{:?}", self.html_url),
            if let Some(website_url) = &self.website_url {
                format!("{:?}", website_url)
            } else {
                String::new()
            },
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.slug.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.avatar_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "description".to_string(),
            "html_url".to_string(),
            "website_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "slug".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "avatar_url".to_string(),
        ]
    }
}

#[doc = "The permissions granted to the user-to-server access token."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AppPermissions {
    #[doc = "The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<Actions>,
    #[doc = "The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub administration: Option<Administration>,
    #[doc = "The level of permission to grant the access token for checks on code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<Checks>,
    #[doc = "The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<Contents>,
    #[doc = "The level of permission to grant the access token for deployments and deployment statuses."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployments: Option<Deployments>,
    #[doc = "The level of permission to grant the access token for managing repository environments."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environments: Option<Environments>,
    #[doc = "The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<Issues>,
    #[doc = "The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,
    #[doc = "The level of permission to grant the access token for packages published to GitHub Packages."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<Packages>,
    #[doc = "The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pages: Option<Pages>,
    #[doc = "The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<PullRequests>,
    #[doc = "The level of permission to grant the access token to manage the post-receive hooks for a repository."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_hooks: Option<RepositoryHooks>,
    #[doc = "The level of permission to grant the access token to manage repository projects, columns, and cards."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_projects: Option<RepositoryProjects>,
    #[doc = "The level of permission to grant the access token to view and manage secret scanning alerts."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning_alerts: Option<SecretScanningAlerts>,
    #[doc = "The level of permission to grant the access token to manage repository secrets."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Secrets>,
    #[doc = "The level of permission to grant the access token to view and manage security events like code scanning alerts."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_events: Option<SecurityEvents>,
    #[doc = "The level of permission to grant the access token to manage just a single file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<SingleFile>,
    #[doc = "The level of permission to grant the access token for commit statuses."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statuses: Option<Statuses>,
    #[doc = "The level of permission to grant the access token to manage Dependabot alerts."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vulnerability_alerts: Option<VulnerabilityAlerts>,
    #[doc = "The level of permission to grant the access token to update GitHub Actions workflow files."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflows: Option<Workflows>,
    #[doc = "The level of permission to grant the access token for organization teams and members."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<Members>,
    #[doc = "The level of permission to grant the access token to manage access to an organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_administration: Option<OrganizationAdministration>,
    #[doc = "The level of permission to grant the access token to manage the post-receive hooks for an organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_hooks: Option<OrganizationHooks>,
    #[doc = "The level of permission to grant the access token for viewing an organization's plan."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_plan: Option<OrganizationPlan>,
    #[doc = "The level of permission to grant the access token to manage organization projects and projects beta (where available)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_projects: Option<OrganizationProjects>,
    #[doc = "The level of permission to grant the access token for organization packages published to GitHub Packages."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_packages: Option<OrganizationPackages>,
    #[doc = "The level of permission to grant the access token to manage organization secrets."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_secrets: Option<OrganizationSecrets>,
    #[doc = "The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_self_hosted_runners: Option<OrganizationSelfHostedRunners>,
    #[doc = "The level of permission to grant the access token to view and manage users blocked by the organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_user_blocking: Option<OrganizationUserBlocking>,
    #[doc = "The level of permission to grant the access token to manage team discussions and related comments."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub team_discussions: Option<TeamDiscussions>,
}

impl std::fmt::Display for AppPermissions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for AppPermissions {
    const LENGTH: usize = 30;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(actions) = &self.actions {
                format!("{:?}", actions)
            } else {
                String::new()
            },
            if let Some(administration) = &self.administration {
                format!("{:?}", administration)
            } else {
                String::new()
            },
            if let Some(checks) = &self.checks {
                format!("{:?}", checks)
            } else {
                String::new()
            },
            if let Some(contents) = &self.contents {
                format!("{:?}", contents)
            } else {
                String::new()
            },
            if let Some(deployments) = &self.deployments {
                format!("{:?}", deployments)
            } else {
                String::new()
            },
            if let Some(environments) = &self.environments {
                format!("{:?}", environments)
            } else {
                String::new()
            },
            if let Some(issues) = &self.issues {
                format!("{:?}", issues)
            } else {
                String::new()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata)
            } else {
                String::new()
            },
            if let Some(packages) = &self.packages {
                format!("{:?}", packages)
            } else {
                String::new()
            },
            if let Some(pages) = &self.pages {
                format!("{:?}", pages)
            } else {
                String::new()
            },
            if let Some(pull_requests) = &self.pull_requests {
                format!("{:?}", pull_requests)
            } else {
                String::new()
            },
            if let Some(repository_hooks) = &self.repository_hooks {
                format!("{:?}", repository_hooks)
            } else {
                String::new()
            },
            if let Some(repository_projects) = &self.repository_projects {
                format!("{:?}", repository_projects)
            } else {
                String::new()
            },
            if let Some(secret_scanning_alerts) = &self.secret_scanning_alerts {
                format!("{:?}", secret_scanning_alerts)
            } else {
                String::new()
            },
            if let Some(secrets) = &self.secrets {
                format!("{:?}", secrets)
            } else {
                String::new()
            },
            if let Some(security_events) = &self.security_events {
                format!("{:?}", security_events)
            } else {
                String::new()
            },
            if let Some(single_file) = &self.single_file {
                format!("{:?}", single_file)
            } else {
                String::new()
            },
            if let Some(statuses) = &self.statuses {
                format!("{:?}", statuses)
            } else {
                String::new()
            },
            if let Some(vulnerability_alerts) = &self.vulnerability_alerts {
                format!("{:?}", vulnerability_alerts)
            } else {
                String::new()
            },
            if let Some(workflows) = &self.workflows {
                format!("{:?}", workflows)
            } else {
                String::new()
            },
            if let Some(members) = &self.members {
                format!("{:?}", members)
            } else {
                String::new()
            },
            if let Some(organization_administration) = &self.organization_administration {
                format!("{:?}", organization_administration)
            } else {
                String::new()
            },
            if let Some(organization_hooks) = &self.organization_hooks {
                format!("{:?}", organization_hooks)
            } else {
                String::new()
            },
            if let Some(organization_plan) = &self.organization_plan {
                format!("{:?}", organization_plan)
            } else {
                String::new()
            },
            if let Some(organization_projects) = &self.organization_projects {
                format!("{:?}", organization_projects)
            } else {
                String::new()
            },
            if let Some(organization_packages) = &self.organization_packages {
                format!("{:?}", organization_packages)
            } else {
                String::new()
            },
            if let Some(organization_secrets) = &self.organization_secrets {
                format!("{:?}", organization_secrets)
            } else {
                String::new()
            },
            if let Some(organization_self_hosted_runners) = &self.organization_self_hosted_runners {
                format!("{:?}", organization_self_hosted_runners)
            } else {
                String::new()
            },
            if let Some(organization_user_blocking) = &self.organization_user_blocking {
                format!("{:?}", organization_user_blocking)
            } else {
                String::new()
            },
            if let Some(team_discussions) = &self.team_discussions {
                format!("{:?}", team_discussions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "actions".to_string(),
            "administration".to_string(),
            "checks".to_string(),
            "contents".to_string(),
            "deployments".to_string(),
            "environments".to_string(),
            "issues".to_string(),
            "metadata".to_string(),
            "packages".to_string(),
            "pages".to_string(),
            "pull_requests".to_string(),
            "repository_hooks".to_string(),
            "repository_projects".to_string(),
            "secret_scanning_alerts".to_string(),
            "secrets".to_string(),
            "security_events".to_string(),
            "single_file".to_string(),
            "statuses".to_string(),
            "vulnerability_alerts".to_string(),
            "workflows".to_string(),
            "members".to_string(),
            "organization_administration".to_string(),
            "organization_hooks".to_string(),
            "organization_plan".to_string(),
            "organization_projects".to_string(),
            "organization_packages".to_string(),
            "organization_secrets".to_string(),
            "organization_self_hosted_runners".to_string(),
            "organization_user_blocking".to_string(),
            "team_discussions".to_string(),
        ]
    }
}

#[doc = "Installation"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Installation {
    #[doc = "The ID of the installation."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account: Option<Account>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: RepositorySelection,
    pub access_tokens_url: url::Url,
    pub repositories_url: url::Url,
    pub html_url: url::Url,
    pub app_id: i64,
    #[doc = "The ID of the user or organization this token is being scoped to."]
    pub target_id: i64,
    pub target_type: String,
    #[doc = "The permissions granted to the user-to-server access token."]
    pub permissions: AppPermissions,
    pub events: Vec<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file_paths: Option<Vec<String>>,
    pub app_slug: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suspended_by: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suspended_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contact_email: Option<String>,
}

impl std::fmt::Display for Installation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Installation {
    const LENGTH: usize = 20;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            format!("{:?}", self.account),
            format!("{:?}", self.repository_selection),
            format!("{:?}", self.access_tokens_url),
            format!("{:?}", self.repositories_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.app_id),
            format!("{:?}", self.target_id),
            self.target_type.clone(),
            format!("{:?}", self.permissions),
            format!("{:?}", self.events),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.single_file_name),
            if let Some(has_multiple_single_files) = &self.has_multiple_single_files {
                format!("{:?}", has_multiple_single_files)
            } else {
                String::new()
            },
            if let Some(single_file_paths) = &self.single_file_paths {
                format!("{:?}", single_file_paths)
            } else {
                String::new()
            },
            self.app_slug.clone(),
            format!("{:?}", self.suspended_by),
            format!("{:?}", self.suspended_at),
            if let Some(contact_email) = &self.contact_email {
                format!("{:?}", contact_email)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "account".to_string(),
            "repository_selection".to_string(),
            "access_tokens_url".to_string(),
            "repositories_url".to_string(),
            "html_url".to_string(),
            "app_id".to_string(),
            "target_id".to_string(),
            "target_type".to_string(),
            "permissions".to_string(),
            "events".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "single_file_name".to_string(),
            "has_multiple_single_files".to_string(),
            "single_file_paths".to_string(),
            "app_slug".to_string(),
            "suspended_by".to_string(),
            "suspended_at".to_string(),
            "contact_email".to_string(),
        ]
    }
}

#[doc = "License Simple"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableLicenseSimple {
    pub key: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spdx_id: Option<String>,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
}

impl std::fmt::Display for NullableLicenseSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableLicenseSimple {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            self.key.clone(),
            self.name.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.spdx_id),
            self.node_id.clone(),
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "key".to_string(),
            "name".to_string(),
            "url".to_string(),
            "spdx_id".to_string(),
            "node_id".to_string(),
            "html_url".to_string(),
        ]
    }
}

#[doc = "A git repository"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Repository {
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub node_id: String,
    #[doc = "The name of the repository."]
    pub name: String,
    pub full_name: String,
    #[doc = "License Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<NullableSimpleUser>,
    pub forks: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    #[doc = "Simple User"]
    pub owner: SimpleUser,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    pub html_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub fork: bool,
    pub url: url::Url,
    pub archive_url: String,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: url::Url,
    pub deployments_url: url::Url,
    pub downloads_url: url::Url,
    pub events_url: url::Url,
    pub forks_url: url::Url,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub languages_url: url::Url,
    pub merges_url: url::Url,
    pub milestones_url: String,
    pub notifications_url: String,
    pub pulls_url: String,
    pub releases_url: String,
    pub ssh_url: String,
    pub stargazers_url: url::Url,
    pub statuses_url: String,
    pub subscribers_url: url::Url,
    pub subscription_url: url::Url,
    pub tags_url: url::Url,
    pub teams_url: url::Url,
    pub trees_url: String,
    pub clone_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror_url: Option<url::Url>,
    pub hooks_url: url::Url,
    pub svn_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    pub forks_count: i64,
    pub stargazers_count: i64,
    pub watchers_count: i64,
    pub size: i64,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    pub open_issues_count: i64,
    #[doc = "Whether this repository acts as a template that can be used to generate new repositories."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub has_pages: bool,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    #[doc = "Returns whether or not this repository disabled."]
    pub disabled: bool,
    #[doc = "The repository visibility: public, private, or internal."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub visibility: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template_repository: Option<TemplateRepository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[doc = "Whether to allow Auto-merge to be used on pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[doc = "Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[doc = "Whether a squash merge commit can use the pull request title as default."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    #[doc = "Whether to allow forking this repo"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network_count: Option<i64>,
    pub open_issues: i64,
    pub watchers: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub starred_at: Option<String>,
}

impl std::fmt::Display for Repository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Repository {
    const LENGTH: usize = 92;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.full_name.clone(),
            format!("{:?}", self.license),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.forks),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            format!("{:?}", self.owner),
            format!("{:?}", self.private),
            format!("{:?}", self.html_url),
            format!("{:?}", self.description),
            format!("{:?}", self.fork),
            format!("{:?}", self.url),
            self.archive_url.clone(),
            self.assignees_url.clone(),
            self.blobs_url.clone(),
            self.branches_url.clone(),
            self.collaborators_url.clone(),
            self.comments_url.clone(),
            self.commits_url.clone(),
            self.compare_url.clone(),
            self.contents_url.clone(),
            format!("{:?}", self.contributors_url),
            format!("{:?}", self.deployments_url),
            format!("{:?}", self.downloads_url),
            format!("{:?}", self.events_url),
            format!("{:?}", self.forks_url),
            self.git_commits_url.clone(),
            self.git_refs_url.clone(),
            self.git_tags_url.clone(),
            self.git_url.clone(),
            self.issue_comment_url.clone(),
            self.issue_events_url.clone(),
            self.issues_url.clone(),
            self.keys_url.clone(),
            self.labels_url.clone(),
            format!("{:?}", self.languages_url),
            format!("{:?}", self.merges_url),
            self.milestones_url.clone(),
            self.notifications_url.clone(),
            self.pulls_url.clone(),
            self.releases_url.clone(),
            self.ssh_url.clone(),
            format!("{:?}", self.stargazers_url),
            self.statuses_url.clone(),
            format!("{:?}", self.subscribers_url),
            format!("{:?}", self.subscription_url),
            format!("{:?}", self.tags_url),
            format!("{:?}", self.teams_url),
            self.trees_url.clone(),
            self.clone_url.clone(),
            format!("{:?}", self.mirror_url),
            format!("{:?}", self.hooks_url),
            format!("{:?}", self.svn_url),
            format!("{:?}", self.homepage),
            format!("{:?}", self.language),
            format!("{:?}", self.forks_count),
            format!("{:?}", self.stargazers_count),
            format!("{:?}", self.watchers_count),
            format!("{:?}", self.size),
            self.default_branch.clone(),
            format!("{:?}", self.open_issues_count),
            if let Some(is_template) = &self.is_template {
                format!("{:?}", is_template)
            } else {
                String::new()
            },
            if let Some(topics) = &self.topics {
                format!("{:?}", topics)
            } else {
                String::new()
            },
            format!("{:?}", self.has_issues),
            format!("{:?}", self.has_projects),
            format!("{:?}", self.has_wiki),
            format!("{:?}", self.has_pages),
            format!("{:?}", self.has_downloads),
            format!("{:?}", self.archived),
            format!("{:?}", self.disabled),
            if let Some(visibility) = &self.visibility {
                format!("{:?}", visibility)
            } else {
                String::new()
            },
            format!("{:?}", self.pushed_at),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(allow_rebase_merge) = &self.allow_rebase_merge {
                format!("{:?}", allow_rebase_merge)
            } else {
                String::new()
            },
            if let Some(template_repository) = &self.template_repository {
                format!("{:?}", template_repository)
            } else {
                String::new()
            },
            if let Some(temp_clone_token) = &self.temp_clone_token {
                format!("{:?}", temp_clone_token)
            } else {
                String::new()
            },
            if let Some(allow_squash_merge) = &self.allow_squash_merge {
                format!("{:?}", allow_squash_merge)
            } else {
                String::new()
            },
            if let Some(allow_auto_merge) = &self.allow_auto_merge {
                format!("{:?}", allow_auto_merge)
            } else {
                String::new()
            },
            if let Some(delete_branch_on_merge) = &self.delete_branch_on_merge {
                format!("{:?}", delete_branch_on_merge)
            } else {
                String::new()
            },
            if let Some(allow_update_branch) = &self.allow_update_branch {
                format!("{:?}", allow_update_branch)
            } else {
                String::new()
            },
            if let Some(use_squash_pr_title_as_default) = &self.use_squash_pr_title_as_default {
                format!("{:?}", use_squash_pr_title_as_default)
            } else {
                String::new()
            },
            if let Some(allow_merge_commit) = &self.allow_merge_commit {
                format!("{:?}", allow_merge_commit)
            } else {
                String::new()
            },
            if let Some(allow_forking) = &self.allow_forking {
                format!("{:?}", allow_forking)
            } else {
                String::new()
            },
            if let Some(subscribers_count) = &self.subscribers_count {
                format!("{:?}", subscribers_count)
            } else {
                String::new()
            },
            if let Some(network_count) = &self.network_count {
                format!("{:?}", network_count)
            } else {
                String::new()
            },
            format!("{:?}", self.open_issues),
            format!("{:?}", self.watchers),
            if let Some(master_branch) = &self.master_branch {
                format!("{:?}", master_branch)
            } else {
                String::new()
            },
            if let Some(starred_at) = &self.starred_at {
                format!("{:?}", starred_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "full_name".to_string(),
            "license".to_string(),
            "organization".to_string(),
            "forks".to_string(),
            "permissions".to_string(),
            "owner".to_string(),
            "private".to_string(),
            "html_url".to_string(),
            "description".to_string(),
            "fork".to_string(),
            "url".to_string(),
            "archive_url".to_string(),
            "assignees_url".to_string(),
            "blobs_url".to_string(),
            "branches_url".to_string(),
            "collaborators_url".to_string(),
            "comments_url".to_string(),
            "commits_url".to_string(),
            "compare_url".to_string(),
            "contents_url".to_string(),
            "contributors_url".to_string(),
            "deployments_url".to_string(),
            "downloads_url".to_string(),
            "events_url".to_string(),
            "forks_url".to_string(),
            "git_commits_url".to_string(),
            "git_refs_url".to_string(),
            "git_tags_url".to_string(),
            "git_url".to_string(),
            "issue_comment_url".to_string(),
            "issue_events_url".to_string(),
            "issues_url".to_string(),
            "keys_url".to_string(),
            "labels_url".to_string(),
            "languages_url".to_string(),
            "merges_url".to_string(),
            "milestones_url".to_string(),
            "notifications_url".to_string(),
            "pulls_url".to_string(),
            "releases_url".to_string(),
            "ssh_url".to_string(),
            "stargazers_url".to_string(),
            "statuses_url".to_string(),
            "subscribers_url".to_string(),
            "subscription_url".to_string(),
            "tags_url".to_string(),
            "teams_url".to_string(),
            "trees_url".to_string(),
            "clone_url".to_string(),
            "mirror_url".to_string(),
            "hooks_url".to_string(),
            "svn_url".to_string(),
            "homepage".to_string(),
            "language".to_string(),
            "forks_count".to_string(),
            "stargazers_count".to_string(),
            "watchers_count".to_string(),
            "size".to_string(),
            "default_branch".to_string(),
            "open_issues_count".to_string(),
            "is_template".to_string(),
            "topics".to_string(),
            "has_issues".to_string(),
            "has_projects".to_string(),
            "has_wiki".to_string(),
            "has_pages".to_string(),
            "has_downloads".to_string(),
            "archived".to_string(),
            "disabled".to_string(),
            "visibility".to_string(),
            "pushed_at".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "allow_rebase_merge".to_string(),
            "template_repository".to_string(),
            "temp_clone_token".to_string(),
            "allow_squash_merge".to_string(),
            "allow_auto_merge".to_string(),
            "delete_branch_on_merge".to_string(),
            "allow_update_branch".to_string(),
            "use_squash_pr_title_as_default".to_string(),
            "allow_merge_commit".to_string(),
            "allow_forking".to_string(),
            "subscribers_count".to_string(),
            "network_count".to_string(),
            "open_issues".to_string(),
            "watchers".to_string(),
            "master_branch".to_string(),
            "starred_at".to_string(),
        ]
    }
}

#[doc = "Authentication token for a GitHub App installed on a user or org."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstallationToken {
    pub token: String,
    pub expires_at: String,
    #[doc = "The permissions granted to the user-to-server access token."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<AppPermissions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_selection: Option<RepositorySelection>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repositories: Option<Vec<Repository>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file_paths: Option<Vec<String>>,
}

impl std::fmt::Display for InstallationToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InstallationToken {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            self.token.clone(),
            self.expires_at.clone(),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            if let Some(repository_selection) = &self.repository_selection {
                format!("{:?}", repository_selection)
            } else {
                String::new()
            },
            if let Some(repositories) = &self.repositories {
                format!("{:?}", repositories)
            } else {
                String::new()
            },
            if let Some(single_file) = &self.single_file {
                format!("{:?}", single_file)
            } else {
                String::new()
            },
            if let Some(has_multiple_single_files) = &self.has_multiple_single_files {
                format!("{:?}", has_multiple_single_files)
            } else {
                String::new()
            },
            if let Some(single_file_paths) = &self.single_file_paths {
                format!("{:?}", single_file_paths)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "token".to_string(),
            "expires_at".to_string(),
            "permissions".to_string(),
            "repository_selection".to_string(),
            "repositories".to_string(),
            "single_file".to_string(),
            "has_multiple_single_files".to_string(),
            "single_file_paths".to_string(),
        ]
    }
}

#[doc = "The authorization associated with an OAuth Access."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApplicationGrant {
    pub id: i64,
    pub url: url::Url,
    pub app: App,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub scopes: Vec<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
}

impl std::fmt::Display for ApplicationGrant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApplicationGrant {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            format!("{:?}", self.url),
            format!("{:?}", self.app),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.scopes),
            if let Some(user) = &self.user {
                format!("{:?}", user)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "url".to_string(),
            "app".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "scopes".to_string(),
            "user".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableScopedInstallation {
    #[doc = "The permissions granted to the user-to-server access token."]
    pub permissions: AppPermissions,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: RepositorySelection,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file_paths: Option<Vec<String>>,
    pub repositories_url: url::Url,
    #[doc = "Simple User"]
    pub account: SimpleUser,
}

impl std::fmt::Display for NullableScopedInstallation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableScopedInstallation {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.permissions),
            format!("{:?}", self.repository_selection),
            format!("{:?}", self.single_file_name),
            if let Some(has_multiple_single_files) = &self.has_multiple_single_files {
                format!("{:?}", has_multiple_single_files)
            } else {
                String::new()
            },
            if let Some(single_file_paths) = &self.single_file_paths {
                format!("{:?}", single_file_paths)
            } else {
                String::new()
            },
            format!("{:?}", self.repositories_url),
            format!("{:?}", self.account),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "permissions".to_string(),
            "repository_selection".to_string(),
            "single_file_name".to_string(),
            "has_multiple_single_files".to_string(),
            "single_file_paths".to_string(),
            "repositories_url".to_string(),
            "account".to_string(),
        ]
    }
}

#[doc = "The authorization for an OAuth app, GitHub App, or a Personal Access Token."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Authorization {
    pub id: i64,
    pub url: url::Url,
    #[doc = "A list of scopes that this authorization is in."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    pub token: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token_last_eight: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hashed_token: Option<String>,
    pub app: App,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub note_url: Option<url::Url>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fingerprint: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<NullableScopedInstallation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for Authorization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Authorization {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            format!("{:?}", self.url),
            format!("{:?}", self.scopes),
            self.token.clone(),
            format!("{:?}", self.token_last_eight),
            format!("{:?}", self.hashed_token),
            format!("{:?}", self.app),
            format!("{:?}", self.note),
            format!("{:?}", self.note_url),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.created_at),
            format!("{:?}", self.fingerprint),
            if let Some(user) = &self.user {
                format!("{:?}", user)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.expires_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "url".to_string(),
            "scopes".to_string(),
            "token".to_string(),
            "token_last_eight".to_string(),
            "hashed_token".to_string(),
            "app".to_string(),
            "note".to_string(),
            "note_url".to_string(),
            "updated_at".to_string(),
            "created_at".to_string(),
            "fingerprint".to_string(),
            "user".to_string(),
            "installation".to_string(),
            "expires_at".to_string(),
        ]
    }
}

#[doc = "A git repository"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ClassroomRepository {
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "The name of the repository."]
    pub name: String,
    pub full_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner: Option<Owner>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub collaborators_url: Option<String>,
    pub commits_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub downloads_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub events_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues_url: Option<String>,
    pub pulls_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ssh_url: Option<String>,
    pub teams_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    pub size: i64,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    pub open_issues_count: i64,
    #[doc = "Whether this repository acts as a template that can be used to generate new repositories."]
    pub is_template: bool,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub clone_url: String,
    #[doc = "Returns whether or not this repository disabled."]
    pub disabled: bool,
    #[doc = "The repository visibility: public, private, or internal."]
    pub visibility: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub classroom_assignment: Option<ClassroomAssignment>,
}

impl std::fmt::Display for ClassroomRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ClassroomRepository {
    const LENGTH: usize = 35;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            if let Some(node_id) = &self.node_id {
                format!("{:?}", node_id)
            } else {
                String::new()
            },
            self.name.clone(),
            self.full_name.clone(),
            format!("{:?}", self.owner),
            format!("{:?}", self.private),
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
            format!("{:?}", self.description),
            format!("{:?}", self.url),
            if let Some(branches_url) = &self.branches_url {
                format!("{:?}", branches_url)
            } else {
                String::new()
            },
            if let Some(collaborators_url) = &self.collaborators_url {
                format!("{:?}", collaborators_url)
            } else {
                String::new()
            },
            self.commits_url.clone(),
            if let Some(contents_url) = &self.contents_url {
                format!("{:?}", contents_url)
            } else {
                String::new()
            },
            if let Some(downloads_url) = &self.downloads_url {
                format!("{:?}", downloads_url)
            } else {
                String::new()
            },
            if let Some(events_url) = &self.events_url {
                format!("{:?}", events_url)
            } else {
                String::new()
            },
            if let Some(git_url) = &self.git_url {
                format!("{:?}", git_url)
            } else {
                String::new()
            },
            if let Some(issue_events_url) = &self.issue_events_url {
                format!("{:?}", issue_events_url)
            } else {
                String::new()
            },
            if let Some(issues_url) = &self.issues_url {
                format!("{:?}", issues_url)
            } else {
                String::new()
            },
            self.pulls_url.clone(),
            if let Some(ssh_url) = &self.ssh_url {
                format!("{:?}", ssh_url)
            } else {
                String::new()
            },
            format!("{:?}", self.teams_url),
            if let Some(homepage) = &self.homepage {
                format!("{:?}", homepage)
            } else {
                String::new()
            },
            format!("{:?}", self.language),
            format!("{:?}", self.size),
            self.default_branch.clone(),
            format!("{:?}", self.open_issues_count),
            format!("{:?}", self.is_template),
            format!("{:?}", self.archived),
            self.clone_url.clone(),
            format!("{:?}", self.disabled),
            self.visibility.clone(),
            format!("{:?}", self.pushed_at),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.classroom_assignment),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "full_name".to_string(),
            "owner".to_string(),
            "private".to_string(),
            "html_url".to_string(),
            "description".to_string(),
            "url".to_string(),
            "branches_url".to_string(),
            "collaborators_url".to_string(),
            "commits_url".to_string(),
            "contents_url".to_string(),
            "downloads_url".to_string(),
            "events_url".to_string(),
            "git_url".to_string(),
            "issue_events_url".to_string(),
            "issues_url".to_string(),
            "pulls_url".to_string(),
            "ssh_url".to_string(),
            "teams_url".to_string(),
            "homepage".to_string(),
            "language".to_string(),
            "size".to_string(),
            "default_branch".to_string(),
            "open_issues_count".to_string(),
            "is_template".to_string(),
            "archived".to_string(),
            "clone_url".to_string(),
            "disabled".to_string(),
            "visibility".to_string(),
            "pushed_at".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "classroom_assignment".to_string(),
        ]
    }
}

#[doc = "Code Of Conduct"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeOfConduct {
    pub key: String,
    pub name: String,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
}

impl std::fmt::Display for CodeOfConduct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeOfConduct {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            self.key.clone(),
            self.name.clone(),
            format!("{:?}", self.url),
            if let Some(body) = &self.body {
                format!("{:?}", body)
            } else {
                String::new()
            },
            format!("{:?}", self.html_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "key".to_string(),
            "name".to_string(),
            "url".to_string(),
            "body".to_string(),
            "html_url".to_string(),
        ]
    }
}

#[doc = "Response of S4 Proxy endpoint that provides GHES statistics"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ServerStatistics {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub collection_date: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schema_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghes_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub github_connect: Option<GithubConnect>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghe_stats: Option<GheStats>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dormant_users: Option<DormantUsers>,
}

impl std::fmt::Display for ServerStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ServerStatistics {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(server_id) = &self.server_id {
                format!("{:?}", server_id)
            } else {
                String::new()
            },
            if let Some(collection_date) = &self.collection_date {
                format!("{:?}", collection_date)
            } else {
                String::new()
            },
            if let Some(schema_version) = &self.schema_version {
                format!("{:?}", schema_version)
            } else {
                String::new()
            },
            if let Some(ghes_version) = &self.ghes_version {
                format!("{:?}", ghes_version)
            } else {
                String::new()
            },
            if let Some(host_name) = &self.host_name {
                format!("{:?}", host_name)
            } else {
                String::new()
            },
            if let Some(github_connect) = &self.github_connect {
                format!("{:?}", github_connect)
            } else {
                String::new()
            },
            if let Some(ghe_stats) = &self.ghe_stats {
                format!("{:?}", ghe_stats)
            } else {
                String::new()
            },
            if let Some(dormant_users) = &self.dormant_users {
                format!("{:?}", dormant_users)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "server_id".to_string(),
            "collection_date".to_string(),
            "schema_version".to_string(),
            "ghes_version".to_string(),
            "host_name".to_string(),
            "github_connect".to_string(),
            "ghe_stats".to_string(),
            "dormant_users".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsCacheUsageOrgEnterprise {
    #[doc = "The count of active caches across all repositories of an enterprise or an organization."]
    pub total_active_caches_count: i64,
    #[doc = "The total size in bytes of all active cache items across all repositories of an enterprise or an organization."]
    pub total_active_caches_size_in_bytes: i64,
}

impl std::fmt::Display for ActionsCacheUsageOrgEnterprise {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsCacheUsageOrgEnterprise {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.total_active_caches_count),
            format!("{:?}", self.total_active_caches_size_in_bytes),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "total_active_caches_count".to_string(),
            "total_active_caches_size_in_bytes".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsOidcCustomIssuerPolicyForEnterprise {
    #[doc = "Whether the enterprise customer requested a custom issuer URL."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub include_enterprise_slug: Option<bool>,
}

impl std::fmt::Display for ActionsOidcCustomIssuerPolicyForEnterprise {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsOidcCustomIssuerPolicyForEnterprise {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(include_enterprise_slug) = &self.include_enterprise_slug {
                format!("{:?}", include_enterprise_slug)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["include_enterprise_slug".to_string()]
    }
}

#[doc = "The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum EnabledOrganizations {
    #[serde(rename = "all")]
    #[display("all")]
    All,
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[serde(rename = "selected")]
    #[display("selected")]
    Selected,
}

#[doc = "The permissions policy that controls the actions and reusable workflows that are allowed to run."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum AllowedActions {
    #[serde(rename = "all")]
    #[display("all")]
    All,
    #[serde(rename = "local_only")]
    #[display("local_only")]
    LocalOnly,
    #[serde(rename = "selected")]
    #[display("selected")]
    Selected,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsEnterprisePermissions {
    #[doc = "The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions."]
    pub enabled_organizations: EnabledOrganizations,
    #[doc = "The API URL to use to get or set the selected organizations that are allowed to run GitHub Actions, when `enabled_organizations` is set to `selected`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_organizations_url: Option<String>,
    #[doc = "The permissions policy that controls the actions and reusable workflows that are allowed to run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allowed_actions: Option<AllowedActions>,
    #[doc = "The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_actions_url: Option<String>,
}

impl std::fmt::Display for ActionsEnterprisePermissions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsEnterprisePermissions {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.enabled_organizations),
            if let Some(selected_organizations_url) = &self.selected_organizations_url {
                format!("{:?}", selected_organizations_url)
            } else {
                String::new()
            },
            if let Some(allowed_actions) = &self.allowed_actions {
                format!("{:?}", allowed_actions)
            } else {
                String::new()
            },
            if let Some(selected_actions_url) = &self.selected_actions_url {
                format!("{:?}", selected_actions_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enabled_organizations".to_string(),
            "selected_organizations_url".to_string(),
            "allowed_actions".to_string(),
            "selected_actions_url".to_string(),
        ]
    }
}

#[doc = "Organization Simple"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationSimple {
    pub login: String,
    pub id: i64,
    pub node_id: String,
    pub url: url::Url,
    pub repos_url: url::Url,
    pub events_url: url::Url,
    pub hooks_url: String,
    pub issues_url: String,
    pub members_url: String,
    pub public_members_url: String,
    pub avatar_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

impl std::fmt::Display for OrganizationSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationSimple {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            self.login.clone(),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.repos_url),
            format!("{:?}", self.events_url),
            self.hooks_url.clone(),
            self.issues_url.clone(),
            self.members_url.clone(),
            self.public_members_url.clone(),
            self.avatar_url.clone(),
            format!("{:?}", self.description),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "login".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "repos_url".to_string(),
            "events_url".to_string(),
            "hooks_url".to_string(),
            "issues_url".to_string(),
            "members_url".to_string(),
            "public_members_url".to_string(),
            "avatar_url".to_string(),
            "description".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SelectedActions {
    #[doc = "Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub github_owned_allowed: Option<bool>,
    #[doc = "Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verified_allowed: Option<bool>,
    #[doc = "Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.\""]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patterns_allowed: Option<Vec<String>>,
}

impl std::fmt::Display for SelectedActions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SelectedActions {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(github_owned_allowed) = &self.github_owned_allowed {
                format!("{:?}", github_owned_allowed)
            } else {
                String::new()
            },
            if let Some(verified_allowed) = &self.verified_allowed {
                format!("{:?}", verified_allowed)
            } else {
                String::new()
            },
            if let Some(patterns_allowed) = &self.patterns_allowed {
                format!("{:?}", patterns_allowed)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "github_owned_allowed".to_string(),
            "verified_allowed".to_string(),
            "patterns_allowed".to_string(),
        ]
    }
}

#[doc = "The default workflow permissions granted to the GITHUB_TOKEN when running workflows."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ActionsDefaultWorkflowPermissions {
    #[serde(rename = "read")]
    #[display("read")]
    Read,
    #[serde(rename = "write")]
    #[display("write")]
    Write,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsGetDefaultWorkflowPermissions {
    #[doc = "The default workflow permissions granted to the GITHUB_TOKEN when running workflows."]
    pub default_workflow_permissions: ActionsDefaultWorkflowPermissions,
    #[doc = "Whether GitHub Actions can approve pull requests. Enabling this can be a security risk."]
    pub can_approve_pull_request_reviews: bool,
}

impl std::fmt::Display for ActionsGetDefaultWorkflowPermissions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsGetDefaultWorkflowPermissions {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.default_workflow_permissions),
            format!("{:?}", self.can_approve_pull_request_reviews),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "default_workflow_permissions".to_string(),
            "can_approve_pull_request_reviews".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsSetDefaultWorkflowPermissions {
    #[doc = "The default workflow permissions granted to the GITHUB_TOKEN when running workflows."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_workflow_permissions: Option<ActionsDefaultWorkflowPermissions>,
    #[doc = "Whether GitHub Actions can approve pull requests. Enabling this can be a security risk."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub can_approve_pull_request_reviews: Option<bool>,
}

impl std::fmt::Display for ActionsSetDefaultWorkflowPermissions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsSetDefaultWorkflowPermissions {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(default_workflow_permissions) = &self.default_workflow_permissions {
                format!("{:?}", default_workflow_permissions)
            } else {
                String::new()
            },
            if let Some(can_approve_pull_request_reviews) = &self.can_approve_pull_request_reviews {
                format!("{:?}", can_approve_pull_request_reviews)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "default_workflow_permissions".to_string(),
            "can_approve_pull_request_reviews".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RunnerGroupsEnterprise {
    pub id: f64,
    pub name: String,
    pub visibility: String,
    pub default: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_organizations_url: Option<String>,
    pub runners_url: String,
    pub allows_public_repositories: bool,
    #[doc = "If `true`, the `restricted_to_workflows` and `selected_workflows` fields cannot be modified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_restrictions_read_only: Option<bool>,
    #[doc = "If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restricted_to_workflows: Option<bool>,
    #[doc = "List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_workflows: Option<Vec<String>>,
}

impl std::fmt::Display for RunnerGroupsEnterprise {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RunnerGroupsEnterprise {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.name.clone(),
            self.visibility.clone(),
            format!("{:?}", self.default),
            if let Some(selected_organizations_url) = &self.selected_organizations_url {
                format!("{:?}", selected_organizations_url)
            } else {
                String::new()
            },
            self.runners_url.clone(),
            format!("{:?}", self.allows_public_repositories),
            if let Some(workflow_restrictions_read_only) = &self.workflow_restrictions_read_only {
                format!("{:?}", workflow_restrictions_read_only)
            } else {
                String::new()
            },
            if let Some(restricted_to_workflows) = &self.restricted_to_workflows {
                format!("{:?}", restricted_to_workflows)
            } else {
                String::new()
            },
            if let Some(selected_workflows) = &self.selected_workflows {
                format!("{:?}", selected_workflows)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "name".to_string(),
            "visibility".to_string(),
            "default".to_string(),
            "selected_organizations_url".to_string(),
            "runners_url".to_string(),
            "allows_public_repositories".to_string(),
            "workflow_restrictions_read_only".to_string(),
            "restricted_to_workflows".to_string(),
            "selected_workflows".to_string(),
        ]
    }
}

#[doc = "A label for a self hosted runner"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RunnerLabel {
    #[doc = "Unique identifier of the label."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[doc = "Name of the label."]
    pub name: String,
    #[doc = "The type of label. Read-only labels are applied automatically when the runner is configured."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<Type>,
}

impl std::fmt::Display for RunnerLabel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RunnerLabel {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            self.name.clone(),
            if let Some(type_) = &self.type_ {
                format!("{:?}", type_)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["id".to_string(), "name".to_string(), "type_".to_string()]
    }
}

#[doc = "A self hosted runner"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Runner {
    #[doc = "The id of the runner."]
    pub id: i64,
    #[doc = "The name of the runner."]
    pub name: String,
    #[doc = "The Operating System of the runner."]
    pub os: String,
    #[doc = "The status of the runner."]
    pub status: String,
    pub busy: bool,
    pub labels: Vec<RunnerLabel>,
}

impl std::fmt::Display for Runner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Runner {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.name.clone(),
            self.os.clone(),
            self.status.clone(),
            format!("{:?}", self.busy),
            format!("{:?}", self.labels),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "name".to_string(),
            "os".to_string(),
            "status".to_string(),
            "busy".to_string(),
            "labels".to_string(),
        ]
    }
}

#[doc = "Runner Application"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RunnerApplication {
    pub os: String,
    pub architecture: String,
    pub download_url: String,
    pub filename: String,
    #[doc = "A short lived bearer token used to download the runner, if needed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub temp_download_token: Option<String>,
    #[serde(
        rename = "sha256_checksum",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sha_256_checksum: Option<String>,
}

impl std::fmt::Display for RunnerApplication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RunnerApplication {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            self.os.clone(),
            self.architecture.clone(),
            self.download_url.clone(),
            self.filename.clone(),
            if let Some(temp_download_token) = &self.temp_download_token {
                format!("{:?}", temp_download_token)
            } else {
                String::new()
            },
            if let Some(sha_256_checksum) = &self.sha_256_checksum {
                format!("{:?}", sha_256_checksum)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "os".to_string(),
            "architecture".to_string(),
            "download_url".to_string(),
            "filename".to_string(),
            "temp_download_token".to_string(),
            "sha_256_checksum".to_string(),
        ]
    }
}

#[doc = "Authentication Token"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AuthenticationToken {
    #[doc = "The token used for authentication"]
    pub token: String,
    #[doc = "The time this token expires"]
    pub expires_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    #[doc = "The repositories this token has access to"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repositories: Option<Vec<Repository>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<String>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_selection: Option<RepositorySelection>,
}

impl std::fmt::Display for AuthenticationToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for AuthenticationToken {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            self.token.clone(),
            format!("{:?}", self.expires_at),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            if let Some(repositories) = &self.repositories {
                format!("{:?}", repositories)
            } else {
                String::new()
            },
            if let Some(single_file) = &self.single_file {
                format!("{:?}", single_file)
            } else {
                String::new()
            },
            if let Some(repository_selection) = &self.repository_selection {
                format!("{:?}", repository_selection)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "token".to_string(),
            "expires_at".to_string(),
            "permissions".to_string(),
            "repositories".to_string(),
            "single_file".to_string(),
            "repository_selection".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AuditLogEvent {
    #[doc = "The time the audit log event occurred, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time)."]
    #[serde(
        rename = "@timestamp",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub timestamp: Option<i64>,
    #[doc = "The name of the action that was performed, for example `user.login` or `repo.create`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active_was: Option<bool>,
    #[doc = "The actor who performed the action."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actor: Option<String>,
    #[doc = "The id of the actor who performed the action."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actor_id: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actor_location: Option<ActorLocation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<Data>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub org_id: Option<i64>,
    #[doc = "The username of the account being blocked."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blocked_user: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub business: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<Vec<Config>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config_was: Option<Vec<ConfigWas>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,
    #[doc = "The time the audit log event was recorded, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deploy_key_fingerprint: Option<String>,
    #[doc = "A unique identifier for an audit event."]
    #[serde(
        rename = "_document_id",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub document_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emoji: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub events: Option<Vec<Events>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub events_were: Option<Vec<EventsWere>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub explanation: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fingerprint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hook_id: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limited_availability: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub old_user: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub openssh_public_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub org: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_visibility: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub read_only: Option<bool>,
    #[doc = "The name of the repository."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repo: Option<String>,
    #[doc = "The name of the repository."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_public: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target_login: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub team: Option<String>,
    #[doc = "The type of protocol (for example, HTTP or SSH) used to transfer Git data."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transport_protocol: Option<i64>,
    #[doc = "A human readable name for the protocol (for example, HTTP or SSH) used to transfer Git data."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transport_protocol_name: Option<String>,
    #[doc = "The user that was affected by the action performed (if available)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    #[doc = "The repository visibility, for example `public` or `private`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub visibility: Option<String>,
}

impl std::fmt::Display for AuditLogEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for AuditLogEvent {
    const LENGTH: usize = 40;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(timestamp) = &self.timestamp {
                format!("{:?}", timestamp)
            } else {
                String::new()
            },
            if let Some(action) = &self.action {
                format!("{:?}", action)
            } else {
                String::new()
            },
            if let Some(active) = &self.active {
                format!("{:?}", active)
            } else {
                String::new()
            },
            if let Some(active_was) = &self.active_was {
                format!("{:?}", active_was)
            } else {
                String::new()
            },
            if let Some(actor) = &self.actor {
                format!("{:?}", actor)
            } else {
                String::new()
            },
            if let Some(actor_id) = &self.actor_id {
                format!("{:?}", actor_id)
            } else {
                String::new()
            },
            if let Some(actor_location) = &self.actor_location {
                format!("{:?}", actor_location)
            } else {
                String::new()
            },
            if let Some(data) = &self.data {
                format!("{:?}", data)
            } else {
                String::new()
            },
            if let Some(org_id) = &self.org_id {
                format!("{:?}", org_id)
            } else {
                String::new()
            },
            if let Some(blocked_user) = &self.blocked_user {
                format!("{:?}", blocked_user)
            } else {
                String::new()
            },
            if let Some(business) = &self.business {
                format!("{:?}", business)
            } else {
                String::new()
            },
            if let Some(config) = &self.config {
                format!("{:?}", config)
            } else {
                String::new()
            },
            if let Some(config_was) = &self.config_was {
                format!("{:?}", config_was)
            } else {
                String::new()
            },
            if let Some(content_type) = &self.content_type {
                format!("{:?}", content_type)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
            if let Some(deploy_key_fingerprint) = &self.deploy_key_fingerprint {
                format!("{:?}", deploy_key_fingerprint)
            } else {
                String::new()
            },
            if let Some(document_id) = &self.document_id {
                format!("{:?}", document_id)
            } else {
                String::new()
            },
            if let Some(emoji) = &self.emoji {
                format!("{:?}", emoji)
            } else {
                String::new()
            },
            if let Some(events) = &self.events {
                format!("{:?}", events)
            } else {
                String::new()
            },
            if let Some(events_were) = &self.events_were {
                format!("{:?}", events_were)
            } else {
                String::new()
            },
            if let Some(explanation) = &self.explanation {
                format!("{:?}", explanation)
            } else {
                String::new()
            },
            if let Some(fingerprint) = &self.fingerprint {
                format!("{:?}", fingerprint)
            } else {
                String::new()
            },
            if let Some(hook_id) = &self.hook_id {
                format!("{:?}", hook_id)
            } else {
                String::new()
            },
            if let Some(limited_availability) = &self.limited_availability {
                format!("{:?}", limited_availability)
            } else {
                String::new()
            },
            if let Some(message) = &self.message {
                format!("{:?}", message)
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(old_user) = &self.old_user {
                format!("{:?}", old_user)
            } else {
                String::new()
            },
            if let Some(openssh_public_key) = &self.openssh_public_key {
                format!("{:?}", openssh_public_key)
            } else {
                String::new()
            },
            if let Some(org) = &self.org {
                format!("{:?}", org)
            } else {
                String::new()
            },
            if let Some(previous_visibility) = &self.previous_visibility {
                format!("{:?}", previous_visibility)
            } else {
                String::new()
            },
            if let Some(read_only) = &self.read_only {
                format!("{:?}", read_only)
            } else {
                String::new()
            },
            if let Some(repo) = &self.repo {
                format!("{:?}", repo)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(repository_public) = &self.repository_public {
                format!("{:?}", repository_public)
            } else {
                String::new()
            },
            if let Some(target_login) = &self.target_login {
                format!("{:?}", target_login)
            } else {
                String::new()
            },
            if let Some(team) = &self.team {
                format!("{:?}", team)
            } else {
                String::new()
            },
            if let Some(transport_protocol) = &self.transport_protocol {
                format!("{:?}", transport_protocol)
            } else {
                String::new()
            },
            if let Some(transport_protocol_name) = &self.transport_protocol_name {
                format!("{:?}", transport_protocol_name)
            } else {
                String::new()
            },
            if let Some(user) = &self.user {
                format!("{:?}", user)
            } else {
                String::new()
            },
            if let Some(visibility) = &self.visibility {
                format!("{:?}", visibility)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "timestamp".to_string(),
            "action".to_string(),
            "active".to_string(),
            "active_was".to_string(),
            "actor".to_string(),
            "actor_id".to_string(),
            "actor_location".to_string(),
            "data".to_string(),
            "org_id".to_string(),
            "blocked_user".to_string(),
            "business".to_string(),
            "config".to_string(),
            "config_was".to_string(),
            "content_type".to_string(),
            "created_at".to_string(),
            "deploy_key_fingerprint".to_string(),
            "document_id".to_string(),
            "emoji".to_string(),
            "events".to_string(),
            "events_were".to_string(),
            "explanation".to_string(),
            "fingerprint".to_string(),
            "hook_id".to_string(),
            "limited_availability".to_string(),
            "message".to_string(),
            "name".to_string(),
            "old_user".to_string(),
            "openssh_public_key".to_string(),
            "org".to_string(),
            "previous_visibility".to_string(),
            "read_only".to_string(),
            "repo".to_string(),
            "repository".to_string(),
            "repository_public".to_string(),
            "target_login".to_string(),
            "team".to_string(),
            "transport_protocol".to_string(),
            "transport_protocol_name".to_string(),
            "user".to_string(),
            "visibility".to_string(),
        ]
    }
}

#[doc = "State of a code scanning alert."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CodeScanningAlertState {
    #[serde(rename = "open")]
    #[display("open")]
    Open,
    #[serde(rename = "closed")]
    #[display("closed")]
    Closed,
    #[serde(rename = "dismissed")]
    #[display("dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    #[display("fixed")]
    Fixed,
}

#[doc = "**Required when the state is dismissed.** The reason for dismissing or closing the alert."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CodeScanningAlertDismissedReason {
    #[serde(rename = "false positive")]
    #[display("false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    #[display("won't fix")]
    WonTFix,
    #[serde(rename = "used in tests")]
    #[display("used in tests")]
    UsedInTests,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertRule {
    #[doc = "A unique identifier for the rule used to detect the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The name of the rule used to detect the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<Severity>,
    #[doc = "The security severity of the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_severity_level: Option<SecuritySeverityLevel>,
    #[doc = "A short description of the rule used to detect the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "description of the rule used to detect the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[doc = "A set of tags applicable for the rule."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    #[doc = "Detailed documentation for the rule as GitHub Flavored Markdown."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub help: Option<String>,
}

impl std::fmt::Display for CodeScanningAlertRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertRule {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(severity) = &self.severity {
                format!("{:?}", severity)
            } else {
                String::new()
            },
            if let Some(security_severity_level) = &self.security_severity_level {
                format!("{:?}", security_severity_level)
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{:?}", description)
            } else {
                String::new()
            },
            if let Some(full_description) = &self.full_description {
                format!("{:?}", full_description)
            } else {
                String::new()
            },
            if let Some(tags) = &self.tags {
                format!("{:?}", tags)
            } else {
                String::new()
            },
            if let Some(help) = &self.help {
                format!("{:?}", help)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "name".to_string(),
            "severity".to_string(),
            "security_severity_level".to_string(),
            "description".to_string(),
            "full_description".to_string(),
            "tags".to_string(),
            "help".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAnalysisTool {
    #[doc = "The name of the tool used to generate the code scanning analysis."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The version of the tool used to generate the code scanning analysis."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    #[doc = "The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
}

impl std::fmt::Display for CodeScanningAnalysisTool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAnalysisTool {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(version) = &self.version {
                format!("{:?}", version)
            } else {
                String::new()
            },
            if let Some(guid) = &self.guid {
                format!("{:?}", guid)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "version".to_string(),
            "guid".to_string(),
        ]
    }
}

#[doc = "Describe a region within a file for the alert."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertLocation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_column: Option<i64>,
}

impl std::fmt::Display for CodeScanningAlertLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertLocation {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(path) = &self.path {
                format!("{:?}", path)
            } else {
                String::new()
            },
            if let Some(start_line) = &self.start_line {
                format!("{:?}", start_line)
            } else {
                String::new()
            },
            if let Some(end_line) = &self.end_line {
                format!("{:?}", end_line)
            } else {
                String::new()
            },
            if let Some(start_column) = &self.start_column {
                format!("{:?}", start_column)
            } else {
                String::new()
            },
            if let Some(end_column) = &self.end_column {
                format!("{:?}", end_column)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "path".to_string(),
            "start_line".to_string(),
            "end_line".to_string(),
            "start_column".to_string(),
            "end_column".to_string(),
        ]
    }
}

#[doc = "A classification of the file. For example to identify it as generated."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CodeScanningAlertClassification {
    #[serde(rename = "source")]
    #[display("source")]
    Source,
    #[serde(rename = "generated")]
    #[display("generated")]
    Generated,
    #[serde(rename = "test")]
    #[display("test")]
    Test,
    #[serde(rename = "library")]
    #[display("library")]
    Library,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertInstance {
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`."]
    #[serde(rename = "ref", default, skip_serializing_if = "Option::is_none")]
    pub ref_: Option<String>,
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub analysis_key: Option<String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environment: Option<String>,
    #[doc = "Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<String>,
    #[doc = "State of a code scanning alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<CodeScanningAlertState>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_sha: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<Message>,
    #[doc = "Describe a region within a file for the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<CodeScanningAlertLocation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[doc = "Classifications that have been applied to the file that triggered the alert.\nFor example identifying it as documentation, or a generated file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub classifications: Option<Vec<Option<CodeScanningAlertClassification>>>,
}

impl std::fmt::Display for CodeScanningAlertInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertInstance {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(ref_) = &self.ref_ {
                format!("{:?}", ref_)
            } else {
                String::new()
            },
            if let Some(analysis_key) = &self.analysis_key {
                format!("{:?}", analysis_key)
            } else {
                String::new()
            },
            if let Some(environment) = &self.environment {
                format!("{:?}", environment)
            } else {
                String::new()
            },
            if let Some(category) = &self.category {
                format!("{:?}", category)
            } else {
                String::new()
            },
            if let Some(state) = &self.state {
                format!("{:?}", state)
            } else {
                String::new()
            },
            if let Some(commit_sha) = &self.commit_sha {
                format!("{:?}", commit_sha)
            } else {
                String::new()
            },
            if let Some(message) = &self.message {
                format!("{:?}", message)
            } else {
                String::new()
            },
            if let Some(location) = &self.location {
                format!("{:?}", location)
            } else {
                String::new()
            },
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
            if let Some(classifications) = &self.classifications {
                format!("{:?}", classifications)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "ref_".to_string(),
            "analysis_key".to_string(),
            "environment".to_string(),
            "category".to_string(),
            "state".to_string(),
            "commit_sha".to_string(),
            "message".to_string(),
            "location".to_string(),
            "html_url".to_string(),
            "classifications".to_string(),
        ]
    }
}

#[doc = "Simple Repository"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SimpleRepository {
    #[doc = "A unique identifier of the repository."]
    pub id: i64,
    #[doc = "The GraphQL identifier of the repository."]
    pub node_id: String,
    #[doc = "The name of the repository."]
    pub name: String,
    #[doc = "The full, globally unique, name of the repository."]
    pub full_name: String,
    #[doc = "Simple User"]
    pub owner: SimpleUser,
    #[doc = "Whether the repository is private."]
    pub private: bool,
    #[doc = "The URL to view the repository on GitHub.com."]
    pub html_url: url::Url,
    #[doc = "The repository description."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "Whether the repository is a fork."]
    pub fork: bool,
    #[doc = "The URL to get more information about the repository from the GitHub API."]
    pub url: url::Url,
    #[doc = "A template for the API URL to download the repository as an archive."]
    pub archive_url: String,
    #[doc = "A template for the API URL to list the available assignees for issues in the repository."]
    pub assignees_url: String,
    #[doc = "A template for the API URL to create or retrieve a raw Git blob in the repository."]
    pub blobs_url: String,
    #[doc = "A template for the API URL to get information about branches in the repository."]
    pub branches_url: String,
    #[doc = "A template for the API URL to get information about collaborators of the repository."]
    pub collaborators_url: String,
    #[doc = "A template for the API URL to get information about comments on the repository."]
    pub comments_url: String,
    #[doc = "A template for the API URL to get information about commits on the repository."]
    pub commits_url: String,
    #[doc = "A template for the API URL to compare two commits or refs."]
    pub compare_url: String,
    #[doc = "A template for the API URL to get the contents of the repository."]
    pub contents_url: String,
    #[doc = "A template for the API URL to list the contributors to the repository."]
    pub contributors_url: url::Url,
    #[doc = "The API URL to list the deployments of the repository."]
    pub deployments_url: url::Url,
    #[doc = "The API URL to list the downloads on the repository."]
    pub downloads_url: url::Url,
    #[doc = "The API URL to list the events of the repository."]
    pub events_url: url::Url,
    #[doc = "The API URL to list the forks of the repository."]
    pub forks_url: url::Url,
    #[doc = "A template for the API URL to get information about Git commits of the repository."]
    pub git_commits_url: String,
    #[doc = "A template for the API URL to get information about Git refs of the repository."]
    pub git_refs_url: String,
    #[doc = "A template for the API URL to get information about Git tags of the repository."]
    pub git_tags_url: String,
    #[doc = "A template for the API URL to get information about issue comments on the repository."]
    pub issue_comment_url: String,
    #[doc = "A template for the API URL to get information about issue events on the repository."]
    pub issue_events_url: String,
    #[doc = "A template for the API URL to get information about issues on the repository."]
    pub issues_url: String,
    #[doc = "A template for the API URL to get information about deploy keys on the repository."]
    pub keys_url: String,
    #[doc = "A template for the API URL to get information about labels of the repository."]
    pub labels_url: String,
    #[doc = "The API URL to get information about the languages of the repository."]
    pub languages_url: url::Url,
    #[doc = "The API URL to merge branches in the repository."]
    pub merges_url: url::Url,
    #[doc = "A template for the API URL to get information about milestones of the repository."]
    pub milestones_url: String,
    #[doc = "A template for the API URL to get information about notifications on the repository."]
    pub notifications_url: String,
    #[doc = "A template for the API URL to get information about pull requests on the repository."]
    pub pulls_url: String,
    #[doc = "A template for the API URL to get information about releases on the repository."]
    pub releases_url: String,
    #[doc = "The API URL to list the stargazers on the repository."]
    pub stargazers_url: url::Url,
    #[doc = "A template for the API URL to get information about statuses of a commit."]
    pub statuses_url: String,
    #[doc = "The API URL to list the subscribers on the repository."]
    pub subscribers_url: url::Url,
    #[doc = "The API URL to subscribe to notifications for this repository."]
    pub subscription_url: url::Url,
    #[doc = "The API URL to get information about tags on the repository."]
    pub tags_url: url::Url,
    #[doc = "The API URL to list the teams on the repository."]
    pub teams_url: url::Url,
    #[doc = "A template for the API URL to create or retrieve a raw Git tree of the repository."]
    pub trees_url: String,
    #[doc = "The API URL to list the hooks on the repository."]
    pub hooks_url: url::Url,
}

impl std::fmt::Display for SimpleRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SimpleRepository {
    const LENGTH: usize = 46;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.full_name.clone(),
            format!("{:?}", self.owner),
            format!("{:?}", self.private),
            format!("{:?}", self.html_url),
            format!("{:?}", self.description),
            format!("{:?}", self.fork),
            format!("{:?}", self.url),
            self.archive_url.clone(),
            self.assignees_url.clone(),
            self.blobs_url.clone(),
            self.branches_url.clone(),
            self.collaborators_url.clone(),
            self.comments_url.clone(),
            self.commits_url.clone(),
            self.compare_url.clone(),
            self.contents_url.clone(),
            format!("{:?}", self.contributors_url),
            format!("{:?}", self.deployments_url),
            format!("{:?}", self.downloads_url),
            format!("{:?}", self.events_url),
            format!("{:?}", self.forks_url),
            self.git_commits_url.clone(),
            self.git_refs_url.clone(),
            self.git_tags_url.clone(),
            self.issue_comment_url.clone(),
            self.issue_events_url.clone(),
            self.issues_url.clone(),
            self.keys_url.clone(),
            self.labels_url.clone(),
            format!("{:?}", self.languages_url),
            format!("{:?}", self.merges_url),
            self.milestones_url.clone(),
            self.notifications_url.clone(),
            self.pulls_url.clone(),
            self.releases_url.clone(),
            format!("{:?}", self.stargazers_url),
            self.statuses_url.clone(),
            format!("{:?}", self.subscribers_url),
            format!("{:?}", self.subscription_url),
            format!("{:?}", self.tags_url),
            format!("{:?}", self.teams_url),
            self.trees_url.clone(),
            format!("{:?}", self.hooks_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "full_name".to_string(),
            "owner".to_string(),
            "private".to_string(),
            "html_url".to_string(),
            "description".to_string(),
            "fork".to_string(),
            "url".to_string(),
            "archive_url".to_string(),
            "assignees_url".to_string(),
            "blobs_url".to_string(),
            "branches_url".to_string(),
            "collaborators_url".to_string(),
            "comments_url".to_string(),
            "commits_url".to_string(),
            "compare_url".to_string(),
            "contents_url".to_string(),
            "contributors_url".to_string(),
            "deployments_url".to_string(),
            "downloads_url".to_string(),
            "events_url".to_string(),
            "forks_url".to_string(),
            "git_commits_url".to_string(),
            "git_refs_url".to_string(),
            "git_tags_url".to_string(),
            "issue_comment_url".to_string(),
            "issue_events_url".to_string(),
            "issues_url".to_string(),
            "keys_url".to_string(),
            "labels_url".to_string(),
            "languages_url".to_string(),
            "merges_url".to_string(),
            "milestones_url".to_string(),
            "notifications_url".to_string(),
            "pulls_url".to_string(),
            "releases_url".to_string(),
            "stargazers_url".to_string(),
            "statuses_url".to_string(),
            "subscribers_url".to_string(),
            "subscription_url".to_string(),
            "tags_url".to_string(),
            "teams_url".to_string(),
            "trees_url".to_string(),
            "hooks_url".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningOrganizationAlertItems {
    #[doc = "The security alert number."]
    pub number: i64,
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The REST API URL of the alert resource."]
    pub url: url::Url,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: url::Url,
    #[doc = "The REST API URL for fetching the list of instances for an alert."]
    pub instances_url: url::Url,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertState,
    #[doc = "The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fixed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_by: Option<NullableSimpleUser>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "**Required when the state is dismissed.** The reason for dismissing or closing the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
    #[doc = "The dismissal comment associated with the dismissal of the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_comment: Option<String>,
    pub rule: CodeScanningAlertRule,
    pub tool: CodeScanningAnalysisTool,
    pub most_recent_instance: CodeScanningAlertInstance,
    #[doc = "Simple Repository"]
    pub repository: SimpleRepository,
}

impl std::fmt::Display for CodeScanningOrganizationAlertItems {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningOrganizationAlertItems {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.number),
            format!("{:?}", self.created_at),
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.instances_url),
            format!("{:?}", self.state),
            if let Some(fixed_at) = &self.fixed_at {
                format!("{:?}", fixed_at)
            } else {
                String::new()
            },
            format!("{:?}", self.dismissed_by),
            format!("{:?}", self.dismissed_at),
            format!("{:?}", self.dismissed_reason),
            if let Some(dismissed_comment) = &self.dismissed_comment {
                format!("{:?}", dismissed_comment)
            } else {
                String::new()
            },
            format!("{:?}", self.rule),
            format!("{:?}", self.tool),
            format!("{:?}", self.most_recent_instance),
            format!("{:?}", self.repository),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "number".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "instances_url".to_string(),
            "state".to_string(),
            "fixed_at".to_string(),
            "dismissed_by".to_string(),
            "dismissed_at".to_string(),
            "dismissed_reason".to_string(),
            "dismissed_comment".to_string(),
            "rule".to_string(),
            "tool".to_string(),
            "most_recent_instance".to_string(),
            "repository".to_string(),
        ]
    }
}

#[doc = "The License Sync Consumed Licenses Information"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GetConsumedLicenses {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total_seats_consumed: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total_seats_purchased: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<Vec<Users>>,
}

impl std::fmt::Display for GetConsumedLicenses {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GetConsumedLicenses {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(total_seats_consumed) = &self.total_seats_consumed {
                format!("{:?}", total_seats_consumed)
            } else {
                String::new()
            },
            if let Some(total_seats_purchased) = &self.total_seats_purchased {
                format!("{:?}", total_seats_purchased)
            } else {
                String::new()
            },
            if let Some(users) = &self.users {
                format!("{:?}", users)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "total_seats_consumed".to_string(),
            "total_seats_purchased".to_string(),
            "users".to_string(),
        ]
    }
}

#[doc = "A per instance information regarding the status of the License Sync Job."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GetLicenseSyncStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server_instances: Option<Vec<ServerInstances>>,
}

impl std::fmt::Display for GetLicenseSyncStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GetLicenseSyncStatus {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(server_instances) = &self.server_instances {
            format!("{:?}", server_instances)
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["server_instances".to_string()]
    }
}

#[doc = "Sets the state of the secret scanning alert. Can be either `open` or `resolved`. You must provide `resolution` when you set the state to `resolved`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum SecretScanningAlertState {
    #[serde(rename = "open")]
    #[display("open")]
    Open,
    #[serde(rename = "resolved")]
    #[display("resolved")]
    Resolved,
}

#[doc = "**Required when the `state` is `resolved`.** The reason for resolving the alert."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum SecretScanningAlertResolution {
    #[serde(rename = "false_positive")]
    #[display("false_positive")]
    FalsePositive,
    #[serde(rename = "wont_fix")]
    #[display("wont_fix")]
    WontFix,
    #[serde(rename = "revoked")]
    #[display("revoked")]
    Revoked,
    #[serde(rename = "used_in_tests")]
    #[display("used_in_tests")]
    UsedInTests,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationSecretScanningAlert {
    #[doc = "The security alert number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i64>,
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The REST API URL of the alert resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<url::Url>,
    #[doc = "The GitHub URL of the alert resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[doc = "The REST API URL of the code locations for this alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locations_url: Option<url::Url>,
    #[doc = "Sets the state of the secret scanning alert. Can be either `open` or `resolved`. You must provide `resolution` when you set the state to `resolved`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<SecretScanningAlertState>,
    #[doc = "**Required when the `state` is `resolved`.** The reason for resolving the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SecretScanningAlertResolution>,
    #[doc = "The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolved_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolved_by: Option<NullableSimpleUser>,
    #[doc = "The type of secret that secret scanning detected."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_type: Option<String>,
    #[doc = "User-friendly name for the detected secret, matching the `secret_type`.\nFor a list of built-in patterns, see \"[Secret scanning patterns](https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security).\""]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_type_display_name: Option<String>,
    #[doc = "The secret that was detected."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    #[doc = "Simple Repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<SimpleRepository>,
    #[doc = "Whether push protection was bypassed for the detected secret."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub push_protection_bypassed: Option<bool>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub push_protection_bypassed_by: Option<NullableSimpleUser>,
    #[doc = "The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub push_protection_bypassed_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for OrganizationSecretScanningAlert {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationSecretScanningAlert {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(number) = &self.number {
                format!("{:?}", number)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
            if let Some(locations_url) = &self.locations_url {
                format!("{:?}", locations_url)
            } else {
                String::new()
            },
            if let Some(state) = &self.state {
                format!("{:?}", state)
            } else {
                String::new()
            },
            if let Some(resolution) = &self.resolution {
                format!("{:?}", resolution)
            } else {
                String::new()
            },
            if let Some(resolved_at) = &self.resolved_at {
                format!("{:?}", resolved_at)
            } else {
                String::new()
            },
            if let Some(resolved_by) = &self.resolved_by {
                format!("{:?}", resolved_by)
            } else {
                String::new()
            },
            if let Some(secret_type) = &self.secret_type {
                format!("{:?}", secret_type)
            } else {
                String::new()
            },
            if let Some(secret_type_display_name) = &self.secret_type_display_name {
                format!("{:?}", secret_type_display_name)
            } else {
                String::new()
            },
            if let Some(secret) = &self.secret {
                format!("{:?}", secret)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(push_protection_bypassed) = &self.push_protection_bypassed {
                format!("{:?}", push_protection_bypassed)
            } else {
                String::new()
            },
            if let Some(push_protection_bypassed_by) = &self.push_protection_bypassed_by {
                format!("{:?}", push_protection_bypassed_by)
            } else {
                String::new()
            },
            if let Some(push_protection_bypassed_at) = &self.push_protection_bypassed_at {
                format!("{:?}", push_protection_bypassed_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "number".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "locations_url".to_string(),
            "state".to_string(),
            "resolution".to_string(),
            "resolved_at".to_string(),
            "resolved_by".to_string(),
            "secret_type".to_string(),
            "secret_type_display_name".to_string(),
            "secret".to_string(),
            "repository".to_string(),
            "push_protection_bypassed".to_string(),
            "push_protection_bypassed_by".to_string(),
            "push_protection_bypassed_at".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsBillingUsage {
    #[doc = "The sum of the free and paid GitHub Actions minutes used."]
    pub total_minutes_used: i64,
    #[doc = "The total paid GitHub Actions minutes used."]
    pub total_paid_minutes_used: i64,
    #[doc = "The amount of free GitHub Actions minutes available."]
    pub included_minutes: i64,
    pub minutes_used_breakdown: MinutesUsedBreakdown,
}

impl std::fmt::Display for ActionsBillingUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsBillingUsage {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.total_minutes_used),
            format!("{:?}", self.total_paid_minutes_used),
            format!("{:?}", self.included_minutes),
            format!("{:?}", self.minutes_used_breakdown),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "total_minutes_used".to_string(),
            "total_paid_minutes_used".to_string(),
            "included_minutes".to_string(),
            "minutes_used_breakdown".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AdvancedSecurityActiveCommittersUser {
    pub user_login: String,
    pub last_pushed_date: String,
}

impl std::fmt::Display for AdvancedSecurityActiveCommittersUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for AdvancedSecurityActiveCommittersUser {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.user_login.clone(), self.last_pushed_date.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["user_login".to_string(), "last_pushed_date".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AdvancedSecurityActiveCommittersRepository {
    pub name: String,
    pub advanced_security_committers: i64,
    pub advanced_security_committers_breakdown: Vec<AdvancedSecurityActiveCommittersUser>,
}

impl std::fmt::Display for AdvancedSecurityActiveCommittersRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for AdvancedSecurityActiveCommittersRepository {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.advanced_security_committers),
            format!("{:?}", self.advanced_security_committers_breakdown),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "advanced_security_committers".to_string(),
            "advanced_security_committers_breakdown".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AdvancedSecurityActiveCommitters {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total_advanced_security_committers: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total_count: Option<i64>,
    pub repositories: Vec<AdvancedSecurityActiveCommittersRepository>,
}

impl std::fmt::Display for AdvancedSecurityActiveCommitters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for AdvancedSecurityActiveCommitters {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(total_advanced_security_committers) =
                &self.total_advanced_security_committers
            {
                format!("{:?}", total_advanced_security_committers)
            } else {
                String::new()
            },
            if let Some(total_count) = &self.total_count {
                format!("{:?}", total_count)
            } else {
                String::new()
            },
            format!("{:?}", self.repositories),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "total_advanced_security_committers".to_string(),
            "total_count".to_string(),
            "repositories".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PackagesBillingUsage {
    #[doc = "Sum of the free and paid storage space (GB) for GitHuub Packages."]
    pub total_gigabytes_bandwidth_used: i64,
    #[doc = "Total paid storage space (GB) for GitHuub Packages."]
    pub total_paid_gigabytes_bandwidth_used: i64,
    #[doc = "Free storage space (GB) for GitHub Packages."]
    pub included_gigabytes_bandwidth: i64,
}

impl std::fmt::Display for PackagesBillingUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PackagesBillingUsage {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.total_gigabytes_bandwidth_used),
            format!("{:?}", self.total_paid_gigabytes_bandwidth_used),
            format!("{:?}", self.included_gigabytes_bandwidth),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "total_gigabytes_bandwidth_used".to_string(),
            "total_paid_gigabytes_bandwidth_used".to_string(),
            "included_gigabytes_bandwidth".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CombinedBillingUsage {
    #[doc = "Numbers of days left in billing cycle."]
    pub days_left_in_billing_cycle: i64,
    #[doc = "Estimated storage space (GB) used in billing cycle."]
    pub estimated_paid_storage_for_month: i64,
    #[doc = "Estimated sum of free and paid storage space (GB) used in billing cycle."]
    pub estimated_storage_for_month: i64,
}

impl std::fmt::Display for CombinedBillingUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CombinedBillingUsage {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.days_left_in_billing_cycle),
            format!("{:?}", self.estimated_paid_storage_for_month),
            format!("{:?}", self.estimated_storage_for_month),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "days_left_in_billing_cycle".to_string(),
            "estimated_paid_storage_for_month".to_string(),
            "estimated_storage_for_month".to_string(),
        ]
    }
}

#[doc = "Actor"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Actor {
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub display_login: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gravatar_id: Option<String>,
    pub url: url::Url,
    pub avatar_url: url::Url,
}

impl std::fmt::Display for Actor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Actor {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.login.clone(),
            if let Some(display_login) = &self.display_login {
                format!("{:?}", display_login)
            } else {
                String::new()
            },
            format!("{:?}", self.gravatar_id),
            format!("{:?}", self.url),
            format!("{:?}", self.avatar_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "login".to_string(),
            "display_login".to_string(),
            "gravatar_id".to_string(),
            "url".to_string(),
            "avatar_url".to_string(),
        ]
    }
}

#[doc = "A collection of related issues and pull requests."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableMilestone {
    pub url: url::Url,
    pub html_url: url::Url,
    pub labels_url: url::Url,
    pub id: i64,
    pub node_id: String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    #[doc = "The state of the milestone."]
    pub state: State,
    #[doc = "The title of the milestone."]
    pub title: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
    pub open_issues: i64,
    pub closed_issues: i64,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub due_on: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for NullableMilestone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableMilestone {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.labels_url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.number),
            format!("{:?}", self.state),
            self.title.clone(),
            format!("{:?}", self.description),
            format!("{:?}", self.creator),
            format!("{:?}", self.open_issues),
            format!("{:?}", self.closed_issues),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.closed_at),
            format!("{:?}", self.due_on),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "html_url".to_string(),
            "labels_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "number".to_string(),
            "state".to_string(),
            "title".to_string(),
            "description".to_string(),
            "creator".to_string(),
            "open_issues".to_string(),
            "closed_issues".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "closed_at".to_string(),
            "due_on".to_string(),
        ]
    }
}

#[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableIntegration {
    #[doc = "Unique identifier of the GitHub app"]
    pub id: i64,
    #[doc = "The slug name of the GitHub app"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slug: Option<String>,
    pub node_id: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    #[doc = "The name of the GitHub app"]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub external_url: url::Url,
    pub html_url: url::Url,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The set of permissions for the GitHub app"]
    pub permissions: Permissions,
    #[doc = "The list of events for the GitHub app"]
    pub events: Vec<String>,
    #[doc = "The number of installations associated with the GitHub app"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installations_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub webhook_secret: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pem: Option<String>,
}

impl std::fmt::Display for NullableIntegration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableIntegration {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            if let Some(slug) = &self.slug {
                format!("{:?}", slug)
            } else {
                String::new()
            },
            self.node_id.clone(),
            format!("{:?}", self.owner),
            self.name.clone(),
            format!("{:?}", self.description),
            format!("{:?}", self.external_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.permissions),
            format!("{:?}", self.events),
            if let Some(installations_count) = &self.installations_count {
                format!("{:?}", installations_count)
            } else {
                String::new()
            },
            if let Some(client_id) = &self.client_id {
                format!("{:?}", client_id)
            } else {
                String::new()
            },
            if let Some(client_secret) = &self.client_secret {
                format!("{:?}", client_secret)
            } else {
                String::new()
            },
            if let Some(webhook_secret) = &self.webhook_secret {
                format!("{:?}", webhook_secret)
            } else {
                String::new()
            },
            if let Some(pem) = &self.pem {
                format!("{:?}", pem)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "slug".to_string(),
            "node_id".to_string(),
            "owner".to_string(),
            "name".to_string(),
            "description".to_string(),
            "external_url".to_string(),
            "html_url".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "permissions".to_string(),
            "events".to_string(),
            "installations_count".to_string(),
            "client_id".to_string(),
            "client_secret".to_string(),
            "webhook_secret".to_string(),
            "pem".to_string(),
        ]
    }
}

#[doc = "How the author is associated with the repository."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum AuthorAssociation {
    #[serde(rename = "COLLABORATOR")]
    #[display("COLLABORATOR")]
    Collaborator,
    #[serde(rename = "CONTRIBUTOR")]
    #[display("CONTRIBUTOR")]
    Contributor,
    #[serde(rename = "FIRST_TIMER")]
    #[display("FIRST_TIMER")]
    FirstTimer,
    #[serde(rename = "FIRST_TIME_CONTRIBUTOR")]
    #[display("FIRST_TIME_CONTRIBUTOR")]
    FirstTimeContributor,
    #[serde(rename = "MANNEQUIN")]
    #[display("MANNEQUIN")]
    Mannequin,
    #[serde(rename = "MEMBER")]
    #[display("MEMBER")]
    Member,
    #[serde(rename = "NONE")]
    #[display("NONE")]
    None,
    #[serde(rename = "OWNER")]
    #[display("OWNER")]
    Owner,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReactionRollup {
    pub url: url::Url,
    pub total_count: i64,
    #[serde(rename = "+1")]
    pub plus_one: i64,
    #[serde(rename = "-1")]
    pub minus_one: i64,
    pub laugh: i64,
    pub confused: i64,
    pub heart: i64,
    pub hooray: i64,
    pub eyes: i64,
    pub rocket: i64,
}

impl std::fmt::Display for ReactionRollup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReactionRollup {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.total_count),
            format!("{:?}", self.plus_one),
            format!("{:?}", self.minus_one),
            format!("{:?}", self.laugh),
            format!("{:?}", self.confused),
            format!("{:?}", self.heart),
            format!("{:?}", self.hooray),
            format!("{:?}", self.eyes),
            format!("{:?}", self.rocket),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "total_count".to_string(),
            "plus_one".to_string(),
            "minus_one".to_string(),
            "laugh".to_string(),
            "confused".to_string(),
            "heart".to_string(),
            "hooray".to_string(),
            "eyes".to_string(),
            "rocket".to_string(),
        ]
    }
}

#[doc = "Issues are a great way to keep track of tasks, enhancements, and bugs for your projects."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Issue {
    pub id: i64,
    pub node_id: String,
    #[doc = "URL for the issue"]
    pub url: url::Url,
    pub repository_url: url::Url,
    pub labels_url: String,
    pub comments_url: url::Url,
    pub events_url: url::Url,
    pub html_url: url::Url,
    #[doc = "Number uniquely identifying the issue within its repository"]
    pub number: i64,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    pub state: String,
    #[doc = "The reason for the current state"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state_reason: Option<String>,
    #[doc = "Title of the issue"]
    pub title: String,
    #[doc = "Contents of the issue"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[doc = "Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"]
    pub labels: Vec<Labels>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignees: Option<Vec<SimpleUser>>,
    #[doc = "A collection of related issues and pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub milestone: Option<NullableMilestone>,
    pub locked: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active_lock_reason: Option<String>,
    pub comments: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<PullRequest>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub closed_by: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeline_url: Option<url::Url>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

impl std::fmt::Display for Issue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Issue {
    const LENGTH: usize = 34;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.repository_url),
            self.labels_url.clone(),
            format!("{:?}", self.comments_url),
            format!("{:?}", self.events_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.number),
            self.state.clone(),
            if let Some(state_reason) = &self.state_reason {
                format!("{:?}", state_reason)
            } else {
                String::new()
            },
            self.title.clone(),
            if let Some(body) = &self.body {
                format!("{:?}", body)
            } else {
                String::new()
            },
            format!("{:?}", self.user),
            format!("{:?}", self.labels),
            format!("{:?}", self.assignee),
            if let Some(assignees) = &self.assignees {
                format!("{:?}", assignees)
            } else {
                String::new()
            },
            format!("{:?}", self.milestone),
            format!("{:?}", self.locked),
            if let Some(active_lock_reason) = &self.active_lock_reason {
                format!("{:?}", active_lock_reason)
            } else {
                String::new()
            },
            format!("{:?}", self.comments),
            if let Some(pull_request) = &self.pull_request {
                format!("{:?}", pull_request)
            } else {
                String::new()
            },
            format!("{:?}", self.closed_at),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(draft) = &self.draft {
                format!("{:?}", draft)
            } else {
                String::new()
            },
            if let Some(closed_by) = &self.closed_by {
                format!("{:?}", closed_by)
            } else {
                String::new()
            },
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
            if let Some(timeline_url) = &self.timeline_url {
                format!("{:?}", timeline_url)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(performed_via_github_app) = &self.performed_via_github_app {
                format!("{:?}", performed_via_github_app)
            } else {
                String::new()
            },
            format!("{:?}", self.author_association),
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "repository_url".to_string(),
            "labels_url".to_string(),
            "comments_url".to_string(),
            "events_url".to_string(),
            "html_url".to_string(),
            "number".to_string(),
            "state".to_string(),
            "state_reason".to_string(),
            "title".to_string(),
            "body".to_string(),
            "user".to_string(),
            "labels".to_string(),
            "assignee".to_string(),
            "assignees".to_string(),
            "milestone".to_string(),
            "locked".to_string(),
            "active_lock_reason".to_string(),
            "comments".to_string(),
            "pull_request".to_string(),
            "closed_at".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "draft".to_string(),
            "closed_by".to_string(),
            "body_html".to_string(),
            "body_text".to_string(),
            "timeline_url".to_string(),
            "repository".to_string(),
            "performed_via_github_app".to_string(),
            "author_association".to_string(),
            "reactions".to_string(),
        ]
    }
}

#[doc = "Comments provide a way for people to collaborate on an issue."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueComment {
    #[doc = "Unique identifier of the issue comment"]
    pub id: i64,
    pub node_id: String,
    #[doc = "URL for the issue comment"]
    pub url: url::Url,
    #[doc = "Contents of the issue comment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    pub html_url: url::Url,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub issue_url: url::Url,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

impl std::fmt::Display for IssueComment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueComment {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            if let Some(body) = &self.body {
                format!("{:?}", body)
            } else {
                String::new()
            },
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            format!("{:?}", self.html_url),
            format!("{:?}", self.user),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.issue_url),
            format!("{:?}", self.author_association),
            if let Some(performed_via_github_app) = &self.performed_via_github_app {
                format!("{:?}", performed_via_github_app)
            } else {
                String::new()
            },
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "body".to_string(),
            "body_text".to_string(),
            "body_html".to_string(),
            "html_url".to_string(),
            "user".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "issue_url".to_string(),
            "author_association".to_string(),
            "performed_via_github_app".to_string(),
            "reactions".to_string(),
        ]
    }
}

#[doc = "Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Event {
    pub id: String,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "Actor"]
    pub actor: Actor,
    pub repo: Repo,
    #[doc = "Actor"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub org: Option<Actor>,
    pub payload: Payload,
    pub public: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for Event {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Event {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            self.id.clone(),
            format!("{:?}", self.type_),
            format!("{:?}", self.actor),
            format!("{:?}", self.repo),
            if let Some(org) = &self.org {
                format!("{:?}", org)
            } else {
                String::new()
            },
            format!("{:?}", self.payload),
            format!("{:?}", self.public),
            format!("{:?}", self.created_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "type_".to_string(),
            "actor".to_string(),
            "repo".to_string(),
            "org".to_string(),
            "payload".to_string(),
            "public".to_string(),
            "created_at".to_string(),
        ]
    }
}

#[doc = "Hypermedia Link with Type"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct LinkWithType {
    pub href: String,
    #[serde(rename = "type")]
    pub type_: String,
}

impl std::fmt::Display for LinkWithType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for LinkWithType {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.href.clone(), self.type_.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["href".to_string(), "type_".to_string()]
    }
}

#[doc = "Feed"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Feed {
    pub timeline_url: String,
    pub user_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub current_user_public_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub current_user_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub current_user_actor_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub current_user_organization_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub current_user_organization_urls: Option<Vec<url::Url>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_advisories_url: Option<String>,
    #[serde(rename = "_links")]
    pub links: Links,
}

impl std::fmt::Display for Feed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Feed {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            self.timeline_url.clone(),
            self.user_url.clone(),
            if let Some(current_user_public_url) = &self.current_user_public_url {
                format!("{:?}", current_user_public_url)
            } else {
                String::new()
            },
            if let Some(current_user_url) = &self.current_user_url {
                format!("{:?}", current_user_url)
            } else {
                String::new()
            },
            if let Some(current_user_actor_url) = &self.current_user_actor_url {
                format!("{:?}", current_user_actor_url)
            } else {
                String::new()
            },
            if let Some(current_user_organization_url) = &self.current_user_organization_url {
                format!("{:?}", current_user_organization_url)
            } else {
                String::new()
            },
            if let Some(current_user_organization_urls) = &self.current_user_organization_urls {
                format!("{:?}", current_user_organization_urls)
            } else {
                String::new()
            },
            if let Some(security_advisories_url) = &self.security_advisories_url {
                format!("{:?}", security_advisories_url)
            } else {
                String::new()
            },
            format!("{:?}", self.links),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "timeline_url".to_string(),
            "user_url".to_string(),
            "current_user_public_url".to_string(),
            "current_user_url".to_string(),
            "current_user_actor_url".to_string(),
            "current_user_organization_url".to_string(),
            "current_user_organization_urls".to_string(),
            "security_advisories_url".to_string(),
            "links".to_string(),
        ]
    }
}

#[doc = "Base Gist"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BaseGist {
    pub url: url::Url,
    pub forks_url: url::Url,
    pub commits_url: url::Url,
    pub id: String,
    pub node_id: String,
    pub git_pull_url: url::Url,
    pub git_push_url: url::Url,
    pub html_url: url::Url,
    pub files: std::collections::HashMap<String, Files>,
    pub public: bool,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub comments: i64,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    pub comments_url: url::Url,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub truncated: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forks: Option<Vec<serde_json::Value>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub history: Option<Vec<serde_json::Value>>,
}

impl std::fmt::Display for BaseGist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for BaseGist {
    const LENGTH: usize = 20;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.forks_url),
            format!("{:?}", self.commits_url),
            self.id.clone(),
            self.node_id.clone(),
            format!("{:?}", self.git_pull_url),
            format!("{:?}", self.git_push_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.files),
            format!("{:?}", self.public),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.description),
            format!("{:?}", self.comments),
            format!("{:?}", self.user),
            format!("{:?}", self.comments_url),
            if let Some(owner) = &self.owner {
                format!("{:?}", owner)
            } else {
                String::new()
            },
            if let Some(truncated) = &self.truncated {
                format!("{:?}", truncated)
            } else {
                String::new()
            },
            if let Some(forks) = &self.forks {
                format!("{:?}", forks)
            } else {
                String::new()
            },
            if let Some(history) = &self.history {
                format!("{:?}", history)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "forks_url".to_string(),
            "commits_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "git_pull_url".to_string(),
            "git_push_url".to_string(),
            "html_url".to_string(),
            "files".to_string(),
            "public".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "description".to_string(),
            "comments".to_string(),
            "user".to_string(),
            "comments_url".to_string(),
            "owner".to_string(),
            "truncated".to_string(),
            "forks".to_string(),
            "history".to_string(),
        ]
    }
}

#[doc = "Public User"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PublicUser {
    pub login: String,
    pub id: i64,
    pub node_id: String,
    pub avatar_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gravatar_id: Option<String>,
    pub url: url::Url,
    pub html_url: url::Url,
    pub followers_url: url::Url,
    pub following_url: String,
    pub gists_url: String,
    pub starred_url: String,
    pub subscriptions_url: url::Url,
    pub organizations_url: url::Url,
    pub repos_url: url::Url,
    pub events_url: String,
    pub received_events_url: url::Url,
    #[serde(rename = "type")]
    pub type_: String,
    pub site_admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blog: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hireable: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bio: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub twitter_username: Option<String>,
    pub public_repos: i64,
    pub public_gists: i64,
    pub followers: i64,
    pub following: i64,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plan: Option<Plan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suspended_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private_gists: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total_private_repos: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owned_private_repos: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disk_usage: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub collaborators: Option<i64>,
}

impl std::fmt::Display for PublicUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PublicUser {
    const LENGTH: usize = 39;
    fn fields(&self) -> Vec<String> {
        vec![
            self.login.clone(),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.avatar_url),
            format!("{:?}", self.gravatar_id),
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.followers_url),
            self.following_url.clone(),
            self.gists_url.clone(),
            self.starred_url.clone(),
            format!("{:?}", self.subscriptions_url),
            format!("{:?}", self.organizations_url),
            format!("{:?}", self.repos_url),
            self.events_url.clone(),
            format!("{:?}", self.received_events_url),
            self.type_.clone(),
            format!("{:?}", self.site_admin),
            format!("{:?}", self.name),
            format!("{:?}", self.company),
            format!("{:?}", self.blog),
            format!("{:?}", self.location),
            format!("{:?}", self.email),
            format!("{:?}", self.hireable),
            format!("{:?}", self.bio),
            if let Some(twitter_username) = &self.twitter_username {
                format!("{:?}", twitter_username)
            } else {
                String::new()
            },
            format!("{:?}", self.public_repos),
            format!("{:?}", self.public_gists),
            format!("{:?}", self.followers),
            format!("{:?}", self.following),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(plan) = &self.plan {
                format!("{:?}", plan)
            } else {
                String::new()
            },
            if let Some(suspended_at) = &self.suspended_at {
                format!("{:?}", suspended_at)
            } else {
                String::new()
            },
            if let Some(private_gists) = &self.private_gists {
                format!("{:?}", private_gists)
            } else {
                String::new()
            },
            if let Some(total_private_repos) = &self.total_private_repos {
                format!("{:?}", total_private_repos)
            } else {
                String::new()
            },
            if let Some(owned_private_repos) = &self.owned_private_repos {
                format!("{:?}", owned_private_repos)
            } else {
                String::new()
            },
            if let Some(disk_usage) = &self.disk_usage {
                format!("{:?}", disk_usage)
            } else {
                String::new()
            },
            if let Some(collaborators) = &self.collaborators {
                format!("{:?}", collaborators)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "login".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "avatar_url".to_string(),
            "gravatar_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "followers_url".to_string(),
            "following_url".to_string(),
            "gists_url".to_string(),
            "starred_url".to_string(),
            "subscriptions_url".to_string(),
            "organizations_url".to_string(),
            "repos_url".to_string(),
            "events_url".to_string(),
            "received_events_url".to_string(),
            "type_".to_string(),
            "site_admin".to_string(),
            "name".to_string(),
            "company".to_string(),
            "blog".to_string(),
            "location".to_string(),
            "email".to_string(),
            "hireable".to_string(),
            "bio".to_string(),
            "twitter_username".to_string(),
            "public_repos".to_string(),
            "public_gists".to_string(),
            "followers".to_string(),
            "following".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "plan".to_string(),
            "suspended_at".to_string(),
            "private_gists".to_string(),
            "total_private_repos".to_string(),
            "owned_private_repos".to_string(),
            "disk_usage".to_string(),
            "collaborators".to_string(),
        ]
    }
}

#[doc = "Gist History"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GistHistory {
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub committed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub change_status: Option<ChangeStatus>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<url::Url>,
}

impl std::fmt::Display for GistHistory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GistHistory {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(user) = &self.user {
                format!("{:?}", user)
            } else {
                String::new()
            },
            if let Some(version) = &self.version {
                format!("{:?}", version)
            } else {
                String::new()
            },
            if let Some(committed_at) = &self.committed_at {
                format!("{:?}", committed_at)
            } else {
                String::new()
            },
            if let Some(change_status) = &self.change_status {
                format!("{:?}", change_status)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "user".to_string(),
            "version".to_string(),
            "committed_at".to_string(),
            "change_status".to_string(),
            "url".to_string(),
        ]
    }
}

#[doc = "Gist Simple"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GistSimple {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forks: Option<Vec<Forks>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub history: Option<Vec<GistHistory>>,
    #[doc = "Gist"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fork_of: Option<ForkOf>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_pull_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_push_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<std::collections::HashMap<String, Option<Files>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comments: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comments_url: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub truncated: Option<bool>,
}

impl std::fmt::Display for GistSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GistSimple {
    const LENGTH: usize = 21;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(forks) = &self.forks {
                format!("{:?}", forks)
            } else {
                String::new()
            },
            if let Some(history) = &self.history {
                format!("{:?}", history)
            } else {
                String::new()
            },
            if let Some(fork_of) = &self.fork_of {
                format!("{:?}", fork_of)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(forks_url) = &self.forks_url {
                format!("{:?}", forks_url)
            } else {
                String::new()
            },
            if let Some(commits_url) = &self.commits_url {
                format!("{:?}", commits_url)
            } else {
                String::new()
            },
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(node_id) = &self.node_id {
                format!("{:?}", node_id)
            } else {
                String::new()
            },
            if let Some(git_pull_url) = &self.git_pull_url {
                format!("{:?}", git_pull_url)
            } else {
                String::new()
            },
            if let Some(git_push_url) = &self.git_push_url {
                format!("{:?}", git_push_url)
            } else {
                String::new()
            },
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
            if let Some(files) = &self.files {
                format!("{:?}", files)
            } else {
                String::new()
            },
            if let Some(public) = &self.public {
                format!("{:?}", public)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{:?}", description)
            } else {
                String::new()
            },
            if let Some(comments) = &self.comments {
                format!("{:?}", comments)
            } else {
                String::new()
            },
            if let Some(user) = &self.user {
                format!("{:?}", user)
            } else {
                String::new()
            },
            if let Some(comments_url) = &self.comments_url {
                format!("{:?}", comments_url)
            } else {
                String::new()
            },
            if let Some(owner) = &self.owner {
                format!("{:?}", owner)
            } else {
                String::new()
            },
            if let Some(truncated) = &self.truncated {
                format!("{:?}", truncated)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "forks".to_string(),
            "history".to_string(),
            "fork_of".to_string(),
            "url".to_string(),
            "forks_url".to_string(),
            "commits_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "git_pull_url".to_string(),
            "git_push_url".to_string(),
            "html_url".to_string(),
            "files".to_string(),
            "public".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "description".to_string(),
            "comments".to_string(),
            "user".to_string(),
            "comments_url".to_string(),
            "owner".to_string(),
            "truncated".to_string(),
        ]
    }
}

#[doc = "A comment made to a gist."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GistComment {
    pub id: i64,
    pub node_id: String,
    pub url: url::Url,
    #[doc = "The comment text."]
    pub body: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
}

impl std::fmt::Display for GistComment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GistComment {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            self.body.clone(),
            format!("{:?}", self.user),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.author_association),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "body".to_string(),
            "user".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "author_association".to_string(),
        ]
    }
}

#[doc = "Gist Commit"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GistCommit {
    pub url: url::Url,
    pub version: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    pub change_status: ChangeStatus,
    pub committed_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for GistCommit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GistCommit {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            self.version.clone(),
            format!("{:?}", self.user),
            format!("{:?}", self.change_status),
            format!("{:?}", self.committed_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "version".to_string(),
            "user".to_string(),
            "change_status".to_string(),
            "committed_at".to_string(),
        ]
    }
}

#[doc = "Gitignore Template"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GitignoreTemplate {
    pub name: String,
    pub source: String,
}

impl std::fmt::Display for GitignoreTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GitignoreTemplate {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.name.clone(), self.source.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["name".to_string(), "source".to_string()]
    }
}

#[doc = "License Simple"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct LicenseSimple {
    pub key: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spdx_id: Option<String>,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
}

impl std::fmt::Display for LicenseSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for LicenseSimple {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            self.key.clone(),
            self.name.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.spdx_id),
            self.node_id.clone(),
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "key".to_string(),
            "name".to_string(),
            "url".to_string(),
            "spdx_id".to_string(),
            "node_id".to_string(),
            "html_url".to_string(),
        ]
    }
}

#[doc = "License"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct License {
    pub key: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spdx_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<url::Url>,
    pub node_id: String,
    pub html_url: url::Url,
    pub description: String,
    pub implementation: String,
    pub permissions: Vec<String>,
    pub conditions: Vec<String>,
    pub limitations: Vec<String>,
    pub body: String,
    pub featured: bool,
}

impl std::fmt::Display for License {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for License {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            self.key.clone(),
            self.name.clone(),
            format!("{:?}", self.spdx_id),
            format!("{:?}", self.url),
            self.node_id.clone(),
            format!("{:?}", self.html_url),
            self.description.clone(),
            self.implementation.clone(),
            format!("{:?}", self.permissions),
            format!("{:?}", self.conditions),
            format!("{:?}", self.limitations),
            self.body.clone(),
            format!("{:?}", self.featured),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "key".to_string(),
            "name".to_string(),
            "spdx_id".to_string(),
            "url".to_string(),
            "node_id".to_string(),
            "html_url".to_string(),
            "description".to_string(),
            "implementation".to_string(),
            "permissions".to_string(),
            "conditions".to_string(),
            "limitations".to_string(),
            "body".to_string(),
            "featured".to_string(),
        ]
    }
}

#[doc = "Marketplace Listing Plan"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MarketplaceListingPlan {
    pub url: url::Url,
    pub accounts_url: url::Url,
    pub id: i64,
    pub number: i64,
    pub name: String,
    pub description: String,
    pub monthly_price_in_cents: i64,
    pub yearly_price_in_cents: i64,
    pub price_model: String,
    pub has_free_trial: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit_name: Option<String>,
    pub state: String,
    pub bullets: Vec<String>,
}

impl std::fmt::Display for MarketplaceListingPlan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MarketplaceListingPlan {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.accounts_url),
            format!("{:?}", self.id),
            format!("{:?}", self.number),
            self.name.clone(),
            self.description.clone(),
            format!("{:?}", self.monthly_price_in_cents),
            format!("{:?}", self.yearly_price_in_cents),
            self.price_model.clone(),
            format!("{:?}", self.has_free_trial),
            format!("{:?}", self.unit_name),
            self.state.clone(),
            format!("{:?}", self.bullets),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "accounts_url".to_string(),
            "id".to_string(),
            "number".to_string(),
            "name".to_string(),
            "description".to_string(),
            "monthly_price_in_cents".to_string(),
            "yearly_price_in_cents".to_string(),
            "price_model".to_string(),
            "has_free_trial".to_string(),
            "unit_name".to_string(),
            "state".to_string(),
            "bullets".to_string(),
        ]
    }
}

#[doc = "Marketplace Purchase"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MarketplacePurchase {
    pub url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_billing_email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub marketplace_pending_change: Option<MarketplacePendingChange>,
    pub marketplace_purchase: MarketplacePurchase,
}

impl std::fmt::Display for MarketplacePurchase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MarketplacePurchase {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            self.url.clone(),
            self.type_.clone(),
            format!("{:?}", self.id),
            self.login.clone(),
            if let Some(organization_billing_email) = &self.organization_billing_email {
                format!("{:?}", organization_billing_email)
            } else {
                String::new()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email)
            } else {
                String::new()
            },
            if let Some(marketplace_pending_change) = &self.marketplace_pending_change {
                format!("{:?}", marketplace_pending_change)
            } else {
                String::new()
            },
            format!("{:?}", self.marketplace_purchase),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "type_".to_string(),
            "id".to_string(),
            "login".to_string(),
            "organization_billing_email".to_string(),
            "email".to_string(),
            "marketplace_pending_change".to_string(),
            "marketplace_purchase".to_string(),
        ]
    }
}

#[doc = "Api Overview"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiOverview {
    pub verifiable_password_authentication: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ssh_key_fingerprints: Option<SshKeyFingerprints>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ssh_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hooks: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pages: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub importer: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dependabot: Option<Vec<String>>,
}

impl std::fmt::Display for ApiOverview {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiOverview {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.verifiable_password_authentication),
            if let Some(ssh_key_fingerprints) = &self.ssh_key_fingerprints {
                format!("{:?}", ssh_key_fingerprints)
            } else {
                String::new()
            },
            if let Some(ssh_keys) = &self.ssh_keys {
                format!("{:?}", ssh_keys)
            } else {
                String::new()
            },
            if let Some(hooks) = &self.hooks {
                format!("{:?}", hooks)
            } else {
                String::new()
            },
            if let Some(web) = &self.web {
                format!("{:?}", web)
            } else {
                String::new()
            },
            if let Some(api) = &self.api {
                format!("{:?}", api)
            } else {
                String::new()
            },
            if let Some(git) = &self.git {
                format!("{:?}", git)
            } else {
                String::new()
            },
            if let Some(packages) = &self.packages {
                format!("{:?}", packages)
            } else {
                String::new()
            },
            if let Some(pages) = &self.pages {
                format!("{:?}", pages)
            } else {
                String::new()
            },
            if let Some(importer) = &self.importer {
                format!("{:?}", importer)
            } else {
                String::new()
            },
            if let Some(actions) = &self.actions {
                format!("{:?}", actions)
            } else {
                String::new()
            },
            if let Some(dependabot) = &self.dependabot {
                format!("{:?}", dependabot)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "verifiable_password_authentication".to_string(),
            "ssh_key_fingerprints".to_string(),
            "ssh_keys".to_string(),
            "hooks".to_string(),
            "web".to_string(),
            "api".to_string(),
            "git".to_string(),
            "packages".to_string(),
            "pages".to_string(),
            "importer".to_string(),
            "actions".to_string(),
            "dependabot".to_string(),
        ]
    }
}

#[doc = "A git repository"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableRepository {
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub node_id: String,
    #[doc = "The name of the repository."]
    pub name: String,
    pub full_name: String,
    #[doc = "License Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<NullableSimpleUser>,
    pub forks: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    #[doc = "Simple User"]
    pub owner: SimpleUser,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    pub html_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub fork: bool,
    pub url: url::Url,
    pub archive_url: String,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: url::Url,
    pub deployments_url: url::Url,
    pub downloads_url: url::Url,
    pub events_url: url::Url,
    pub forks_url: url::Url,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub languages_url: url::Url,
    pub merges_url: url::Url,
    pub milestones_url: String,
    pub notifications_url: String,
    pub pulls_url: String,
    pub releases_url: String,
    pub ssh_url: String,
    pub stargazers_url: url::Url,
    pub statuses_url: String,
    pub subscribers_url: url::Url,
    pub subscription_url: url::Url,
    pub tags_url: url::Url,
    pub teams_url: url::Url,
    pub trees_url: String,
    pub clone_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror_url: Option<url::Url>,
    pub hooks_url: url::Url,
    pub svn_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    pub forks_count: i64,
    pub stargazers_count: i64,
    pub watchers_count: i64,
    pub size: i64,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    pub open_issues_count: i64,
    #[doc = "Whether this repository acts as a template that can be used to generate new repositories."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub has_pages: bool,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    #[doc = "Returns whether or not this repository disabled."]
    pub disabled: bool,
    #[doc = "The repository visibility: public, private, or internal."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub visibility: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template_repository: Option<TemplateRepository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[doc = "Whether to allow Auto-merge to be used on pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[doc = "Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[doc = "Whether a squash merge commit can use the pull request title as default."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    #[doc = "Whether to allow forking this repo"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network_count: Option<i64>,
    pub open_issues: i64,
    pub watchers: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub starred_at: Option<String>,
}

impl std::fmt::Display for NullableRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableRepository {
    const LENGTH: usize = 92;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.full_name.clone(),
            format!("{:?}", self.license),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.forks),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            format!("{:?}", self.owner),
            format!("{:?}", self.private),
            format!("{:?}", self.html_url),
            format!("{:?}", self.description),
            format!("{:?}", self.fork),
            format!("{:?}", self.url),
            self.archive_url.clone(),
            self.assignees_url.clone(),
            self.blobs_url.clone(),
            self.branches_url.clone(),
            self.collaborators_url.clone(),
            self.comments_url.clone(),
            self.commits_url.clone(),
            self.compare_url.clone(),
            self.contents_url.clone(),
            format!("{:?}", self.contributors_url),
            format!("{:?}", self.deployments_url),
            format!("{:?}", self.downloads_url),
            format!("{:?}", self.events_url),
            format!("{:?}", self.forks_url),
            self.git_commits_url.clone(),
            self.git_refs_url.clone(),
            self.git_tags_url.clone(),
            self.git_url.clone(),
            self.issue_comment_url.clone(),
            self.issue_events_url.clone(),
            self.issues_url.clone(),
            self.keys_url.clone(),
            self.labels_url.clone(),
            format!("{:?}", self.languages_url),
            format!("{:?}", self.merges_url),
            self.milestones_url.clone(),
            self.notifications_url.clone(),
            self.pulls_url.clone(),
            self.releases_url.clone(),
            self.ssh_url.clone(),
            format!("{:?}", self.stargazers_url),
            self.statuses_url.clone(),
            format!("{:?}", self.subscribers_url),
            format!("{:?}", self.subscription_url),
            format!("{:?}", self.tags_url),
            format!("{:?}", self.teams_url),
            self.trees_url.clone(),
            self.clone_url.clone(),
            format!("{:?}", self.mirror_url),
            format!("{:?}", self.hooks_url),
            format!("{:?}", self.svn_url),
            format!("{:?}", self.homepage),
            format!("{:?}", self.language),
            format!("{:?}", self.forks_count),
            format!("{:?}", self.stargazers_count),
            format!("{:?}", self.watchers_count),
            format!("{:?}", self.size),
            self.default_branch.clone(),
            format!("{:?}", self.open_issues_count),
            if let Some(is_template) = &self.is_template {
                format!("{:?}", is_template)
            } else {
                String::new()
            },
            if let Some(topics) = &self.topics {
                format!("{:?}", topics)
            } else {
                String::new()
            },
            format!("{:?}", self.has_issues),
            format!("{:?}", self.has_projects),
            format!("{:?}", self.has_wiki),
            format!("{:?}", self.has_pages),
            format!("{:?}", self.has_downloads),
            format!("{:?}", self.archived),
            format!("{:?}", self.disabled),
            if let Some(visibility) = &self.visibility {
                format!("{:?}", visibility)
            } else {
                String::new()
            },
            format!("{:?}", self.pushed_at),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(allow_rebase_merge) = &self.allow_rebase_merge {
                format!("{:?}", allow_rebase_merge)
            } else {
                String::new()
            },
            if let Some(template_repository) = &self.template_repository {
                format!("{:?}", template_repository)
            } else {
                String::new()
            },
            if let Some(temp_clone_token) = &self.temp_clone_token {
                format!("{:?}", temp_clone_token)
            } else {
                String::new()
            },
            if let Some(allow_squash_merge) = &self.allow_squash_merge {
                format!("{:?}", allow_squash_merge)
            } else {
                String::new()
            },
            if let Some(allow_auto_merge) = &self.allow_auto_merge {
                format!("{:?}", allow_auto_merge)
            } else {
                String::new()
            },
            if let Some(delete_branch_on_merge) = &self.delete_branch_on_merge {
                format!("{:?}", delete_branch_on_merge)
            } else {
                String::new()
            },
            if let Some(allow_update_branch) = &self.allow_update_branch {
                format!("{:?}", allow_update_branch)
            } else {
                String::new()
            },
            if let Some(use_squash_pr_title_as_default) = &self.use_squash_pr_title_as_default {
                format!("{:?}", use_squash_pr_title_as_default)
            } else {
                String::new()
            },
            if let Some(allow_merge_commit) = &self.allow_merge_commit {
                format!("{:?}", allow_merge_commit)
            } else {
                String::new()
            },
            if let Some(allow_forking) = &self.allow_forking {
                format!("{:?}", allow_forking)
            } else {
                String::new()
            },
            if let Some(subscribers_count) = &self.subscribers_count {
                format!("{:?}", subscribers_count)
            } else {
                String::new()
            },
            if let Some(network_count) = &self.network_count {
                format!("{:?}", network_count)
            } else {
                String::new()
            },
            format!("{:?}", self.open_issues),
            format!("{:?}", self.watchers),
            if let Some(master_branch) = &self.master_branch {
                format!("{:?}", master_branch)
            } else {
                String::new()
            },
            if let Some(starred_at) = &self.starred_at {
                format!("{:?}", starred_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "full_name".to_string(),
            "license".to_string(),
            "organization".to_string(),
            "forks".to_string(),
            "permissions".to_string(),
            "owner".to_string(),
            "private".to_string(),
            "html_url".to_string(),
            "description".to_string(),
            "fork".to_string(),
            "url".to_string(),
            "archive_url".to_string(),
            "assignees_url".to_string(),
            "blobs_url".to_string(),
            "branches_url".to_string(),
            "collaborators_url".to_string(),
            "comments_url".to_string(),
            "commits_url".to_string(),
            "compare_url".to_string(),
            "contents_url".to_string(),
            "contributors_url".to_string(),
            "deployments_url".to_string(),
            "downloads_url".to_string(),
            "events_url".to_string(),
            "forks_url".to_string(),
            "git_commits_url".to_string(),
            "git_refs_url".to_string(),
            "git_tags_url".to_string(),
            "git_url".to_string(),
            "issue_comment_url".to_string(),
            "issue_events_url".to_string(),
            "issues_url".to_string(),
            "keys_url".to_string(),
            "labels_url".to_string(),
            "languages_url".to_string(),
            "merges_url".to_string(),
            "milestones_url".to_string(),
            "notifications_url".to_string(),
            "pulls_url".to_string(),
            "releases_url".to_string(),
            "ssh_url".to_string(),
            "stargazers_url".to_string(),
            "statuses_url".to_string(),
            "subscribers_url".to_string(),
            "subscription_url".to_string(),
            "tags_url".to_string(),
            "teams_url".to_string(),
            "trees_url".to_string(),
            "clone_url".to_string(),
            "mirror_url".to_string(),
            "hooks_url".to_string(),
            "svn_url".to_string(),
            "homepage".to_string(),
            "language".to_string(),
            "forks_count".to_string(),
            "stargazers_count".to_string(),
            "watchers_count".to_string(),
            "size".to_string(),
            "default_branch".to_string(),
            "open_issues_count".to_string(),
            "is_template".to_string(),
            "topics".to_string(),
            "has_issues".to_string(),
            "has_projects".to_string(),
            "has_wiki".to_string(),
            "has_pages".to_string(),
            "has_downloads".to_string(),
            "archived".to_string(),
            "disabled".to_string(),
            "visibility".to_string(),
            "pushed_at".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "allow_rebase_merge".to_string(),
            "template_repository".to_string(),
            "temp_clone_token".to_string(),
            "allow_squash_merge".to_string(),
            "allow_auto_merge".to_string(),
            "delete_branch_on_merge".to_string(),
            "allow_update_branch".to_string(),
            "use_squash_pr_title_as_default".to_string(),
            "allow_merge_commit".to_string(),
            "allow_forking".to_string(),
            "subscribers_count".to_string(),
            "network_count".to_string(),
            "open_issues".to_string(),
            "watchers".to_string(),
            "master_branch".to_string(),
            "starred_at".to_string(),
        ]
    }
}

#[doc = "Minimal Repository"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MinimalRepository {
    pub id: i64,
    pub node_id: String,
    pub name: String,
    pub full_name: String,
    #[doc = "Simple User"]
    pub owner: SimpleUser,
    pub private: bool,
    pub html_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub fork: bool,
    pub url: url::Url,
    pub archive_url: String,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: url::Url,
    pub deployments_url: url::Url,
    pub downloads_url: url::Url,
    pub events_url: url::Url,
    pub forks_url: url::Url,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_url: Option<String>,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub languages_url: url::Url,
    pub merges_url: url::Url,
    pub milestones_url: String,
    pub notifications_url: String,
    pub pulls_url: String,
    pub releases_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ssh_url: Option<String>,
    pub stargazers_url: url::Url,
    pub statuses_url: String,
    pub subscribers_url: url::Url,
    pub subscription_url: url::Url,
    pub tags_url: url::Url,
    pub teams_url: url::Url,
    pub trees_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror_url: Option<String>,
    pub hooks_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub watchers_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_projects: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_pages: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_downloads: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archived: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub visibility: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role_name: Option<String>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template_repository: Option<NullableRepository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network_count: Option<i64>,
    #[doc = "Code Of Conduct"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code_of_conduct: Option<CodeOfConduct>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forks: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
}

impl std::fmt::Display for MinimalRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MinimalRepository {
    const LENGTH: usize = 85;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.full_name.clone(),
            format!("{:?}", self.owner),
            format!("{:?}", self.private),
            format!("{:?}", self.html_url),
            format!("{:?}", self.description),
            format!("{:?}", self.fork),
            format!("{:?}", self.url),
            self.archive_url.clone(),
            self.assignees_url.clone(),
            self.blobs_url.clone(),
            self.branches_url.clone(),
            self.collaborators_url.clone(),
            self.comments_url.clone(),
            self.commits_url.clone(),
            self.compare_url.clone(),
            self.contents_url.clone(),
            format!("{:?}", self.contributors_url),
            format!("{:?}", self.deployments_url),
            format!("{:?}", self.downloads_url),
            format!("{:?}", self.events_url),
            format!("{:?}", self.forks_url),
            self.git_commits_url.clone(),
            self.git_refs_url.clone(),
            self.git_tags_url.clone(),
            if let Some(git_url) = &self.git_url {
                format!("{:?}", git_url)
            } else {
                String::new()
            },
            self.issue_comment_url.clone(),
            self.issue_events_url.clone(),
            self.issues_url.clone(),
            self.keys_url.clone(),
            self.labels_url.clone(),
            format!("{:?}", self.languages_url),
            format!("{:?}", self.merges_url),
            self.milestones_url.clone(),
            self.notifications_url.clone(),
            self.pulls_url.clone(),
            self.releases_url.clone(),
            if let Some(ssh_url) = &self.ssh_url {
                format!("{:?}", ssh_url)
            } else {
                String::new()
            },
            format!("{:?}", self.stargazers_url),
            self.statuses_url.clone(),
            format!("{:?}", self.subscribers_url),
            format!("{:?}", self.subscription_url),
            format!("{:?}", self.tags_url),
            format!("{:?}", self.teams_url),
            self.trees_url.clone(),
            if let Some(clone_url) = &self.clone_url {
                format!("{:?}", clone_url)
            } else {
                String::new()
            },
            if let Some(mirror_url) = &self.mirror_url {
                format!("{:?}", mirror_url)
            } else {
                String::new()
            },
            format!("{:?}", self.hooks_url),
            if let Some(svn_url) = &self.svn_url {
                format!("{:?}", svn_url)
            } else {
                String::new()
            },
            if let Some(homepage) = &self.homepage {
                format!("{:?}", homepage)
            } else {
                String::new()
            },
            if let Some(language) = &self.language {
                format!("{:?}", language)
            } else {
                String::new()
            },
            if let Some(forks_count) = &self.forks_count {
                format!("{:?}", forks_count)
            } else {
                String::new()
            },
            if let Some(stargazers_count) = &self.stargazers_count {
                format!("{:?}", stargazers_count)
            } else {
                String::new()
            },
            if let Some(watchers_count) = &self.watchers_count {
                format!("{:?}", watchers_count)
            } else {
                String::new()
            },
            if let Some(size) = &self.size {
                format!("{:?}", size)
            } else {
                String::new()
            },
            if let Some(default_branch) = &self.default_branch {
                format!("{:?}", default_branch)
            } else {
                String::new()
            },
            if let Some(open_issues_count) = &self.open_issues_count {
                format!("{:?}", open_issues_count)
            } else {
                String::new()
            },
            if let Some(is_template) = &self.is_template {
                format!("{:?}", is_template)
            } else {
                String::new()
            },
            if let Some(topics) = &self.topics {
                format!("{:?}", topics)
            } else {
                String::new()
            },
            if let Some(has_issues) = &self.has_issues {
                format!("{:?}", has_issues)
            } else {
                String::new()
            },
            if let Some(has_projects) = &self.has_projects {
                format!("{:?}", has_projects)
            } else {
                String::new()
            },
            if let Some(has_wiki) = &self.has_wiki {
                format!("{:?}", has_wiki)
            } else {
                String::new()
            },
            if let Some(has_pages) = &self.has_pages {
                format!("{:?}", has_pages)
            } else {
                String::new()
            },
            if let Some(has_downloads) = &self.has_downloads {
                format!("{:?}", has_downloads)
            } else {
                String::new()
            },
            if let Some(archived) = &self.archived {
                format!("{:?}", archived)
            } else {
                String::new()
            },
            if let Some(disabled) = &self.disabled {
                format!("{:?}", disabled)
            } else {
                String::new()
            },
            if let Some(visibility) = &self.visibility {
                format!("{:?}", visibility)
            } else {
                String::new()
            },
            if let Some(pushed_at) = &self.pushed_at {
                format!("{:?}", pushed_at)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            if let Some(role_name) = &self.role_name {
                format!("{:?}", role_name)
            } else {
                String::new()
            },
            if let Some(template_repository) = &self.template_repository {
                format!("{:?}", template_repository)
            } else {
                String::new()
            },
            if let Some(temp_clone_token) = &self.temp_clone_token {
                format!("{:?}", temp_clone_token)
            } else {
                String::new()
            },
            if let Some(delete_branch_on_merge) = &self.delete_branch_on_merge {
                format!("{:?}", delete_branch_on_merge)
            } else {
                String::new()
            },
            if let Some(subscribers_count) = &self.subscribers_count {
                format!("{:?}", subscribers_count)
            } else {
                String::new()
            },
            if let Some(network_count) = &self.network_count {
                format!("{:?}", network_count)
            } else {
                String::new()
            },
            if let Some(code_of_conduct) = &self.code_of_conduct {
                format!("{:?}", code_of_conduct)
            } else {
                String::new()
            },
            if let Some(license) = &self.license {
                format!("{:?}", license)
            } else {
                String::new()
            },
            if let Some(forks) = &self.forks {
                format!("{:?}", forks)
            } else {
                String::new()
            },
            if let Some(open_issues) = &self.open_issues {
                format!("{:?}", open_issues)
            } else {
                String::new()
            },
            if let Some(watchers) = &self.watchers {
                format!("{:?}", watchers)
            } else {
                String::new()
            },
            if let Some(allow_forking) = &self.allow_forking {
                format!("{:?}", allow_forking)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "full_name".to_string(),
            "owner".to_string(),
            "private".to_string(),
            "html_url".to_string(),
            "description".to_string(),
            "fork".to_string(),
            "url".to_string(),
            "archive_url".to_string(),
            "assignees_url".to_string(),
            "blobs_url".to_string(),
            "branches_url".to_string(),
            "collaborators_url".to_string(),
            "comments_url".to_string(),
            "commits_url".to_string(),
            "compare_url".to_string(),
            "contents_url".to_string(),
            "contributors_url".to_string(),
            "deployments_url".to_string(),
            "downloads_url".to_string(),
            "events_url".to_string(),
            "forks_url".to_string(),
            "git_commits_url".to_string(),
            "git_refs_url".to_string(),
            "git_tags_url".to_string(),
            "git_url".to_string(),
            "issue_comment_url".to_string(),
            "issue_events_url".to_string(),
            "issues_url".to_string(),
            "keys_url".to_string(),
            "labels_url".to_string(),
            "languages_url".to_string(),
            "merges_url".to_string(),
            "milestones_url".to_string(),
            "notifications_url".to_string(),
            "pulls_url".to_string(),
            "releases_url".to_string(),
            "ssh_url".to_string(),
            "stargazers_url".to_string(),
            "statuses_url".to_string(),
            "subscribers_url".to_string(),
            "subscription_url".to_string(),
            "tags_url".to_string(),
            "teams_url".to_string(),
            "trees_url".to_string(),
            "clone_url".to_string(),
            "mirror_url".to_string(),
            "hooks_url".to_string(),
            "svn_url".to_string(),
            "homepage".to_string(),
            "language".to_string(),
            "forks_count".to_string(),
            "stargazers_count".to_string(),
            "watchers_count".to_string(),
            "size".to_string(),
            "default_branch".to_string(),
            "open_issues_count".to_string(),
            "is_template".to_string(),
            "topics".to_string(),
            "has_issues".to_string(),
            "has_projects".to_string(),
            "has_wiki".to_string(),
            "has_pages".to_string(),
            "has_downloads".to_string(),
            "archived".to_string(),
            "disabled".to_string(),
            "visibility".to_string(),
            "pushed_at".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "permissions".to_string(),
            "role_name".to_string(),
            "template_repository".to_string(),
            "temp_clone_token".to_string(),
            "delete_branch_on_merge".to_string(),
            "subscribers_count".to_string(),
            "network_count".to_string(),
            "code_of_conduct".to_string(),
            "license".to_string(),
            "forks".to_string(),
            "open_issues".to_string(),
            "watchers".to_string(),
            "allow_forking".to_string(),
        ]
    }
}

#[doc = "Thread"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Thread {
    pub id: String,
    #[doc = "Minimal Repository"]
    pub repository: MinimalRepository,
    pub subject: Subject,
    pub reason: String,
    pub unread: bool,
    pub updated_at: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_read_at: Option<String>,
    pub url: String,
    pub subscription_url: String,
}

impl std::fmt::Display for Thread {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Thread {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            self.id.clone(),
            format!("{:?}", self.repository),
            format!("{:?}", self.subject),
            self.reason.clone(),
            format!("{:?}", self.unread),
            self.updated_at.clone(),
            format!("{:?}", self.last_read_at),
            self.url.clone(),
            self.subscription_url.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "repository".to_string(),
            "subject".to_string(),
            "reason".to_string(),
            "unread".to_string(),
            "updated_at".to_string(),
            "last_read_at".to_string(),
            "url".to_string(),
            "subscription_url".to_string(),
        ]
    }
}

#[doc = "Thread Subscription"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ThreadSubscription {
    pub subscribed: bool,
    pub ignored: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thread_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_url: Option<url::Url>,
}

impl std::fmt::Display for ThreadSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ThreadSubscription {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.subscribed),
            format!("{:?}", self.ignored),
            format!("{:?}", self.reason),
            format!("{:?}", self.created_at),
            format!("{:?}", self.url),
            if let Some(thread_url) = &self.thread_url {
                format!("{:?}", thread_url)
            } else {
                String::new()
            },
            if let Some(repository_url) = &self.repository_url {
                format!("{:?}", repository_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "subscribed".to_string(),
            "ignored".to_string(),
            "reason".to_string(),
            "created_at".to_string(),
            "url".to_string(),
            "thread_url".to_string(),
            "repository_url".to_string(),
        ]
    }
}

#[doc = "Custom repository roles created by organization administrators"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationCustomRepositoryRole {
    pub id: i64,
    pub name: String,
}

impl std::fmt::Display for OrganizationCustomRepositoryRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationCustomRepositoryRole {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.id), self.name.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["id".to_string(), "name".to_string()]
    }
}

#[doc = "Secrets for a GitHub Codespace."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodespacesOrgSecret {
    #[doc = "The name of the secret"]
    pub name: String,
    #[doc = "Secret created at"]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Secret last updated at"]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The type of repositories in the organization that the secret is visible to"]
    pub visibility: Visibility,
    #[doc = "API URL at which the list of repositories this secret is vicible can be retrieved"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_repositories_url: Option<url::Url>,
}

impl std::fmt::Display for CodespacesOrgSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodespacesOrgSecret {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.visibility),
            if let Some(selected_repositories_url) = &self.selected_repositories_url {
                format!("{:?}", selected_repositories_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "visibility".to_string(),
            "selected_repositories_url".to_string(),
        ]
    }
}

#[doc = "Organization Full"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationFull {
    pub login: String,
    pub id: i64,
    pub node_id: String,
    pub url: url::Url,
    pub repos_url: url::Url,
    pub events_url: url::Url,
    pub hooks_url: String,
    pub issues_url: String,
    pub members_url: String,
    pub public_members_url: String,
    pub avatar_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blog: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub twitter_username: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_verified: Option<bool>,
    pub has_organization_projects: bool,
    pub has_repository_projects: bool,
    pub public_repos: i64,
    pub public_gists: i64,
    pub followers: i64,
    pub following: i64,
    pub html_url: url::Url,
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total_private_repos: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owned_private_repos: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private_gists: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disk_usage: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub collaborators: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub billing_email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plan: Option<Plan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_repository_permission: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members_can_create_repositories: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub two_factor_requirement_enabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members_allowed_repository_creation_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members_can_create_public_repositories: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members_can_create_private_repositories: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members_can_create_internal_repositories: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members_can_create_pages: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members_can_create_public_pages: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members_can_create_private_pages: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members_can_fork_private_repositories: Option<bool>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for OrganizationFull {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationFull {
    const LENGTH: usize = 47;
    fn fields(&self) -> Vec<String> {
        vec![
            self.login.clone(),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.repos_url),
            format!("{:?}", self.events_url),
            self.hooks_url.clone(),
            self.issues_url.clone(),
            self.members_url.clone(),
            self.public_members_url.clone(),
            self.avatar_url.clone(),
            format!("{:?}", self.description),
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(company) = &self.company {
                format!("{:?}", company)
            } else {
                String::new()
            },
            if let Some(blog) = &self.blog {
                format!("{:?}", blog)
            } else {
                String::new()
            },
            if let Some(location) = &self.location {
                format!("{:?}", location)
            } else {
                String::new()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email)
            } else {
                String::new()
            },
            if let Some(twitter_username) = &self.twitter_username {
                format!("{:?}", twitter_username)
            } else {
                String::new()
            },
            if let Some(is_verified) = &self.is_verified {
                format!("{:?}", is_verified)
            } else {
                String::new()
            },
            format!("{:?}", self.has_organization_projects),
            format!("{:?}", self.has_repository_projects),
            format!("{:?}", self.public_repos),
            format!("{:?}", self.public_gists),
            format!("{:?}", self.followers),
            format!("{:?}", self.following),
            format!("{:?}", self.html_url),
            format!("{:?}", self.created_at),
            self.type_.clone(),
            if let Some(total_private_repos) = &self.total_private_repos {
                format!("{:?}", total_private_repos)
            } else {
                String::new()
            },
            if let Some(owned_private_repos) = &self.owned_private_repos {
                format!("{:?}", owned_private_repos)
            } else {
                String::new()
            },
            if let Some(private_gists) = &self.private_gists {
                format!("{:?}", private_gists)
            } else {
                String::new()
            },
            if let Some(disk_usage) = &self.disk_usage {
                format!("{:?}", disk_usage)
            } else {
                String::new()
            },
            if let Some(collaborators) = &self.collaborators {
                format!("{:?}", collaborators)
            } else {
                String::new()
            },
            if let Some(billing_email) = &self.billing_email {
                format!("{:?}", billing_email)
            } else {
                String::new()
            },
            if let Some(plan) = &self.plan {
                format!("{:?}", plan)
            } else {
                String::new()
            },
            if let Some(default_repository_permission) = &self.default_repository_permission {
                format!("{:?}", default_repository_permission)
            } else {
                String::new()
            },
            if let Some(members_can_create_repositories) = &self.members_can_create_repositories {
                format!("{:?}", members_can_create_repositories)
            } else {
                String::new()
            },
            if let Some(two_factor_requirement_enabled) = &self.two_factor_requirement_enabled {
                format!("{:?}", two_factor_requirement_enabled)
            } else {
                String::new()
            },
            if let Some(members_allowed_repository_creation_type) =
                &self.members_allowed_repository_creation_type
            {
                format!("{:?}", members_allowed_repository_creation_type)
            } else {
                String::new()
            },
            if let Some(members_can_create_public_repositories) =
                &self.members_can_create_public_repositories
            {
                format!("{:?}", members_can_create_public_repositories)
            } else {
                String::new()
            },
            if let Some(members_can_create_private_repositories) =
                &self.members_can_create_private_repositories
            {
                format!("{:?}", members_can_create_private_repositories)
            } else {
                String::new()
            },
            if let Some(members_can_create_internal_repositories) =
                &self.members_can_create_internal_repositories
            {
                format!("{:?}", members_can_create_internal_repositories)
            } else {
                String::new()
            },
            if let Some(members_can_create_pages) = &self.members_can_create_pages {
                format!("{:?}", members_can_create_pages)
            } else {
                String::new()
            },
            if let Some(members_can_create_public_pages) = &self.members_can_create_public_pages {
                format!("{:?}", members_can_create_public_pages)
            } else {
                String::new()
            },
            if let Some(members_can_create_private_pages) = &self.members_can_create_private_pages {
                format!("{:?}", members_can_create_private_pages)
            } else {
                String::new()
            },
            if let Some(members_can_fork_private_repositories) =
                &self.members_can_fork_private_repositories
            {
                format!("{:?}", members_can_fork_private_repositories)
            } else {
                String::new()
            },
            format!("{:?}", self.updated_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "login".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "repos_url".to_string(),
            "events_url".to_string(),
            "hooks_url".to_string(),
            "issues_url".to_string(),
            "members_url".to_string(),
            "public_members_url".to_string(),
            "avatar_url".to_string(),
            "description".to_string(),
            "name".to_string(),
            "company".to_string(),
            "blog".to_string(),
            "location".to_string(),
            "email".to_string(),
            "twitter_username".to_string(),
            "is_verified".to_string(),
            "has_organization_projects".to_string(),
            "has_repository_projects".to_string(),
            "public_repos".to_string(),
            "public_gists".to_string(),
            "followers".to_string(),
            "following".to_string(),
            "html_url".to_string(),
            "created_at".to_string(),
            "type_".to_string(),
            "total_private_repos".to_string(),
            "owned_private_repos".to_string(),
            "private_gists".to_string(),
            "disk_usage".to_string(),
            "collaborators".to_string(),
            "billing_email".to_string(),
            "plan".to_string(),
            "default_repository_permission".to_string(),
            "members_can_create_repositories".to_string(),
            "two_factor_requirement_enabled".to_string(),
            "members_allowed_repository_creation_type".to_string(),
            "members_can_create_public_repositories".to_string(),
            "members_can_create_private_repositories".to_string(),
            "members_can_create_internal_repositories".to_string(),
            "members_can_create_pages".to_string(),
            "members_can_create_public_pages".to_string(),
            "members_can_create_private_pages".to_string(),
            "members_can_fork_private_repositories".to_string(),
            "updated_at".to_string(),
        ]
    }
}

#[doc = "GitHub Actions Cache Usage by repository."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsCacheUsageByRepository {
    #[doc = "The repository owner and name for the cache usage being shown."]
    pub full_name: String,
    #[doc = "The sum of the size in bytes of all the active cache items in the repository."]
    pub active_caches_size_in_bytes: i64,
    #[doc = "The number of active caches in the repository."]
    pub active_caches_count: i64,
}

impl std::fmt::Display for ActionsCacheUsageByRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsCacheUsageByRepository {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.full_name.clone(),
            format!("{:?}", self.active_caches_size_in_bytes),
            format!("{:?}", self.active_caches_count),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "full_name".to_string(),
            "active_caches_size_in_bytes".to_string(),
            "active_caches_count".to_string(),
        ]
    }
}

#[doc = "Actions OIDC Subject customization"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OidcCustomSub {
    pub include_claim_keys: Vec<String>,
}

impl std::fmt::Display for OidcCustomSub {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OidcCustomSub {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.include_claim_keys)]
    }

    fn headers() -> Vec<String> {
        vec!["include_claim_keys".to_string()]
    }
}

#[doc = "An object without any properties."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EmptyObject {}

impl std::fmt::Display for EmptyObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for EmptyObject {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<String> {
        vec![]
    }

    fn headers() -> Vec<String> {
        vec![]
    }
}

#[doc = "The policy that controls the repositories in the organization that are allowed to run GitHub Actions."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum EnabledRepositories {
    #[serde(rename = "all")]
    #[display("all")]
    All,
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[serde(rename = "selected")]
    #[display("selected")]
    Selected,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsOrganizationPermissions {
    #[doc = "The policy that controls the repositories in the organization that are allowed to run GitHub Actions."]
    pub enabled_repositories: EnabledRepositories,
    #[doc = "The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_repositories_url: Option<String>,
    #[doc = "The permissions policy that controls the actions and reusable workflows that are allowed to run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allowed_actions: Option<AllowedActions>,
    #[doc = "The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_actions_url: Option<String>,
}

impl std::fmt::Display for ActionsOrganizationPermissions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsOrganizationPermissions {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.enabled_repositories),
            if let Some(selected_repositories_url) = &self.selected_repositories_url {
                format!("{:?}", selected_repositories_url)
            } else {
                String::new()
            },
            if let Some(allowed_actions) = &self.allowed_actions {
                format!("{:?}", allowed_actions)
            } else {
                String::new()
            },
            if let Some(selected_actions_url) = &self.selected_actions_url {
                format!("{:?}", selected_actions_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enabled_repositories".to_string(),
            "selected_repositories_url".to_string(),
            "allowed_actions".to_string(),
            "selected_actions_url".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RunnerGroupsOrg {
    pub id: f64,
    pub name: String,
    pub visibility: String,
    pub default: bool,
    #[doc = "Link to the selected repositories resource for this runner group. Not present unless visibility was set to `selected`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_repositories_url: Option<String>,
    pub runners_url: String,
    pub inherited: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inherited_allows_public_repositories: Option<bool>,
    pub allows_public_repositories: bool,
    #[doc = "If `true`, the `restricted_to_workflows` and `selected_workflows` fields cannot be modified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_restrictions_read_only: Option<bool>,
    #[doc = "If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restricted_to_workflows: Option<bool>,
    #[doc = "List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_workflows: Option<Vec<String>>,
}

impl std::fmt::Display for RunnerGroupsOrg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RunnerGroupsOrg {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.name.clone(),
            self.visibility.clone(),
            format!("{:?}", self.default),
            if let Some(selected_repositories_url) = &self.selected_repositories_url {
                format!("{:?}", selected_repositories_url)
            } else {
                String::new()
            },
            self.runners_url.clone(),
            format!("{:?}", self.inherited),
            if let Some(inherited_allows_public_repositories) =
                &self.inherited_allows_public_repositories
            {
                format!("{:?}", inherited_allows_public_repositories)
            } else {
                String::new()
            },
            format!("{:?}", self.allows_public_repositories),
            if let Some(workflow_restrictions_read_only) = &self.workflow_restrictions_read_only {
                format!("{:?}", workflow_restrictions_read_only)
            } else {
                String::new()
            },
            if let Some(restricted_to_workflows) = &self.restricted_to_workflows {
                format!("{:?}", restricted_to_workflows)
            } else {
                String::new()
            },
            if let Some(selected_workflows) = &self.selected_workflows {
                format!("{:?}", selected_workflows)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "name".to_string(),
            "visibility".to_string(),
            "default".to_string(),
            "selected_repositories_url".to_string(),
            "runners_url".to_string(),
            "inherited".to_string(),
            "inherited_allows_public_repositories".to_string(),
            "allows_public_repositories".to_string(),
            "workflow_restrictions_read_only".to_string(),
            "restricted_to_workflows".to_string(),
            "selected_workflows".to_string(),
        ]
    }
}

#[doc = "Secrets for GitHub Actions for an organization."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationActionsSecret {
    #[doc = "The name of the secret."]
    pub name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Visibility of a secret"]
    pub visibility: Visibility,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_repositories_url: Option<url::Url>,
}

impl std::fmt::Display for OrganizationActionsSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationActionsSecret {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.visibility),
            if let Some(selected_repositories_url) = &self.selected_repositories_url {
                format!("{:?}", selected_repositories_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "visibility".to_string(),
            "selected_repositories_url".to_string(),
        ]
    }
}

#[doc = "The public key used for setting Actions Secrets."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsPublicKey {
    #[doc = "The identifier for the key."]
    pub key_id: String,
    #[doc = "The Base64 encoded public key."]
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
}

impl std::fmt::Display for ActionsPublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsPublicKey {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            self.key_id.clone(),
            self.key.clone(),
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(title) = &self.title {
                format!("{:?}", title)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "key_id".to_string(),
            "key".to_string(),
            "id".to_string(),
            "url".to_string(),
            "title".to_string(),
            "created_at".to_string(),
        ]
    }
}

#[doc = "A description of the machine powering a codespace."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableCodespaceMachine {
    #[doc = "The name of the machine."]
    pub name: String,
    #[doc = "The display name of the machine includes cores, memory, and storage."]
    pub display_name: String,
    #[doc = "The operating system of the machine."]
    pub operating_system: String,
    #[doc = "How much storage is available to the codespace."]
    pub storage_in_bytes: i64,
    #[doc = "How much memory is available to the codespace."]
    pub memory_in_bytes: i64,
    #[doc = "How many cores are available to the codespace."]
    pub cpus: i64,
    #[doc = "Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be \"null\" if prebuilds are not supported or prebuild availability could not be determined. Value will be \"none\" if no prebuild is available. Latest values \"ready\" and \"in_progress\" indicate the prebuild availability status."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prebuild_availability: Option<PrebuildAvailability>,
}

impl std::fmt::Display for NullableCodespaceMachine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableCodespaceMachine {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            self.display_name.clone(),
            self.operating_system.clone(),
            format!("{:?}", self.storage_in_bytes),
            format!("{:?}", self.memory_in_bytes),
            format!("{:?}", self.cpus),
            format!("{:?}", self.prebuild_availability),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "display_name".to_string(),
            "operating_system".to_string(),
            "storage_in_bytes".to_string(),
            "memory_in_bytes".to_string(),
            "cpus".to_string(),
            "prebuild_availability".to_string(),
        ]
    }
}

#[doc = "A codespace."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Codespace {
    pub id: i64,
    #[doc = "Automatically generated name of this codespace."]
    pub name: String,
    #[doc = "Display name for this codespace."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[doc = "UUID identifying this codespace's environment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environment_id: Option<String>,
    #[doc = "Simple User"]
    pub owner: SimpleUser,
    #[doc = "Simple User"]
    pub billable_owner: SimpleUser,
    #[doc = "Minimal Repository"]
    pub repository: MinimalRepository,
    #[doc = "A description of the machine powering a codespace."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub machine: Option<NullableCodespaceMachine>,
    #[doc = "Path to devcontainer.json from repo root used to create Codespace."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub devcontainer_path: Option<String>,
    #[doc = "Whether the codespace was created from a prebuild."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prebuild: Option<bool>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Last known time this codespace was started."]
    pub last_used_at: chrono::DateTime<chrono::Utc>,
    #[doc = "State of this codespace."]
    pub state: State,
    #[doc = "API URL for this codespace."]
    pub url: url::Url,
    #[doc = "Details about the codespace's git repository."]
    pub git_status: GitStatus,
    #[doc = "The Azure region where this codespace is located."]
    pub location: Location,
    #[doc = "The number of minutes of inactivity after which this codespace will be automatically stopped."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub idle_timeout_minutes: Option<i64>,
    #[doc = "URL to access this codespace on the web."]
    pub web_url: url::Url,
    #[doc = "API URL to access available alternate machine types for this codespace."]
    pub machines_url: url::Url,
    #[doc = "API URL to start this codespace."]
    pub start_url: url::Url,
    #[doc = "API URL to stop this codespace."]
    pub stop_url: url::Url,
    #[doc = "API URL for the Pull Request associated with this codespace, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pulls_url: Option<url::Url>,
    pub recent_folders: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub runtime_constraints: Option<RuntimeConstraints>,
    #[doc = "Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pending_operation: Option<bool>,
    #[doc = "Text to show user when codespace is disabled by a pending operation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pending_operation_disabled_reason: Option<String>,
    #[doc = "Text to show user when codespace idle timeout minutes has been overriden by an organization policy"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub idle_timeout_notice: Option<String>,
}

impl std::fmt::Display for Codespace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Codespace {
    const LENGTH: usize = 28;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.name.clone(),
            if let Some(display_name) = &self.display_name {
                format!("{:?}", display_name)
            } else {
                String::new()
            },
            format!("{:?}", self.environment_id),
            format!("{:?}", self.owner),
            format!("{:?}", self.billable_owner),
            format!("{:?}", self.repository),
            format!("{:?}", self.machine),
            if let Some(devcontainer_path) = &self.devcontainer_path {
                format!("{:?}", devcontainer_path)
            } else {
                String::new()
            },
            format!("{:?}", self.prebuild),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.last_used_at),
            format!("{:?}", self.state),
            format!("{:?}", self.url),
            format!("{:?}", self.git_status),
            format!("{:?}", self.location),
            format!("{:?}", self.idle_timeout_minutes),
            format!("{:?}", self.web_url),
            format!("{:?}", self.machines_url),
            format!("{:?}", self.start_url),
            format!("{:?}", self.stop_url),
            format!("{:?}", self.pulls_url),
            format!("{:?}", self.recent_folders),
            if let Some(runtime_constraints) = &self.runtime_constraints {
                format!("{:?}", runtime_constraints)
            } else {
                String::new()
            },
            if let Some(pending_operation) = &self.pending_operation {
                format!("{:?}", pending_operation)
            } else {
                String::new()
            },
            if let Some(pending_operation_disabled_reason) = &self.pending_operation_disabled_reason
            {
                format!("{:?}", pending_operation_disabled_reason)
            } else {
                String::new()
            },
            if let Some(idle_timeout_notice) = &self.idle_timeout_notice {
                format!("{:?}", idle_timeout_notice)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "name".to_string(),
            "display_name".to_string(),
            "environment_id".to_string(),
            "owner".to_string(),
            "billable_owner".to_string(),
            "repository".to_string(),
            "machine".to_string(),
            "devcontainer_path".to_string(),
            "prebuild".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "last_used_at".to_string(),
            "state".to_string(),
            "url".to_string(),
            "git_status".to_string(),
            "location".to_string(),
            "idle_timeout_minutes".to_string(),
            "web_url".to_string(),
            "machines_url".to_string(),
            "start_url".to_string(),
            "stop_url".to_string(),
            "pulls_url".to_string(),
            "recent_folders".to_string(),
            "runtime_constraints".to_string(),
            "pending_operation".to_string(),
            "pending_operation_disabled_reason".to_string(),
            "idle_timeout_notice".to_string(),
        ]
    }
}

#[doc = "Credential Authorization"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CredentialAuthorization {
    #[doc = "User login that owns the underlying credential."]
    pub login: String,
    #[doc = "Unique identifier for the credential."]
    pub credential_id: i64,
    #[doc = "Human-readable description of the credential type."]
    pub credential_type: String,
    #[doc = "Last eight characters of the credential. Only included in responses with credential_type of personal access token."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token_last_eight: Option<String>,
    #[doc = "Date when the credential was authorized for use."]
    pub credential_authorized_at: chrono::DateTime<chrono::Utc>,
    #[doc = "List of oauth scopes the token has been granted."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    #[doc = "Unique string to distinguish the credential. Only included in responses with credential_type of SSH Key."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fingerprint: Option<String>,
    #[doc = "Date when the credential was last accessed. May be null if it was never accessed"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credential_accessed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_credential_id: Option<i64>,
    #[doc = "The title given to the ssh key. This will only be present when the credential is an ssh key."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_credential_title: Option<String>,
    #[doc = "The note given to the token. This will only be present when the credential is a token."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_credential_note: Option<String>,
    #[doc = "The expiry for the token. This will only be present when the credential is a token."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_credential_expires_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for CredentialAuthorization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CredentialAuthorization {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            self.login.clone(),
            format!("{:?}", self.credential_id),
            self.credential_type.clone(),
            if let Some(token_last_eight) = &self.token_last_eight {
                format!("{:?}", token_last_eight)
            } else {
                String::new()
            },
            format!("{:?}", self.credential_authorized_at),
            if let Some(scopes) = &self.scopes {
                format!("{:?}", scopes)
            } else {
                String::new()
            },
            if let Some(fingerprint) = &self.fingerprint {
                format!("{:?}", fingerprint)
            } else {
                String::new()
            },
            format!("{:?}", self.credential_accessed_at),
            format!("{:?}", self.authorized_credential_id),
            if let Some(authorized_credential_title) = &self.authorized_credential_title {
                format!("{:?}", authorized_credential_title)
            } else {
                String::new()
            },
            if let Some(authorized_credential_note) = &self.authorized_credential_note {
                format!("{:?}", authorized_credential_note)
            } else {
                String::new()
            },
            if let Some(authorized_credential_expires_at) = &self.authorized_credential_expires_at {
                format!("{:?}", authorized_credential_expires_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "login".to_string(),
            "credential_id".to_string(),
            "credential_type".to_string(),
            "token_last_eight".to_string(),
            "credential_authorized_at".to_string(),
            "scopes".to_string(),
            "fingerprint".to_string(),
            "credential_accessed_at".to_string(),
            "authorized_credential_id".to_string(),
            "authorized_credential_title".to_string(),
            "authorized_credential_note".to_string(),
            "authorized_credential_expires_at".to_string(),
        ]
    }
}

#[doc = "Secrets for GitHub Dependabot for an organization."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationDependabotSecret {
    #[doc = "The name of the secret."]
    pub name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Visibility of a secret"]
    pub visibility: Visibility,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_repositories_url: Option<url::Url>,
}

impl std::fmt::Display for OrganizationDependabotSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationDependabotSecret {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.visibility),
            if let Some(selected_repositories_url) = &self.selected_repositories_url {
                format!("{:?}", selected_repositories_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "visibility".to_string(),
            "selected_repositories_url".to_string(),
        ]
    }
}

#[doc = "The public key used for setting Dependabot Secrets."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DependabotPublicKey {
    #[doc = "The identifier for the key."]
    pub key_id: String,
    #[doc = "The Base64 encoded public key."]
    pub key: String,
}

impl std::fmt::Display for DependabotPublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DependabotPublicKey {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.key_id.clone(), self.key.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["key_id".to_string(), "key".to_string()]
    }
}

#[doc = "Information about an external group's usage and its members"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExternalGroup {
    #[doc = "The internal ID of the group"]
    pub group_id: i64,
    #[doc = "The display name for the group"]
    pub group_name: String,
    #[doc = "The date when the group was last updated_at"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<String>,
    #[doc = "An array of teams linked to this group"]
    pub teams: Vec<Teams>,
    #[doc = "An array of external members linked to this group"]
    pub members: Vec<Members>,
}

impl std::fmt::Display for ExternalGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ExternalGroup {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.group_id),
            self.group_name.clone(),
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            format!("{:?}", self.teams),
            format!("{:?}", self.members),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "group_id".to_string(),
            "group_name".to_string(),
            "updated_at".to_string(),
            "teams".to_string(),
            "members".to_string(),
        ]
    }
}

#[doc = "A list of external groups available to be connected to a team"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExternalGroups {
    #[doc = "An array of external groups available to be mapped to a team"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<Groups>>,
}

impl std::fmt::Display for ExternalGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ExternalGroups {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(groups) = &self.groups {
            format!("{:?}", groups)
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["groups".to_string()]
    }
}

#[doc = "Organization Invitation"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationInvitation {
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub login: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub role: String,
    pub created_at: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failed_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failed_reason: Option<String>,
    #[doc = "Simple User"]
    pub inviter: SimpleUser,
    pub team_count: i64,
    pub node_id: String,
    pub invitation_teams_url: String,
}

impl std::fmt::Display for OrganizationInvitation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationInvitation {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            format!("{:?}", self.login),
            format!("{:?}", self.email),
            self.role.clone(),
            self.created_at.clone(),
            if let Some(failed_at) = &self.failed_at {
                format!("{:?}", failed_at)
            } else {
                String::new()
            },
            if let Some(failed_reason) = &self.failed_reason {
                format!("{:?}", failed_reason)
            } else {
                String::new()
            },
            format!("{:?}", self.inviter),
            format!("{:?}", self.team_count),
            self.node_id.clone(),
            self.invitation_teams_url.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "login".to_string(),
            "email".to_string(),
            "role".to_string(),
            "created_at".to_string(),
            "failed_at".to_string(),
            "failed_reason".to_string(),
            "inviter".to_string(),
            "team_count".to_string(),
            "node_id".to_string(),
            "invitation_teams_url".to_string(),
        ]
    }
}

#[doc = "Org Hook"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgHook {
    pub id: i64,
    pub url: url::Url,
    pub ping_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deliveries_url: Option<url::Url>,
    pub name: String,
    pub events: Vec<String>,
    pub active: bool,
    pub config: Config,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "type")]
    pub type_: String,
}

impl std::fmt::Display for OrgHook {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrgHook {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            format!("{:?}", self.url),
            format!("{:?}", self.ping_url),
            if let Some(deliveries_url) = &self.deliveries_url {
                format!("{:?}", deliveries_url)
            } else {
                String::new()
            },
            self.name.clone(),
            format!("{:?}", self.events),
            format!("{:?}", self.active),
            format!("{:?}", self.config),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.created_at),
            self.type_.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "url".to_string(),
            "ping_url".to_string(),
            "deliveries_url".to_string(),
            "name".to_string(),
            "events".to_string(),
            "active".to_string(),
            "config".to_string(),
            "updated_at".to_string(),
            "created_at".to_string(),
            "type_".to_string(),
        ]
    }
}

#[doc = "The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum InteractionGroup {
    #[serde(rename = "existing_users")]
    #[display("existing_users")]
    ExistingUsers,
    #[serde(rename = "contributors_only")]
    #[display("contributors_only")]
    ContributorsOnly,
    #[serde(rename = "collaborators_only")]
    #[display("collaborators_only")]
    CollaboratorsOnly,
}

#[doc = "Interaction limit settings."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InteractionLimitResponse {
    #[doc = "The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect."]
    pub limit: InteractionGroup,
    pub origin: String,
    pub expires_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for InteractionLimitResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InteractionLimitResponse {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.limit),
            self.origin.clone(),
            format!("{:?}", self.expires_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "limit".to_string(),
            "origin".to_string(),
            "expires_at".to_string(),
        ]
    }
}

#[doc = "The duration of the interaction restriction. Default: `one_day`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum InteractionExpiry {
    #[serde(rename = "one_day")]
    #[display("one_day")]
    OneDay,
    #[serde(rename = "three_days")]
    #[display("three_days")]
    ThreeDays,
    #[serde(rename = "one_week")]
    #[display("one_week")]
    OneWeek,
    #[serde(rename = "one_month")]
    #[display("one_month")]
    OneMonth,
    #[serde(rename = "six_months")]
    #[display("six_months")]
    SixMonths,
}

#[doc = "Limit interactions to a specific type of user for a specified duration"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InteractionLimit {
    #[doc = "The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect."]
    pub limit: InteractionGroup,
    #[doc = "The duration of the interaction restriction. Default: `one_day`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expiry: Option<InteractionExpiry>,
}

impl std::fmt::Display for InteractionLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InteractionLimit {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.limit),
            if let Some(expiry) = &self.expiry {
                format!("{:?}", expiry)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["limit".to_string(), "expiry".to_string()]
    }
}

#[doc = "Groups of organization members that gives permissions on specified repositories."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableTeamSimple {
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub node_id: String,
    #[doc = "URL for the team"]
    pub url: url::Url,
    pub members_url: String,
    #[doc = "Name of the team"]
    pub name: String,
    #[doc = "Description of the team"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: String,
    #[doc = "The level of privacy this team should have"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privacy: Option<String>,
    pub html_url: url::Url,
    pub repositories_url: url::Url,
    pub slug: String,
    #[doc = "Distinguished Name (DN) that team maps to within LDAP environment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ldap_dn: Option<String>,
}

impl std::fmt::Display for NullableTeamSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableTeamSimple {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            self.members_url.clone(),
            self.name.clone(),
            format!("{:?}", self.description),
            self.permission.clone(),
            if let Some(privacy) = &self.privacy {
                format!("{:?}", privacy)
            } else {
                String::new()
            },
            format!("{:?}", self.html_url),
            format!("{:?}", self.repositories_url),
            self.slug.clone(),
            if let Some(ldap_dn) = &self.ldap_dn {
                format!("{:?}", ldap_dn)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "members_url".to_string(),
            "name".to_string(),
            "description".to_string(),
            "permission".to_string(),
            "privacy".to_string(),
            "html_url".to_string(),
            "repositories_url".to_string(),
            "slug".to_string(),
            "ldap_dn".to_string(),
        ]
    }
}

#[doc = "Groups of organization members that gives permissions on specified repositories."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Team {
    pub id: i64,
    pub node_id: String,
    pub name: String,
    pub slug: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privacy: Option<String>,
    pub permission: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    pub url: url::Url,
    pub html_url: url::Url,
    pub members_url: String,
    pub repositories_url: url::Url,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<NullableTeamSimple>,
}

impl std::fmt::Display for Team {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Team {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.slug.clone(),
            format!("{:?}", self.description),
            if let Some(privacy) = &self.privacy {
                format!("{:?}", privacy)
            } else {
                String::new()
            },
            self.permission.clone(),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            self.members_url.clone(),
            format!("{:?}", self.repositories_url),
            format!("{:?}", self.parent),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "slug".to_string(),
            "description".to_string(),
            "privacy".to_string(),
            "permission".to_string(),
            "permissions".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "members_url".to_string(),
            "repositories_url".to_string(),
            "parent".to_string(),
        ]
    }
}

#[doc = "An export of a codespace. Also, latest export details for a codespace can be fetched with id = latest"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodespaceExportDetails {
    #[doc = "State of the latest export"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    #[doc = "Completion time of the last export operation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Name of the exported branch"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub branch: Option<String>,
    #[doc = "Git commit SHA of the exported branch"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sha: Option<String>,
    #[doc = "Id for the export details"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Url for fetching export details"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub export_url: Option<String>,
    #[doc = "Web url for the exported branch"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
}

impl std::fmt::Display for CodespaceExportDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodespaceExportDetails {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(state) = &self.state {
                format!("{:?}", state)
            } else {
                String::new()
            },
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at)
            } else {
                String::new()
            },
            if let Some(branch) = &self.branch {
                format!("{:?}", branch)
            } else {
                String::new()
            },
            if let Some(sha) = &self.sha {
                format!("{:?}", sha)
            } else {
                String::new()
            },
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(export_url) = &self.export_url {
                format!("{:?}", export_url)
            } else {
                String::new()
            },
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "state".to_string(),
            "completed_at".to_string(),
            "branch".to_string(),
            "sha".to_string(),
            "id".to_string(),
            "export_url".to_string(),
            "html_url".to_string(),
        ]
    }
}

#[doc = "Org Membership"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgMembership {
    pub url: url::Url,
    #[doc = "The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation."]
    pub state: State,
    #[doc = "The user's membership type in the organization."]
    pub role: Role,
    pub organization_url: url::Url,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
}

impl std::fmt::Display for OrgMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrgMembership {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.state),
            format!("{:?}", self.role),
            format!("{:?}", self.organization_url),
            format!("{:?}", self.organization),
            format!("{:?}", self.user),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "state".to_string(),
            "role".to_string(),
            "organization_url".to_string(),
            "organization".to_string(),
            "user".to_string(),
            "permissions".to_string(),
        ]
    }
}

#[doc = "A migration."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Migration {
    pub id: i64,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    pub guid: String,
    pub state: String,
    pub lock_repositories: bool,
    pub exclude_metadata: bool,
    pub exclude_git_data: bool,
    pub exclude_attachments: bool,
    pub exclude_releases: bool,
    pub exclude_owner_projects: bool,
    pub org_metadata_only: bool,
    pub repositories: Vec<Repository>,
    pub url: url::Url,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archive_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exclude: Option<Vec<serde_json::Value>>,
}

impl std::fmt::Display for Migration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Migration {
    const LENGTH: usize = 18;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            format!("{:?}", self.owner),
            self.guid.clone(),
            self.state.clone(),
            format!("{:?}", self.lock_repositories),
            format!("{:?}", self.exclude_metadata),
            format!("{:?}", self.exclude_git_data),
            format!("{:?}", self.exclude_attachments),
            format!("{:?}", self.exclude_releases),
            format!("{:?}", self.exclude_owner_projects),
            format!("{:?}", self.org_metadata_only),
            format!("{:?}", self.repositories),
            format!("{:?}", self.url),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            self.node_id.clone(),
            if let Some(archive_url) = &self.archive_url {
                format!("{:?}", archive_url)
            } else {
                String::new()
            },
            if let Some(exclude) = &self.exclude {
                format!("{:?}", exclude)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "owner".to_string(),
            "guid".to_string(),
            "state".to_string(),
            "lock_repositories".to_string(),
            "exclude_metadata".to_string(),
            "exclude_git_data".to_string(),
            "exclude_attachments".to_string(),
            "exclude_releases".to_string(),
            "exclude_owner_projects".to_string(),
            "org_metadata_only".to_string(),
            "repositories".to_string(),
            "url".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "node_id".to_string(),
            "archive_url".to_string(),
            "exclude".to_string(),
        ]
    }
}

#[doc = "Minimal Repository"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableMinimalRepository {
    pub id: i64,
    pub node_id: String,
    pub name: String,
    pub full_name: String,
    #[doc = "Simple User"]
    pub owner: SimpleUser,
    pub private: bool,
    pub html_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub fork: bool,
    pub url: url::Url,
    pub archive_url: String,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: url::Url,
    pub deployments_url: url::Url,
    pub downloads_url: url::Url,
    pub events_url: url::Url,
    pub forks_url: url::Url,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_url: Option<String>,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub languages_url: url::Url,
    pub merges_url: url::Url,
    pub milestones_url: String,
    pub notifications_url: String,
    pub pulls_url: String,
    pub releases_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ssh_url: Option<String>,
    pub stargazers_url: url::Url,
    pub statuses_url: String,
    pub subscribers_url: url::Url,
    pub subscription_url: url::Url,
    pub tags_url: url::Url,
    pub teams_url: url::Url,
    pub trees_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror_url: Option<String>,
    pub hooks_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub watchers_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_projects: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_pages: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_downloads: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archived: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub visibility: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role_name: Option<String>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template_repository: Option<NullableRepository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network_count: Option<i64>,
    #[doc = "Code Of Conduct"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code_of_conduct: Option<CodeOfConduct>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forks: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
}

impl std::fmt::Display for NullableMinimalRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableMinimalRepository {
    const LENGTH: usize = 85;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.full_name.clone(),
            format!("{:?}", self.owner),
            format!("{:?}", self.private),
            format!("{:?}", self.html_url),
            format!("{:?}", self.description),
            format!("{:?}", self.fork),
            format!("{:?}", self.url),
            self.archive_url.clone(),
            self.assignees_url.clone(),
            self.blobs_url.clone(),
            self.branches_url.clone(),
            self.collaborators_url.clone(),
            self.comments_url.clone(),
            self.commits_url.clone(),
            self.compare_url.clone(),
            self.contents_url.clone(),
            format!("{:?}", self.contributors_url),
            format!("{:?}", self.deployments_url),
            format!("{:?}", self.downloads_url),
            format!("{:?}", self.events_url),
            format!("{:?}", self.forks_url),
            self.git_commits_url.clone(),
            self.git_refs_url.clone(),
            self.git_tags_url.clone(),
            if let Some(git_url) = &self.git_url {
                format!("{:?}", git_url)
            } else {
                String::new()
            },
            self.issue_comment_url.clone(),
            self.issue_events_url.clone(),
            self.issues_url.clone(),
            self.keys_url.clone(),
            self.labels_url.clone(),
            format!("{:?}", self.languages_url),
            format!("{:?}", self.merges_url),
            self.milestones_url.clone(),
            self.notifications_url.clone(),
            self.pulls_url.clone(),
            self.releases_url.clone(),
            if let Some(ssh_url) = &self.ssh_url {
                format!("{:?}", ssh_url)
            } else {
                String::new()
            },
            format!("{:?}", self.stargazers_url),
            self.statuses_url.clone(),
            format!("{:?}", self.subscribers_url),
            format!("{:?}", self.subscription_url),
            format!("{:?}", self.tags_url),
            format!("{:?}", self.teams_url),
            self.trees_url.clone(),
            if let Some(clone_url) = &self.clone_url {
                format!("{:?}", clone_url)
            } else {
                String::new()
            },
            if let Some(mirror_url) = &self.mirror_url {
                format!("{:?}", mirror_url)
            } else {
                String::new()
            },
            format!("{:?}", self.hooks_url),
            if let Some(svn_url) = &self.svn_url {
                format!("{:?}", svn_url)
            } else {
                String::new()
            },
            if let Some(homepage) = &self.homepage {
                format!("{:?}", homepage)
            } else {
                String::new()
            },
            if let Some(language) = &self.language {
                format!("{:?}", language)
            } else {
                String::new()
            },
            if let Some(forks_count) = &self.forks_count {
                format!("{:?}", forks_count)
            } else {
                String::new()
            },
            if let Some(stargazers_count) = &self.stargazers_count {
                format!("{:?}", stargazers_count)
            } else {
                String::new()
            },
            if let Some(watchers_count) = &self.watchers_count {
                format!("{:?}", watchers_count)
            } else {
                String::new()
            },
            if let Some(size) = &self.size {
                format!("{:?}", size)
            } else {
                String::new()
            },
            if let Some(default_branch) = &self.default_branch {
                format!("{:?}", default_branch)
            } else {
                String::new()
            },
            if let Some(open_issues_count) = &self.open_issues_count {
                format!("{:?}", open_issues_count)
            } else {
                String::new()
            },
            if let Some(is_template) = &self.is_template {
                format!("{:?}", is_template)
            } else {
                String::new()
            },
            if let Some(topics) = &self.topics {
                format!("{:?}", topics)
            } else {
                String::new()
            },
            if let Some(has_issues) = &self.has_issues {
                format!("{:?}", has_issues)
            } else {
                String::new()
            },
            if let Some(has_projects) = &self.has_projects {
                format!("{:?}", has_projects)
            } else {
                String::new()
            },
            if let Some(has_wiki) = &self.has_wiki {
                format!("{:?}", has_wiki)
            } else {
                String::new()
            },
            if let Some(has_pages) = &self.has_pages {
                format!("{:?}", has_pages)
            } else {
                String::new()
            },
            if let Some(has_downloads) = &self.has_downloads {
                format!("{:?}", has_downloads)
            } else {
                String::new()
            },
            if let Some(archived) = &self.archived {
                format!("{:?}", archived)
            } else {
                String::new()
            },
            if let Some(disabled) = &self.disabled {
                format!("{:?}", disabled)
            } else {
                String::new()
            },
            if let Some(visibility) = &self.visibility {
                format!("{:?}", visibility)
            } else {
                String::new()
            },
            if let Some(pushed_at) = &self.pushed_at {
                format!("{:?}", pushed_at)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            if let Some(role_name) = &self.role_name {
                format!("{:?}", role_name)
            } else {
                String::new()
            },
            if let Some(template_repository) = &self.template_repository {
                format!("{:?}", template_repository)
            } else {
                String::new()
            },
            if let Some(temp_clone_token) = &self.temp_clone_token {
                format!("{:?}", temp_clone_token)
            } else {
                String::new()
            },
            if let Some(delete_branch_on_merge) = &self.delete_branch_on_merge {
                format!("{:?}", delete_branch_on_merge)
            } else {
                String::new()
            },
            if let Some(subscribers_count) = &self.subscribers_count {
                format!("{:?}", subscribers_count)
            } else {
                String::new()
            },
            if let Some(network_count) = &self.network_count {
                format!("{:?}", network_count)
            } else {
                String::new()
            },
            if let Some(code_of_conduct) = &self.code_of_conduct {
                format!("{:?}", code_of_conduct)
            } else {
                String::new()
            },
            if let Some(license) = &self.license {
                format!("{:?}", license)
            } else {
                String::new()
            },
            if let Some(forks) = &self.forks {
                format!("{:?}", forks)
            } else {
                String::new()
            },
            if let Some(open_issues) = &self.open_issues {
                format!("{:?}", open_issues)
            } else {
                String::new()
            },
            if let Some(watchers) = &self.watchers {
                format!("{:?}", watchers)
            } else {
                String::new()
            },
            if let Some(allow_forking) = &self.allow_forking {
                format!("{:?}", allow_forking)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "full_name".to_string(),
            "owner".to_string(),
            "private".to_string(),
            "html_url".to_string(),
            "description".to_string(),
            "fork".to_string(),
            "url".to_string(),
            "archive_url".to_string(),
            "assignees_url".to_string(),
            "blobs_url".to_string(),
            "branches_url".to_string(),
            "collaborators_url".to_string(),
            "comments_url".to_string(),
            "commits_url".to_string(),
            "compare_url".to_string(),
            "contents_url".to_string(),
            "contributors_url".to_string(),
            "deployments_url".to_string(),
            "downloads_url".to_string(),
            "events_url".to_string(),
            "forks_url".to_string(),
            "git_commits_url".to_string(),
            "git_refs_url".to_string(),
            "git_tags_url".to_string(),
            "git_url".to_string(),
            "issue_comment_url".to_string(),
            "issue_events_url".to_string(),
            "issues_url".to_string(),
            "keys_url".to_string(),
            "labels_url".to_string(),
            "languages_url".to_string(),
            "merges_url".to_string(),
            "milestones_url".to_string(),
            "notifications_url".to_string(),
            "pulls_url".to_string(),
            "releases_url".to_string(),
            "ssh_url".to_string(),
            "stargazers_url".to_string(),
            "statuses_url".to_string(),
            "subscribers_url".to_string(),
            "subscription_url".to_string(),
            "tags_url".to_string(),
            "teams_url".to_string(),
            "trees_url".to_string(),
            "clone_url".to_string(),
            "mirror_url".to_string(),
            "hooks_url".to_string(),
            "svn_url".to_string(),
            "homepage".to_string(),
            "language".to_string(),
            "forks_count".to_string(),
            "stargazers_count".to_string(),
            "watchers_count".to_string(),
            "size".to_string(),
            "default_branch".to_string(),
            "open_issues_count".to_string(),
            "is_template".to_string(),
            "topics".to_string(),
            "has_issues".to_string(),
            "has_projects".to_string(),
            "has_wiki".to_string(),
            "has_pages".to_string(),
            "has_downloads".to_string(),
            "archived".to_string(),
            "disabled".to_string(),
            "visibility".to_string(),
            "pushed_at".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "permissions".to_string(),
            "role_name".to_string(),
            "template_repository".to_string(),
            "temp_clone_token".to_string(),
            "delete_branch_on_merge".to_string(),
            "subscribers_count".to_string(),
            "network_count".to_string(),
            "code_of_conduct".to_string(),
            "license".to_string(),
            "forks".to_string(),
            "open_issues".to_string(),
            "watchers".to_string(),
            "allow_forking".to_string(),
        ]
    }
}

#[doc = "A software package"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Package {
    #[doc = "Unique identifier of the package."]
    pub id: i64,
    #[doc = "The name of the package."]
    pub name: String,
    pub package_type: PackageType,
    pub url: String,
    pub html_url: String,
    #[doc = "The number of versions of the package."]
    pub version_count: i64,
    pub visibility: Visibility,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    #[doc = "Minimal Repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<NullableMinimalRepository>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Package {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Package {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.name.clone(),
            format!("{:?}", self.package_type),
            self.url.clone(),
            self.html_url.clone(),
            format!("{:?}", self.version_count),
            format!("{:?}", self.visibility),
            if let Some(owner) = &self.owner {
                format!("{:?}", owner)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "name".to_string(),
            "package_type".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "version_count".to_string(),
            "visibility".to_string(),
            "owner".to_string(),
            "repository".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
        ]
    }
}

#[doc = "A version of a software package"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PackageVersion {
    #[doc = "Unique identifier of the package version."]
    pub id: i64,
    #[doc = "The name of the package version."]
    pub name: String,
    pub url: String,
    pub package_html_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deleted_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,
}

impl std::fmt::Display for PackageVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PackageVersion {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.name.clone(),
            self.url.clone(),
            self.package_html_url.clone(),
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
            if let Some(license) = &self.license {
                format!("{:?}", license)
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{:?}", description)
            } else {
                String::new()
            },
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(deleted_at) = &self.deleted_at {
                format!("{:?}", deleted_at)
            } else {
                String::new()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "name".to_string(),
            "url".to_string(),
            "package_html_url".to_string(),
            "html_url".to_string(),
            "license".to_string(),
            "description".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "deleted_at".to_string(),
            "metadata".to_string(),
        ]
    }
}

#[doc = "Projects are a way to organize columns and cards of work."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Project {
    pub owner_url: url::Url,
    pub url: url::Url,
    pub html_url: url::Url,
    pub columns_url: url::Url,
    pub id: i64,
    pub node_id: String,
    #[doc = "Name of the project"]
    pub name: String,
    #[doc = "Body of the project"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    pub number: i64,
    #[doc = "State of the project; either 'open' or 'closed'"]
    pub state: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The baseline permission that all organization members have on this project. Only present if owner is an organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_permission: Option<OrganizationPermission>,
    #[doc = "Whether or not this project can be seen by everyone. Only present if owner is an organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private: Option<bool>,
}

impl std::fmt::Display for Project {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Project {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.owner_url),
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.columns_url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            format!("{:?}", self.body),
            format!("{:?}", self.number),
            self.state.clone(),
            format!("{:?}", self.creator),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(organization_permission) = &self.organization_permission {
                format!("{:?}", organization_permission)
            } else {
                String::new()
            },
            if let Some(private) = &self.private {
                format!("{:?}", private)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "owner_url".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "columns_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "body".to_string(),
            "number".to_string(),
            "state".to_string(),
            "creator".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "organization_permission".to_string(),
            "private".to_string(),
        ]
    }
}

#[doc = "External Groups to be mapped to a team for membership"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GroupMapping {
    #[doc = "Array of groups to be mapped to this team"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<Groups>>,
}

impl std::fmt::Display for GroupMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GroupMapping {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(groups) = &self.groups {
            format!("{:?}", groups)
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["groups".to_string()]
    }
}

#[doc = "Groups of organization members that gives permissions on specified repositories."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamFull {
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub node_id: String,
    #[doc = "URL for the team"]
    pub url: url::Url,
    pub html_url: url::Url,
    #[doc = "Name of the team"]
    pub name: String,
    pub slug: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The level of privacy this team should have"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privacy: Option<Privacy>,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: String,
    pub members_url: String,
    pub repositories_url: url::Url,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<NullableTeamSimple>,
    pub members_count: i64,
    pub repos_count: i64,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Organization Full"]
    pub organization: OrganizationFull,
    #[doc = "Distinguished Name (DN) that team maps to within LDAP environment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ldap_dn: Option<String>,
}

impl std::fmt::Display for TeamFull {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamFull {
    const LENGTH: usize = 18;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            self.name.clone(),
            self.slug.clone(),
            format!("{:?}", self.description),
            if let Some(privacy) = &self.privacy {
                format!("{:?}", privacy)
            } else {
                String::new()
            },
            self.permission.clone(),
            self.members_url.clone(),
            format!("{:?}", self.repositories_url),
            if let Some(parent) = &self.parent {
                format!("{:?}", parent)
            } else {
                String::new()
            },
            format!("{:?}", self.members_count),
            format!("{:?}", self.repos_count),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.organization),
            if let Some(ldap_dn) = &self.ldap_dn {
                format!("{:?}", ldap_dn)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "name".to_string(),
            "slug".to_string(),
            "description".to_string(),
            "privacy".to_string(),
            "permission".to_string(),
            "members_url".to_string(),
            "repositories_url".to_string(),
            "parent".to_string(),
            "members_count".to_string(),
            "repos_count".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "organization".to_string(),
            "ldap_dn".to_string(),
        ]
    }
}

#[doc = "A team discussion is a persistent record of a free-form conversation within a team."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamDiscussion {
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub author: Option<NullableSimpleUser>,
    #[doc = "The main text of the discussion."]
    pub body: String,
    pub body_html: String,
    #[doc = "The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server."]
    pub body_version: String,
    pub comments_count: i64,
    pub comments_url: url::Url,
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_edited_at: Option<chrono::DateTime<chrono::Utc>>,
    pub html_url: url::Url,
    pub node_id: String,
    #[doc = "The unique sequence number of a team discussion."]
    pub number: i64,
    #[doc = "Whether or not this discussion should be pinned for easy retrieval."]
    pub pinned: bool,
    #[doc = "Whether or not this discussion should be restricted to team members and organization administrators."]
    pub private: bool,
    pub team_url: url::Url,
    #[doc = "The title of the discussion."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

impl std::fmt::Display for TeamDiscussion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamDiscussion {
    const LENGTH: usize = 18;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.author),
            self.body.clone(),
            self.body_html.clone(),
            self.body_version.clone(),
            format!("{:?}", self.comments_count),
            format!("{:?}", self.comments_url),
            format!("{:?}", self.created_at),
            format!("{:?}", self.last_edited_at),
            format!("{:?}", self.html_url),
            self.node_id.clone(),
            format!("{:?}", self.number),
            format!("{:?}", self.pinned),
            format!("{:?}", self.private),
            format!("{:?}", self.team_url),
            self.title.clone(),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.url),
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "author".to_string(),
            "body".to_string(),
            "body_html".to_string(),
            "body_version".to_string(),
            "comments_count".to_string(),
            "comments_url".to_string(),
            "created_at".to_string(),
            "last_edited_at".to_string(),
            "html_url".to_string(),
            "node_id".to_string(),
            "number".to_string(),
            "pinned".to_string(),
            "private".to_string(),
            "team_url".to_string(),
            "title".to_string(),
            "updated_at".to_string(),
            "url".to_string(),
            "reactions".to_string(),
        ]
    }
}

#[doc = "A reply to a discussion within a team."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamDiscussionComment {
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub author: Option<NullableSimpleUser>,
    #[doc = "The main text of the comment."]
    pub body: String,
    pub body_html: String,
    #[doc = "The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server."]
    pub body_version: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_edited_at: Option<chrono::DateTime<chrono::Utc>>,
    pub discussion_url: url::Url,
    pub html_url: url::Url,
    pub node_id: String,
    #[doc = "The unique sequence number of a team discussion comment."]
    pub number: i64,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

impl std::fmt::Display for TeamDiscussionComment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamDiscussionComment {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.author),
            self.body.clone(),
            self.body_html.clone(),
            self.body_version.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.last_edited_at),
            format!("{:?}", self.discussion_url),
            format!("{:?}", self.html_url),
            self.node_id.clone(),
            format!("{:?}", self.number),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.url),
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "author".to_string(),
            "body".to_string(),
            "body_html".to_string(),
            "body_version".to_string(),
            "created_at".to_string(),
            "last_edited_at".to_string(),
            "discussion_url".to_string(),
            "html_url".to_string(),
            "node_id".to_string(),
            "number".to_string(),
            "updated_at".to_string(),
            "url".to_string(),
            "reactions".to_string(),
        ]
    }
}

#[doc = "Reactions to conversations provide a way to help people express their feelings more simply and effectively."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Reaction {
    pub id: i64,
    pub node_id: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[doc = "The reaction to use"]
    pub content: Content,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Reaction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Reaction {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.user),
            format!("{:?}", self.content),
            format!("{:?}", self.created_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "user".to_string(),
            "content".to_string(),
            "created_at".to_string(),
        ]
    }
}

#[doc = "Team Membership"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamMembership {
    pub url: url::Url,
    #[doc = "The role of the user in the team."]
    pub role: Role,
    #[doc = "The state of the user's membership in the team."]
    pub state: State,
}

impl std::fmt::Display for TeamMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamMembership {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.role),
            format!("{:?}", self.state),
        ]
    }

    fn headers() -> Vec<String> {
        vec!["url".to_string(), "role".to_string(), "state".to_string()]
    }
}

#[doc = "A team's access to a project."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamProject {
    pub owner_url: String,
    pub url: String,
    pub html_url: String,
    pub columns_url: String,
    pub id: i64,
    pub node_id: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    pub number: i64,
    pub state: String,
    #[doc = "Simple User"]
    pub creator: SimpleUser,
    pub created_at: String,
    pub updated_at: String,
    #[doc = "The organization permission for this project. Only present when owner is an organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_permission: Option<String>,
    #[doc = "Whether the project is private or not. Only present when owner is an organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private: Option<bool>,
    pub permissions: Permissions,
}

impl std::fmt::Display for TeamProject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamProject {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            self.owner_url.clone(),
            self.url.clone(),
            self.html_url.clone(),
            self.columns_url.clone(),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            format!("{:?}", self.body),
            format!("{:?}", self.number),
            self.state.clone(),
            format!("{:?}", self.creator),
            self.created_at.clone(),
            self.updated_at.clone(),
            if let Some(organization_permission) = &self.organization_permission {
                format!("{:?}", organization_permission)
            } else {
                String::new()
            },
            if let Some(private) = &self.private {
                format!("{:?}", private)
            } else {
                String::new()
            },
            format!("{:?}", self.permissions),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "owner_url".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "columns_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "body".to_string(),
            "number".to_string(),
            "state".to_string(),
            "creator".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "organization_permission".to_string(),
            "private".to_string(),
            "permissions".to_string(),
        ]
    }
}

#[doc = "A team's access to a repository."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamRepository {
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub node_id: String,
    #[doc = "The name of the repository."]
    pub name: String,
    pub full_name: String,
    #[doc = "License Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    pub forks: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role_name: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    pub html_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub fork: bool,
    pub url: url::Url,
    pub archive_url: String,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: url::Url,
    pub deployments_url: url::Url,
    pub downloads_url: url::Url,
    pub events_url: url::Url,
    pub forks_url: url::Url,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub languages_url: url::Url,
    pub merges_url: url::Url,
    pub milestones_url: String,
    pub notifications_url: String,
    pub pulls_url: String,
    pub releases_url: String,
    pub ssh_url: String,
    pub stargazers_url: url::Url,
    pub statuses_url: String,
    pub subscribers_url: url::Url,
    pub subscription_url: url::Url,
    pub tags_url: url::Url,
    pub teams_url: url::Url,
    pub trees_url: String,
    pub clone_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror_url: Option<url::Url>,
    pub hooks_url: url::Url,
    pub svn_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    pub forks_count: i64,
    pub stargazers_count: i64,
    pub watchers_count: i64,
    pub size: i64,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    pub open_issues_count: i64,
    #[doc = "Whether this repository acts as a template that can be used to generate new repositories."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub has_pages: bool,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    #[doc = "Returns whether or not this repository disabled."]
    pub disabled: bool,
    #[doc = "The repository visibility: public, private, or internal."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub visibility: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template_repository: Option<NullableRepository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[doc = "Whether to allow Auto-merge to be used on pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    #[doc = "Whether to allow forking this repo"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network_count: Option<i64>,
    pub open_issues: i64,
    pub watchers: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
}

impl std::fmt::Display for TeamRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamRepository {
    const LENGTH: usize = 89;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.full_name.clone(),
            format!("{:?}", self.license),
            format!("{:?}", self.forks),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            if let Some(role_name) = &self.role_name {
                format!("{:?}", role_name)
            } else {
                String::new()
            },
            format!("{:?}", self.owner),
            format!("{:?}", self.private),
            format!("{:?}", self.html_url),
            format!("{:?}", self.description),
            format!("{:?}", self.fork),
            format!("{:?}", self.url),
            self.archive_url.clone(),
            self.assignees_url.clone(),
            self.blobs_url.clone(),
            self.branches_url.clone(),
            self.collaborators_url.clone(),
            self.comments_url.clone(),
            self.commits_url.clone(),
            self.compare_url.clone(),
            self.contents_url.clone(),
            format!("{:?}", self.contributors_url),
            format!("{:?}", self.deployments_url),
            format!("{:?}", self.downloads_url),
            format!("{:?}", self.events_url),
            format!("{:?}", self.forks_url),
            self.git_commits_url.clone(),
            self.git_refs_url.clone(),
            self.git_tags_url.clone(),
            self.git_url.clone(),
            self.issue_comment_url.clone(),
            self.issue_events_url.clone(),
            self.issues_url.clone(),
            self.keys_url.clone(),
            self.labels_url.clone(),
            format!("{:?}", self.languages_url),
            format!("{:?}", self.merges_url),
            self.milestones_url.clone(),
            self.notifications_url.clone(),
            self.pulls_url.clone(),
            self.releases_url.clone(),
            self.ssh_url.clone(),
            format!("{:?}", self.stargazers_url),
            self.statuses_url.clone(),
            format!("{:?}", self.subscribers_url),
            format!("{:?}", self.subscription_url),
            format!("{:?}", self.tags_url),
            format!("{:?}", self.teams_url),
            self.trees_url.clone(),
            self.clone_url.clone(),
            format!("{:?}", self.mirror_url),
            format!("{:?}", self.hooks_url),
            format!("{:?}", self.svn_url),
            format!("{:?}", self.homepage),
            format!("{:?}", self.language),
            format!("{:?}", self.forks_count),
            format!("{:?}", self.stargazers_count),
            format!("{:?}", self.watchers_count),
            format!("{:?}", self.size),
            self.default_branch.clone(),
            format!("{:?}", self.open_issues_count),
            if let Some(is_template) = &self.is_template {
                format!("{:?}", is_template)
            } else {
                String::new()
            },
            if let Some(topics) = &self.topics {
                format!("{:?}", topics)
            } else {
                String::new()
            },
            format!("{:?}", self.has_issues),
            format!("{:?}", self.has_projects),
            format!("{:?}", self.has_wiki),
            format!("{:?}", self.has_pages),
            format!("{:?}", self.has_downloads),
            format!("{:?}", self.archived),
            format!("{:?}", self.disabled),
            if let Some(visibility) = &self.visibility {
                format!("{:?}", visibility)
            } else {
                String::new()
            },
            format!("{:?}", self.pushed_at),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(allow_rebase_merge) = &self.allow_rebase_merge {
                format!("{:?}", allow_rebase_merge)
            } else {
                String::new()
            },
            if let Some(template_repository) = &self.template_repository {
                format!("{:?}", template_repository)
            } else {
                String::new()
            },
            if let Some(temp_clone_token) = &self.temp_clone_token {
                format!("{:?}", temp_clone_token)
            } else {
                String::new()
            },
            if let Some(allow_squash_merge) = &self.allow_squash_merge {
                format!("{:?}", allow_squash_merge)
            } else {
                String::new()
            },
            if let Some(allow_auto_merge) = &self.allow_auto_merge {
                format!("{:?}", allow_auto_merge)
            } else {
                String::new()
            },
            if let Some(delete_branch_on_merge) = &self.delete_branch_on_merge {
                format!("{:?}", delete_branch_on_merge)
            } else {
                String::new()
            },
            if let Some(allow_merge_commit) = &self.allow_merge_commit {
                format!("{:?}", allow_merge_commit)
            } else {
                String::new()
            },
            if let Some(allow_forking) = &self.allow_forking {
                format!("{:?}", allow_forking)
            } else {
                String::new()
            },
            if let Some(subscribers_count) = &self.subscribers_count {
                format!("{:?}", subscribers_count)
            } else {
                String::new()
            },
            if let Some(network_count) = &self.network_count {
                format!("{:?}", network_count)
            } else {
                String::new()
            },
            format!("{:?}", self.open_issues),
            format!("{:?}", self.watchers),
            if let Some(master_branch) = &self.master_branch {
                format!("{:?}", master_branch)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "full_name".to_string(),
            "license".to_string(),
            "forks".to_string(),
            "permissions".to_string(),
            "role_name".to_string(),
            "owner".to_string(),
            "private".to_string(),
            "html_url".to_string(),
            "description".to_string(),
            "fork".to_string(),
            "url".to_string(),
            "archive_url".to_string(),
            "assignees_url".to_string(),
            "blobs_url".to_string(),
            "branches_url".to_string(),
            "collaborators_url".to_string(),
            "comments_url".to_string(),
            "commits_url".to_string(),
            "compare_url".to_string(),
            "contents_url".to_string(),
            "contributors_url".to_string(),
            "deployments_url".to_string(),
            "downloads_url".to_string(),
            "events_url".to_string(),
            "forks_url".to_string(),
            "git_commits_url".to_string(),
            "git_refs_url".to_string(),
            "git_tags_url".to_string(),
            "git_url".to_string(),
            "issue_comment_url".to_string(),
            "issue_events_url".to_string(),
            "issues_url".to_string(),
            "keys_url".to_string(),
            "labels_url".to_string(),
            "languages_url".to_string(),
            "merges_url".to_string(),
            "milestones_url".to_string(),
            "notifications_url".to_string(),
            "pulls_url".to_string(),
            "releases_url".to_string(),
            "ssh_url".to_string(),
            "stargazers_url".to_string(),
            "statuses_url".to_string(),
            "subscribers_url".to_string(),
            "subscription_url".to_string(),
            "tags_url".to_string(),
            "teams_url".to_string(),
            "trees_url".to_string(),
            "clone_url".to_string(),
            "mirror_url".to_string(),
            "hooks_url".to_string(),
            "svn_url".to_string(),
            "homepage".to_string(),
            "language".to_string(),
            "forks_count".to_string(),
            "stargazers_count".to_string(),
            "watchers_count".to_string(),
            "size".to_string(),
            "default_branch".to_string(),
            "open_issues_count".to_string(),
            "is_template".to_string(),
            "topics".to_string(),
            "has_issues".to_string(),
            "has_projects".to_string(),
            "has_wiki".to_string(),
            "has_pages".to_string(),
            "has_downloads".to_string(),
            "archived".to_string(),
            "disabled".to_string(),
            "visibility".to_string(),
            "pushed_at".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "allow_rebase_merge".to_string(),
            "template_repository".to_string(),
            "temp_clone_token".to_string(),
            "allow_squash_merge".to_string(),
            "allow_auto_merge".to_string(),
            "delete_branch_on_merge".to_string(),
            "allow_merge_commit".to_string(),
            "allow_forking".to_string(),
            "subscribers_count".to_string(),
            "network_count".to_string(),
            "open_issues".to_string(),
            "watchers".to_string(),
            "master_branch".to_string(),
        ]
    }
}

#[doc = "Project cards represent a scope of work."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectCard {
    pub url: url::Url,
    #[doc = "The project card's ID"]
    pub id: i64,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Whether or not the card is archived"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archived: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub column_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_id: Option<String>,
    pub column_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_url: Option<url::Url>,
    pub project_url: url::Url,
}

impl std::fmt::Display for ProjectCard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectCard {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.note),
            format!("{:?}", self.creator),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(archived) = &self.archived {
                format!("{:?}", archived)
            } else {
                String::new()
            },
            if let Some(column_name) = &self.column_name {
                format!("{:?}", column_name)
            } else {
                String::new()
            },
            if let Some(project_id) = &self.project_id {
                format!("{:?}", project_id)
            } else {
                String::new()
            },
            format!("{:?}", self.column_url),
            if let Some(content_url) = &self.content_url {
                format!("{:?}", content_url)
            } else {
                String::new()
            },
            format!("{:?}", self.project_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "note".to_string(),
            "creator".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "archived".to_string(),
            "column_name".to_string(),
            "project_id".to_string(),
            "column_url".to_string(),
            "content_url".to_string(),
            "project_url".to_string(),
        ]
    }
}

#[doc = "Project columns contain cards of work."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectColumn {
    pub url: url::Url,
    pub project_url: url::Url,
    pub cards_url: url::Url,
    #[doc = "The unique identifier of the project column"]
    pub id: i64,
    pub node_id: String,
    #[doc = "Name of the project column"]
    pub name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for ProjectColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectColumn {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.project_url),
            format!("{:?}", self.cards_url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "project_url".to_string(),
            "cards_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
        ]
    }
}

#[doc = "Project Collaborator Permission"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectCollaboratorPermission {
    pub permission: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
}

impl std::fmt::Display for ProjectCollaboratorPermission {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectCollaboratorPermission {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.permission.clone(), format!("{:?}", self.user)]
    }

    fn headers() -> Vec<String> {
        vec!["permission".to_string(), "user".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RateLimit {
    pub limit: i64,
    pub remaining: i64,
    pub reset: i64,
    pub used: i64,
}

impl std::fmt::Display for RateLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RateLimit {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.limit),
            format!("{:?}", self.remaining),
            format!("{:?}", self.reset),
            format!("{:?}", self.used),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "limit".to_string(),
            "remaining".to_string(),
            "reset".to_string(),
            "used".to_string(),
        ]
    }
}

#[doc = "Rate Limit Overview"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RateLimitOverview {
    pub resources: Resources,
    pub rate: RateLimit,
}

impl std::fmt::Display for RateLimitOverview {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RateLimitOverview {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.resources), format!("{:?}", self.rate)]
    }

    fn headers() -> Vec<String> {
        vec!["resources".to_string(), "rate".to_string()]
    }
}

#[doc = "Code of Conduct Simple"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeOfConductSimple {
    pub url: url::Url,
    pub key: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
}

impl std::fmt::Display for CodeOfConductSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeOfConductSimple {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            self.key.clone(),
            self.name.clone(),
            format!("{:?}", self.html_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "key".to_string(),
            "name".to_string(),
            "html_url".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecurityAndAnalysis {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub advanced_security: Option<AdvancedSecurity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning: Option<SecretScanning>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning_push_protection: Option<SecretScanningPushProtection>,
}

impl std::fmt::Display for SecurityAndAnalysis {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecurityAndAnalysis {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(advanced_security) = &self.advanced_security {
                format!("{:?}", advanced_security)
            } else {
                String::new()
            },
            if let Some(secret_scanning) = &self.secret_scanning {
                format!("{:?}", secret_scanning)
            } else {
                String::new()
            },
            if let Some(secret_scanning_push_protection) = &self.secret_scanning_push_protection {
                format!("{:?}", secret_scanning_push_protection)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "advanced_security".to_string(),
            "secret_scanning".to_string(),
            "secret_scanning_push_protection".to_string(),
        ]
    }
}

#[doc = "Full Repository"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FullRepository {
    pub id: i64,
    pub node_id: String,
    pub name: String,
    pub full_name: String,
    #[doc = "Simple User"]
    pub owner: SimpleUser,
    pub private: bool,
    pub html_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub fork: bool,
    pub url: url::Url,
    pub archive_url: String,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: url::Url,
    pub deployments_url: url::Url,
    pub downloads_url: url::Url,
    pub events_url: url::Url,
    pub forks_url: url::Url,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub languages_url: url::Url,
    pub merges_url: url::Url,
    pub milestones_url: String,
    pub notifications_url: String,
    pub pulls_url: String,
    pub releases_url: String,
    pub ssh_url: String,
    pub stargazers_url: url::Url,
    pub statuses_url: String,
    pub subscribers_url: url::Url,
    pub subscription_url: url::Url,
    pub tags_url: url::Url,
    pub teams_url: url::Url,
    pub trees_url: String,
    pub clone_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror_url: Option<url::Url>,
    pub hooks_url: url::Url,
    pub svn_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    pub forks_count: i64,
    pub stargazers_count: i64,
    pub watchers_count: i64,
    pub size: i64,
    pub default_branch: String,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topics: Option<Vec<String>>,
    pub has_issues: bool,
    pub has_projects: bool,
    pub has_wiki: bool,
    pub has_pages: bool,
    pub has_downloads: bool,
    pub archived: bool,
    #[doc = "Returns whether or not this repository disabled."]
    pub disabled: bool,
    #[doc = "The repository visibility: public, private, or internal."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub visibility: Option<String>,
    pub pushed_at: chrono::DateTime<chrono::Utc>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template_repository: Option<NullableRepository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    pub subscribers_count: i64,
    pub network_count: i64,
    #[doc = "License Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<NullableSimpleUser>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<Repository>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<Repository>,
    pub forks: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub open_issues: i64,
    pub watchers: i64,
    #[doc = "Whether anonymous git access is allowed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub anonymous_access_enabled: Option<bool>,
    #[doc = "Code of Conduct Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code_of_conduct: Option<CodeOfConductSimple>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_and_analysis: Option<SecurityAndAnalysis>,
}

impl std::fmt::Display for FullRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for FullRepository {
    const LENGTH: usize = 96;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.full_name.clone(),
            format!("{:?}", self.owner),
            format!("{:?}", self.private),
            format!("{:?}", self.html_url),
            format!("{:?}", self.description),
            format!("{:?}", self.fork),
            format!("{:?}", self.url),
            self.archive_url.clone(),
            self.assignees_url.clone(),
            self.blobs_url.clone(),
            self.branches_url.clone(),
            self.collaborators_url.clone(),
            self.comments_url.clone(),
            self.commits_url.clone(),
            self.compare_url.clone(),
            self.contents_url.clone(),
            format!("{:?}", self.contributors_url),
            format!("{:?}", self.deployments_url),
            format!("{:?}", self.downloads_url),
            format!("{:?}", self.events_url),
            format!("{:?}", self.forks_url),
            self.git_commits_url.clone(),
            self.git_refs_url.clone(),
            self.git_tags_url.clone(),
            self.git_url.clone(),
            self.issue_comment_url.clone(),
            self.issue_events_url.clone(),
            self.issues_url.clone(),
            self.keys_url.clone(),
            self.labels_url.clone(),
            format!("{:?}", self.languages_url),
            format!("{:?}", self.merges_url),
            self.milestones_url.clone(),
            self.notifications_url.clone(),
            self.pulls_url.clone(),
            self.releases_url.clone(),
            self.ssh_url.clone(),
            format!("{:?}", self.stargazers_url),
            self.statuses_url.clone(),
            format!("{:?}", self.subscribers_url),
            format!("{:?}", self.subscription_url),
            format!("{:?}", self.tags_url),
            format!("{:?}", self.teams_url),
            self.trees_url.clone(),
            self.clone_url.clone(),
            format!("{:?}", self.mirror_url),
            format!("{:?}", self.hooks_url),
            format!("{:?}", self.svn_url),
            format!("{:?}", self.homepage),
            format!("{:?}", self.language),
            format!("{:?}", self.forks_count),
            format!("{:?}", self.stargazers_count),
            format!("{:?}", self.watchers_count),
            format!("{:?}", self.size),
            self.default_branch.clone(),
            format!("{:?}", self.open_issues_count),
            if let Some(is_template) = &self.is_template {
                format!("{:?}", is_template)
            } else {
                String::new()
            },
            if let Some(topics) = &self.topics {
                format!("{:?}", topics)
            } else {
                String::new()
            },
            format!("{:?}", self.has_issues),
            format!("{:?}", self.has_projects),
            format!("{:?}", self.has_wiki),
            format!("{:?}", self.has_pages),
            format!("{:?}", self.has_downloads),
            format!("{:?}", self.archived),
            format!("{:?}", self.disabled),
            if let Some(visibility) = &self.visibility {
                format!("{:?}", visibility)
            } else {
                String::new()
            },
            format!("{:?}", self.pushed_at),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            if let Some(allow_rebase_merge) = &self.allow_rebase_merge {
                format!("{:?}", allow_rebase_merge)
            } else {
                String::new()
            },
            if let Some(template_repository) = &self.template_repository {
                format!("{:?}", template_repository)
            } else {
                String::new()
            },
            if let Some(temp_clone_token) = &self.temp_clone_token {
                format!("{:?}", temp_clone_token)
            } else {
                String::new()
            },
            if let Some(allow_squash_merge) = &self.allow_squash_merge {
                format!("{:?}", allow_squash_merge)
            } else {
                String::new()
            },
            if let Some(allow_auto_merge) = &self.allow_auto_merge {
                format!("{:?}", allow_auto_merge)
            } else {
                String::new()
            },
            if let Some(delete_branch_on_merge) = &self.delete_branch_on_merge {
                format!("{:?}", delete_branch_on_merge)
            } else {
                String::new()
            },
            if let Some(allow_merge_commit) = &self.allow_merge_commit {
                format!("{:?}", allow_merge_commit)
            } else {
                String::new()
            },
            if let Some(allow_update_branch) = &self.allow_update_branch {
                format!("{:?}", allow_update_branch)
            } else {
                String::new()
            },
            if let Some(use_squash_pr_title_as_default) = &self.use_squash_pr_title_as_default {
                format!("{:?}", use_squash_pr_title_as_default)
            } else {
                String::new()
            },
            if let Some(allow_forking) = &self.allow_forking {
                format!("{:?}", allow_forking)
            } else {
                String::new()
            },
            format!("{:?}", self.subscribers_count),
            format!("{:?}", self.network_count),
            format!("{:?}", self.license),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(parent) = &self.parent {
                format!("{:?}", parent)
            } else {
                String::new()
            },
            if let Some(source) = &self.source {
                format!("{:?}", source)
            } else {
                String::new()
            },
            format!("{:?}", self.forks),
            if let Some(master_branch) = &self.master_branch {
                format!("{:?}", master_branch)
            } else {
                String::new()
            },
            format!("{:?}", self.open_issues),
            format!("{:?}", self.watchers),
            if let Some(anonymous_access_enabled) = &self.anonymous_access_enabled {
                format!("{:?}", anonymous_access_enabled)
            } else {
                String::new()
            },
            if let Some(code_of_conduct) = &self.code_of_conduct {
                format!("{:?}", code_of_conduct)
            } else {
                String::new()
            },
            if let Some(security_and_analysis) = &self.security_and_analysis {
                format!("{:?}", security_and_analysis)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "full_name".to_string(),
            "owner".to_string(),
            "private".to_string(),
            "html_url".to_string(),
            "description".to_string(),
            "fork".to_string(),
            "url".to_string(),
            "archive_url".to_string(),
            "assignees_url".to_string(),
            "blobs_url".to_string(),
            "branches_url".to_string(),
            "collaborators_url".to_string(),
            "comments_url".to_string(),
            "commits_url".to_string(),
            "compare_url".to_string(),
            "contents_url".to_string(),
            "contributors_url".to_string(),
            "deployments_url".to_string(),
            "downloads_url".to_string(),
            "events_url".to_string(),
            "forks_url".to_string(),
            "git_commits_url".to_string(),
            "git_refs_url".to_string(),
            "git_tags_url".to_string(),
            "git_url".to_string(),
            "issue_comment_url".to_string(),
            "issue_events_url".to_string(),
            "issues_url".to_string(),
            "keys_url".to_string(),
            "labels_url".to_string(),
            "languages_url".to_string(),
            "merges_url".to_string(),
            "milestones_url".to_string(),
            "notifications_url".to_string(),
            "pulls_url".to_string(),
            "releases_url".to_string(),
            "ssh_url".to_string(),
            "stargazers_url".to_string(),
            "statuses_url".to_string(),
            "subscribers_url".to_string(),
            "subscription_url".to_string(),
            "tags_url".to_string(),
            "teams_url".to_string(),
            "trees_url".to_string(),
            "clone_url".to_string(),
            "mirror_url".to_string(),
            "hooks_url".to_string(),
            "svn_url".to_string(),
            "homepage".to_string(),
            "language".to_string(),
            "forks_count".to_string(),
            "stargazers_count".to_string(),
            "watchers_count".to_string(),
            "size".to_string(),
            "default_branch".to_string(),
            "open_issues_count".to_string(),
            "is_template".to_string(),
            "topics".to_string(),
            "has_issues".to_string(),
            "has_projects".to_string(),
            "has_wiki".to_string(),
            "has_pages".to_string(),
            "has_downloads".to_string(),
            "archived".to_string(),
            "disabled".to_string(),
            "visibility".to_string(),
            "pushed_at".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "permissions".to_string(),
            "allow_rebase_merge".to_string(),
            "template_repository".to_string(),
            "temp_clone_token".to_string(),
            "allow_squash_merge".to_string(),
            "allow_auto_merge".to_string(),
            "delete_branch_on_merge".to_string(),
            "allow_merge_commit".to_string(),
            "allow_update_branch".to_string(),
            "use_squash_pr_title_as_default".to_string(),
            "allow_forking".to_string(),
            "subscribers_count".to_string(),
            "network_count".to_string(),
            "license".to_string(),
            "organization".to_string(),
            "parent".to_string(),
            "source".to_string(),
            "forks".to_string(),
            "master_branch".to_string(),
            "open_issues".to_string(),
            "watchers".to_string(),
            "anonymous_access_enabled".to_string(),
            "code_of_conduct".to_string(),
            "security_and_analysis".to_string(),
        ]
    }
}

#[doc = "An artifact"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Artifact {
    pub id: i64,
    pub node_id: String,
    #[doc = "The name of the artifact."]
    pub name: String,
    #[doc = "The size in bytes of the artifact."]
    pub size_in_bytes: i64,
    pub url: String,
    pub archive_download_url: String,
    #[doc = "Whether or not the artifact has expired."]
    pub expired: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_run: Option<WorkflowRun>,
}

impl std::fmt::Display for Artifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Artifact {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            format!("{:?}", self.size_in_bytes),
            self.url.clone(),
            self.archive_download_url.clone(),
            format!("{:?}", self.expired),
            format!("{:?}", self.created_at),
            format!("{:?}", self.expires_at),
            format!("{:?}", self.updated_at),
            if let Some(workflow_run) = &self.workflow_run {
                format!("{:?}", workflow_run)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "size_in_bytes".to_string(),
            "url".to_string(),
            "archive_download_url".to_string(),
            "expired".to_string(),
            "created_at".to_string(),
            "expires_at".to_string(),
            "updated_at".to_string(),
            "workflow_run".to_string(),
        ]
    }
}

#[doc = "Repository actions caches"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsCacheList {
    #[doc = "Total number of caches"]
    pub total_count: i64,
    #[doc = "Array of caches"]
    pub actions_caches: Vec<ActionsCaches>,
}

impl std::fmt::Display for ActionsCacheList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsCacheList {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.total_count),
            format!("{:?}", self.actions_caches),
        ]
    }

    fn headers() -> Vec<String> {
        vec!["total_count".to_string(), "actions_caches".to_string()]
    }
}

#[doc = "Information of a job execution in a workflow run"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Job {
    #[doc = "The id of the job."]
    pub id: i64,
    #[doc = "The id of the associated workflow run."]
    pub run_id: i64,
    pub run_url: String,
    #[doc = "Attempt number of the associated workflow run, 1 for first attempt and higher if the workflow was re-run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub run_attempt: Option<i64>,
    pub node_id: String,
    #[doc = "The SHA of the commit that is being run."]
    pub head_sha: String,
    pub url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[doc = "The phase of the lifecycle that the job is currently in."]
    pub status: Status,
    #[doc = "The outcome of the job."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conclusion: Option<String>,
    #[doc = "The time that the job started, in ISO 8601 format."]
    pub started_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The time that the job finished, in ISO 8601 format."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The name of the job."]
    pub name: String,
    #[doc = "Steps in this job."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<Vec<Steps>>,
    pub check_run_url: String,
    #[doc = "Labels for the workflow job. Specified by the \"runs_on\" attribute in the action's workflow file."]
    pub labels: Vec<String>,
    #[doc = "The ID of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub runner_id: Option<i64>,
    #[doc = "The name of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub runner_name: Option<String>,
    #[doc = "The ID of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub runner_group_id: Option<i64>,
    #[doc = "The name of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub runner_group_name: Option<String>,
}

impl std::fmt::Display for Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Job {
    const LENGTH: usize = 20;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            format!("{:?}", self.run_id),
            self.run_url.clone(),
            if let Some(run_attempt) = &self.run_attempt {
                format!("{:?}", run_attempt)
            } else {
                String::new()
            },
            self.node_id.clone(),
            self.head_sha.clone(),
            self.url.clone(),
            format!("{:?}", self.html_url),
            format!("{:?}", self.status),
            format!("{:?}", self.conclusion),
            format!("{:?}", self.started_at),
            format!("{:?}", self.completed_at),
            self.name.clone(),
            if let Some(steps) = &self.steps {
                format!("{:?}", steps)
            } else {
                String::new()
            },
            self.check_run_url.clone(),
            format!("{:?}", self.labels),
            format!("{:?}", self.runner_id),
            format!("{:?}", self.runner_name),
            format!("{:?}", self.runner_group_id),
            format!("{:?}", self.runner_group_name),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "run_id".to_string(),
            "run_url".to_string(),
            "run_attempt".to_string(),
            "node_id".to_string(),
            "head_sha".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "status".to_string(),
            "conclusion".to_string(),
            "started_at".to_string(),
            "completed_at".to_string(),
            "name".to_string(),
            "steps".to_string(),
            "check_run_url".to_string(),
            "labels".to_string(),
            "runner_id".to_string(),
            "runner_name".to_string(),
            "runner_group_id".to_string(),
            "runner_group_name".to_string(),
        ]
    }
}

#[doc = "OIDC Customer Subject"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OptOutOidcCustomSub {
    pub use_default: bool,
}

impl std::fmt::Display for OptOutOidcCustomSub {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OptOutOidcCustomSub {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.use_default)]
    }

    fn headers() -> Vec<String> {
        vec!["use_default".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsRepositoryPermissions {
    #[doc = "Whether GitHub Actions is enabled on the repository."]
    pub enabled: bool,
    #[doc = "The permissions policy that controls the actions and reusable workflows that are allowed to run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allowed_actions: Option<AllowedActions>,
    #[doc = "The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_actions_url: Option<String>,
}

impl std::fmt::Display for ActionsRepositoryPermissions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsRepositoryPermissions {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.enabled),
            if let Some(allowed_actions) = &self.allowed_actions {
                format!("{:?}", allowed_actions)
            } else {
                String::new()
            },
            if let Some(selected_actions_url) = &self.selected_actions_url {
                format!("{:?}", selected_actions_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enabled".to_string(),
            "allowed_actions".to_string(),
            "selected_actions_url".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsWorkflowAccessToRepository {
    #[doc = "Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the\nrepository. `none` means access is only possible from workflows in this repository."]
    pub access_level: AccessLevel,
}

impl std::fmt::Display for ActionsWorkflowAccessToRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsWorkflowAccessToRepository {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.access_level)]
    }

    fn headers() -> Vec<String> {
        vec!["access_level".to_string()]
    }
}

#[doc = "A workflow referenced/reused by the initial caller workflow"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReferencedWorkflow {
    pub path: String,
    pub sha: String,
    #[serde(rename = "ref", default, skip_serializing_if = "Option::is_none")]
    pub ref_: Option<String>,
}

impl std::fmt::Display for ReferencedWorkflow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReferencedWorkflow {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.path.clone(),
            self.sha.clone(),
            if let Some(ref_) = &self.ref_ {
                format!("{:?}", ref_)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["path".to_string(), "sha".to_string(), "ref_".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestMinimal {
    pub id: i64,
    pub number: i64,
    pub url: String,
    pub head: Head,
    pub base: Base,
}

impl std::fmt::Display for PullRequestMinimal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestMinimal {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            format!("{:?}", self.number),
            self.url.clone(),
            format!("{:?}", self.head),
            format!("{:?}", self.base),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "number".to_string(),
            "url".to_string(),
            "head".to_string(),
            "base".to_string(),
        ]
    }
}

#[doc = "Simple Commit"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableSimpleCommit {
    pub id: String,
    pub tree_id: String,
    pub message: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub author: Option<Author>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub committer: Option<Committer>,
}

impl std::fmt::Display for NullableSimpleCommit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableSimpleCommit {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            self.id.clone(),
            self.tree_id.clone(),
            self.message.clone(),
            format!("{:?}", self.timestamp),
            format!("{:?}", self.author),
            format!("{:?}", self.committer),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "tree_id".to_string(),
            "message".to_string(),
            "timestamp".to_string(),
            "author".to_string(),
            "committer".to_string(),
        ]
    }
}

#[doc = "An invocation of a workflow"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WorkflowRun {
    #[doc = "The ID of the workflow run."]
    pub id: i64,
    #[doc = "The name of the workflow run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    #[doc = "The ID of the associated check suite."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub check_suite_id: Option<i64>,
    #[doc = "The node ID of the associated check suite."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub check_suite_node_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that points to the version of the workflow being run."]
    pub head_sha: String,
    #[doc = "The full path of the workflow"]
    pub path: String,
    #[doc = "The auto incrementing run number for the workflow run."]
    pub run_number: i64,
    #[doc = "Attempt number of the run, 1 for first attempt and higher if the workflow was re-run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub referenced_workflows: Option<Vec<ReferencedWorkflow>>,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conclusion: Option<String>,
    #[doc = "The ID of the parent workflow."]
    pub workflow_id: i64,
    #[doc = "The URL to the workflow run."]
    pub url: String,
    pub html_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<Vec<PullRequestMinimal>>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triggering_actor: Option<SimpleUser>,
    #[doc = "The start time of the latest run. Resets on re-run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub run_started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The URL to the jobs for the workflow run."]
    pub jobs_url: String,
    #[doc = "The URL to download the logs for the workflow run."]
    pub logs_url: String,
    #[doc = "The URL to the associated check suite."]
    pub check_suite_url: String,
    #[doc = "The URL to the artifacts for the workflow run."]
    pub artifacts_url: String,
    #[doc = "The URL to cancel the workflow run."]
    pub cancel_url: String,
    #[doc = "The URL to rerun the workflow run."]
    pub rerun_url: String,
    #[doc = "The URL to the previous attempted run of this workflow, if one exists."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_attempt_url: Option<String>,
    #[doc = "The URL to the workflow."]
    pub workflow_url: String,
    #[doc = "Simple Commit"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub head_commit: Option<NullableSimpleCommit>,
    #[doc = "Minimal Repository"]
    pub repository: MinimalRepository,
    #[doc = "Minimal Repository"]
    pub head_repository: MinimalRepository,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub head_repository_id: Option<i64>,
}

impl std::fmt::Display for WorkflowRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WorkflowRun {
    const LENGTH: usize = 35;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            self.node_id.clone(),
            if let Some(check_suite_id) = &self.check_suite_id {
                format!("{:?}", check_suite_id)
            } else {
                String::new()
            },
            if let Some(check_suite_node_id) = &self.check_suite_node_id {
                format!("{:?}", check_suite_node_id)
            } else {
                String::new()
            },
            format!("{:?}", self.head_branch),
            self.head_sha.clone(),
            self.path.clone(),
            format!("{:?}", self.run_number),
            if let Some(run_attempt) = &self.run_attempt {
                format!("{:?}", run_attempt)
            } else {
                String::new()
            },
            if let Some(referenced_workflows) = &self.referenced_workflows {
                format!("{:?}", referenced_workflows)
            } else {
                String::new()
            },
            self.event.clone(),
            format!("{:?}", self.status),
            format!("{:?}", self.conclusion),
            format!("{:?}", self.workflow_id),
            self.url.clone(),
            self.html_url.clone(),
            format!("{:?}", self.pull_requests),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(actor) = &self.actor {
                format!("{:?}", actor)
            } else {
                String::new()
            },
            if let Some(triggering_actor) = &self.triggering_actor {
                format!("{:?}", triggering_actor)
            } else {
                String::new()
            },
            if let Some(run_started_at) = &self.run_started_at {
                format!("{:?}", run_started_at)
            } else {
                String::new()
            },
            self.jobs_url.clone(),
            self.logs_url.clone(),
            self.check_suite_url.clone(),
            self.artifacts_url.clone(),
            self.cancel_url.clone(),
            self.rerun_url.clone(),
            if let Some(previous_attempt_url) = &self.previous_attempt_url {
                format!("{:?}", previous_attempt_url)
            } else {
                String::new()
            },
            self.workflow_url.clone(),
            format!("{:?}", self.head_commit),
            format!("{:?}", self.repository),
            format!("{:?}", self.head_repository),
            if let Some(head_repository_id) = &self.head_repository_id {
                format!("{:?}", head_repository_id)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "name".to_string(),
            "node_id".to_string(),
            "check_suite_id".to_string(),
            "check_suite_node_id".to_string(),
            "head_branch".to_string(),
            "head_sha".to_string(),
            "path".to_string(),
            "run_number".to_string(),
            "run_attempt".to_string(),
            "referenced_workflows".to_string(),
            "event".to_string(),
            "status".to_string(),
            "conclusion".to_string(),
            "workflow_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "pull_requests".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "actor".to_string(),
            "triggering_actor".to_string(),
            "run_started_at".to_string(),
            "jobs_url".to_string(),
            "logs_url".to_string(),
            "check_suite_url".to_string(),
            "artifacts_url".to_string(),
            "cancel_url".to_string(),
            "rerun_url".to_string(),
            "previous_attempt_url".to_string(),
            "workflow_url".to_string(),
            "head_commit".to_string(),
            "repository".to_string(),
            "head_repository".to_string(),
            "head_repository_id".to_string(),
        ]
    }
}

#[doc = "An entry in the reviews log for environment deployments"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EnvironmentApprovals {
    #[doc = "The list of environments that were approved or rejected"]
    pub environments: Vec<Environments>,
    #[doc = "Whether deployment to the environment(s) was approved or rejected"]
    pub state: State,
    #[doc = "Simple User"]
    pub user: SimpleUser,
    #[doc = "The comment submitted with the deployment review"]
    pub comment: String,
}

impl std::fmt::Display for EnvironmentApprovals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for EnvironmentApprovals {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.environments),
            format!("{:?}", self.state),
            format!("{:?}", self.user),
            self.comment.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "environments".to_string(),
            "state".to_string(),
            "user".to_string(),
            "comment".to_string(),
        ]
    }
}

#[doc = "The type of reviewer."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum DeploymentReviewerType {
    User,
    Team,
}

#[doc = "Details of a deployment that is waiting for protection rules to pass"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PendingDeployment {
    pub environment: Environment,
    #[doc = "The set duration of the wait timer"]
    pub wait_timer: i64,
    #[doc = "The time that the wait timer began."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wait_timer_started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Whether the currently authenticated user can approve the deployment"]
    pub current_user_can_approve: bool,
    #[doc = "The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed."]
    pub reviewers: Vec<Reviewers>,
}

impl std::fmt::Display for PendingDeployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PendingDeployment {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.environment),
            format!("{:?}", self.wait_timer),
            format!("{:?}", self.wait_timer_started_at),
            format!("{:?}", self.current_user_can_approve),
            format!("{:?}", self.reviewers),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "environment".to_string(),
            "wait_timer".to_string(),
            "wait_timer_started_at".to_string(),
            "current_user_can_approve".to_string(),
            "reviewers".to_string(),
        ]
    }
}

#[doc = "A request for a specific ref(branch,sha,tag) to be deployed"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Deployment {
    pub url: url::Url,
    #[doc = "Unique identifier of the deployment"]
    pub id: i64,
    pub node_id: String,
    pub sha: String,
    #[doc = "The ref to deploy. This can be a branch, tag, or sha."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "Parameter to specify a task to execute"]
    pub task: String,
    pub payload: Payload,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub original_environment: Option<String>,
    #[doc = "Name for the target deployment environment."]
    pub environment: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub statuses_url: url::Url,
    pub repository_url: url::Url,
    #[doc = "Specifies if the given environment is will no longer exist at some point in the future. Default: false."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transient_environment: Option<bool>,
    #[doc = "Specifies if the given environment is one that end-users directly interact with. Default: false."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub production_environment: Option<bool>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
}

impl std::fmt::Display for Deployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Deployment {
    const LENGTH: usize = 18;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.sha.clone(),
            self.ref_.clone(),
            self.task.clone(),
            format!("{:?}", self.payload),
            if let Some(original_environment) = &self.original_environment {
                format!("{:?}", original_environment)
            } else {
                String::new()
            },
            self.environment.clone(),
            format!("{:?}", self.description),
            format!("{:?}", self.creator),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.statuses_url),
            format!("{:?}", self.repository_url),
            if let Some(transient_environment) = &self.transient_environment {
                format!("{:?}", transient_environment)
            } else {
                String::new()
            },
            if let Some(production_environment) = &self.production_environment {
                format!("{:?}", production_environment)
            } else {
                String::new()
            },
            if let Some(performed_via_github_app) = &self.performed_via_github_app {
                format!("{:?}", performed_via_github_app)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "sha".to_string(),
            "ref_".to_string(),
            "task".to_string(),
            "payload".to_string(),
            "original_environment".to_string(),
            "environment".to_string(),
            "description".to_string(),
            "creator".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "statuses_url".to_string(),
            "repository_url".to_string(),
            "transient_environment".to_string(),
            "production_environment".to_string(),
            "performed_via_github_app".to_string(),
        ]
    }
}

#[doc = "Workflow Run Usage"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WorkflowRunUsage {
    pub billable: Billable,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub run_duration_ms: Option<i64>,
}

impl std::fmt::Display for WorkflowRunUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WorkflowRunUsage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.billable),
            if let Some(run_duration_ms) = &self.run_duration_ms {
                format!("{:?}", run_duration_ms)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["billable".to_string(), "run_duration_ms".to_string()]
    }
}

#[doc = "Set secrets for GitHub Actions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsSecret {
    #[doc = "The name of the secret."]
    pub name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for ActionsSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsSecret {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
        ]
    }
}

#[doc = "A GitHub Actions workflow"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Workflow {
    pub id: i64,
    pub node_id: String,
    pub name: String,
    pub path: String,
    pub state: State,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub url: String,
    pub html_url: String,
    pub badge_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deleted_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for Workflow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Workflow {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.path.clone(),
            format!("{:?}", self.state),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            self.url.clone(),
            self.html_url.clone(),
            self.badge_url.clone(),
            if let Some(deleted_at) = &self.deleted_at {
                format!("{:?}", deleted_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "path".to_string(),
            "state".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "badge_url".to_string(),
            "deleted_at".to_string(),
        ]
    }
}

#[doc = "Workflow Usage"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WorkflowUsage {
    pub billable: Billable,
}

impl std::fmt::Display for WorkflowUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WorkflowUsage {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.billable)]
    }

    fn headers() -> Vec<String> {
        vec!["billable".to_string()]
    }
}

#[doc = "An autolink reference."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Autolink {
    pub id: i64,
    #[doc = "The prefix of a key that is linkified."]
    pub key_prefix: String,
    #[doc = "A template for the target URL that is generated if a key was found."]
    pub url_template: String,
    #[doc = "Whether this autolink reference matches alphanumeric characters. If false, this autolink reference is a legacy autolink that only matches numeric characters."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_alphanumeric: Option<bool>,
}

impl std::fmt::Display for Autolink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Autolink {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.key_prefix.clone(),
            self.url_template.clone(),
            if let Some(is_alphanumeric) = &self.is_alphanumeric {
                format!("{:?}", is_alphanumeric)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "key_prefix".to_string(),
            "url_template".to_string(),
            "is_alphanumeric".to_string(),
        ]
    }
}

#[doc = "Protected Branch Required Status Check"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProtectedBranchRequiredStatusCheck {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enforcement_level: Option<String>,
    pub contexts: Vec<String>,
    pub checks: Vec<Checks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contexts_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
}

impl std::fmt::Display for ProtectedBranchRequiredStatusCheck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProtectedBranchRequiredStatusCheck {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(enforcement_level) = &self.enforcement_level {
                format!("{:?}", enforcement_level)
            } else {
                String::new()
            },
            format!("{:?}", self.contexts),
            format!("{:?}", self.checks),
            if let Some(contexts_url) = &self.contexts_url {
                format!("{:?}", contexts_url)
            } else {
                String::new()
            },
            if let Some(strict) = &self.strict {
                format!("{:?}", strict)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "enforcement_level".to_string(),
            "contexts".to_string(),
            "checks".to_string(),
            "contexts_url".to_string(),
            "strict".to_string(),
        ]
    }
}

#[doc = "Protected Branch Admin Enforced"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProtectedBranchAdminEnforced {
    pub url: url::Url,
    pub enabled: bool,
}

impl std::fmt::Display for ProtectedBranchAdminEnforced {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProtectedBranchAdminEnforced {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.url), format!("{:?}", self.enabled)]
    }

    fn headers() -> Vec<String> {
        vec!["url".to_string(), "enabled".to_string()]
    }
}

#[doc = "Protected Branch Pull Request Review"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProtectedBranchPullRequestReview {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissal_restrictions: Option<DismissalRestrictions>,
    #[doc = "Allow specific users, teams, or apps to bypass pull request requirements."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bypass_pull_request_allowances: Option<BypassPullRequestAllowances>,
    pub dismiss_stale_reviews: bool,
    pub require_code_owner_reviews: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_approving_review_count: Option<i64>,
}

impl std::fmt::Display for ProtectedBranchPullRequestReview {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProtectedBranchPullRequestReview {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(dismissal_restrictions) = &self.dismissal_restrictions {
                format!("{:?}", dismissal_restrictions)
            } else {
                String::new()
            },
            if let Some(bypass_pull_request_allowances) = &self.bypass_pull_request_allowances {
                format!("{:?}", bypass_pull_request_allowances)
            } else {
                String::new()
            },
            format!("{:?}", self.dismiss_stale_reviews),
            format!("{:?}", self.require_code_owner_reviews),
            if let Some(required_approving_review_count) = &self.required_approving_review_count {
                format!("{:?}", required_approving_review_count)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "dismissal_restrictions".to_string(),
            "bypass_pull_request_allowances".to_string(),
            "dismiss_stale_reviews".to_string(),
            "require_code_owner_reviews".to_string(),
            "required_approving_review_count".to_string(),
        ]
    }
}

#[doc = "Branch Restriction Policy"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BranchRestrictionPolicy {
    pub url: url::Url,
    pub users_url: url::Url,
    pub teams_url: url::Url,
    pub apps_url: url::Url,
    pub users: Vec<Users>,
    pub teams: Vec<Teams>,
    pub apps: Vec<Apps>,
}

impl std::fmt::Display for BranchRestrictionPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for BranchRestrictionPolicy {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.users_url),
            format!("{:?}", self.teams_url),
            format!("{:?}", self.apps_url),
            format!("{:?}", self.users),
            format!("{:?}", self.teams),
            format!("{:?}", self.apps),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "users_url".to_string(),
            "teams_url".to_string(),
            "apps_url".to_string(),
            "users".to_string(),
            "teams".to_string(),
            "apps".to_string(),
        ]
    }
}

#[doc = "Branch Protection"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BranchProtection {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[doc = "Protected Branch Required Status Check"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_status_checks: Option<ProtectedBranchRequiredStatusCheck>,
    #[doc = "Protected Branch Admin Enforced"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enforce_admins: Option<ProtectedBranchAdminEnforced>,
    #[doc = "Protected Branch Pull Request Review"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_pull_request_reviews: Option<ProtectedBranchPullRequestReview>,
    #[doc = "Branch Restriction Policy"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restrictions: Option<BranchRestrictionPolicy>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_linear_history: Option<RequiredLinearHistory>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_force_pushes: Option<AllowForcePushes>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_deletions: Option<AllowDeletions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block_creations: Option<BlockCreations>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_conversation_resolution: Option<RequiredConversationResolution>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protection_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_signatures: Option<RequiredSignatures>,
}

impl std::fmt::Display for BranchProtection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for BranchProtection {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(enabled) = &self.enabled {
                format!("{:?}", enabled)
            } else {
                String::new()
            },
            if let Some(required_status_checks) = &self.required_status_checks {
                format!("{:?}", required_status_checks)
            } else {
                String::new()
            },
            if let Some(enforce_admins) = &self.enforce_admins {
                format!("{:?}", enforce_admins)
            } else {
                String::new()
            },
            if let Some(required_pull_request_reviews) = &self.required_pull_request_reviews {
                format!("{:?}", required_pull_request_reviews)
            } else {
                String::new()
            },
            if let Some(restrictions) = &self.restrictions {
                format!("{:?}", restrictions)
            } else {
                String::new()
            },
            if let Some(required_linear_history) = &self.required_linear_history {
                format!("{:?}", required_linear_history)
            } else {
                String::new()
            },
            if let Some(allow_force_pushes) = &self.allow_force_pushes {
                format!("{:?}", allow_force_pushes)
            } else {
                String::new()
            },
            if let Some(allow_deletions) = &self.allow_deletions {
                format!("{:?}", allow_deletions)
            } else {
                String::new()
            },
            if let Some(block_creations) = &self.block_creations {
                format!("{:?}", block_creations)
            } else {
                String::new()
            },
            if let Some(required_conversation_resolution) = &self.required_conversation_resolution {
                format!("{:?}", required_conversation_resolution)
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(protection_url) = &self.protection_url {
                format!("{:?}", protection_url)
            } else {
                String::new()
            },
            if let Some(required_signatures) = &self.required_signatures {
                format!("{:?}", required_signatures)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "enabled".to_string(),
            "required_status_checks".to_string(),
            "enforce_admins".to_string(),
            "required_pull_request_reviews".to_string(),
            "restrictions".to_string(),
            "required_linear_history".to_string(),
            "allow_force_pushes".to_string(),
            "allow_deletions".to_string(),
            "block_creations".to_string(),
            "required_conversation_resolution".to_string(),
            "name".to_string(),
            "protection_url".to_string(),
            "required_signatures".to_string(),
        ]
    }
}

#[doc = "Short Branch"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ShortBranch {
    pub name: String,
    pub commit: Commit,
    pub protected: bool,
    #[doc = "Branch Protection"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protection: Option<BranchProtection>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protection_url: Option<url::Url>,
}

impl std::fmt::Display for ShortBranch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ShortBranch {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.commit),
            format!("{:?}", self.protected),
            if let Some(protection) = &self.protection {
                format!("{:?}", protection)
            } else {
                String::new()
            },
            if let Some(protection_url) = &self.protection_url {
                format!("{:?}", protection_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "commit".to_string(),
            "protected".to_string(),
            "protection".to_string(),
            "protection_url".to_string(),
        ]
    }
}

#[doc = "Metaproperties for Git author/committer information."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableGitUser {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub date: Option<String>,
}

impl std::fmt::Display for NullableGitUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableGitUser {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email)
            } else {
                String::new()
            },
            if let Some(date) = &self.date {
                format!("{:?}", date)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["name".to_string(), "email".to_string(), "date".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Verification {
    pub verified: bool,
    pub reason: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub payload: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signature: Option<String>,
}

impl std::fmt::Display for Verification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Verification {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.verified),
            self.reason.clone(),
            format!("{:?}", self.payload),
            format!("{:?}", self.signature),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "verified".to_string(),
            "reason".to_string(),
            "payload".to_string(),
            "signature".to_string(),
        ]
    }
}

#[doc = "Diff Entry"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiffEntry {
    pub sha: String,
    pub filename: String,
    pub status: Status,
    pub additions: i64,
    pub deletions: i64,
    pub changes: i64,
    pub blob_url: url::Url,
    pub raw_url: url::Url,
    pub contents_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_filename: Option<String>,
}

impl std::fmt::Display for DiffEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiffEntry {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            self.sha.clone(),
            self.filename.clone(),
            format!("{:?}", self.status),
            format!("{:?}", self.additions),
            format!("{:?}", self.deletions),
            format!("{:?}", self.changes),
            format!("{:?}", self.blob_url),
            format!("{:?}", self.raw_url),
            format!("{:?}", self.contents_url),
            if let Some(patch) = &self.patch {
                format!("{:?}", patch)
            } else {
                String::new()
            },
            if let Some(previous_filename) = &self.previous_filename {
                format!("{:?}", previous_filename)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sha".to_string(),
            "filename".to_string(),
            "status".to_string(),
            "additions".to_string(),
            "deletions".to_string(),
            "changes".to_string(),
            "blob_url".to_string(),
            "raw_url".to_string(),
            "contents_url".to_string(),
            "patch".to_string(),
            "previous_filename".to_string(),
        ]
    }
}

#[doc = "Commit"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Commit {
    pub url: url::Url,
    pub sha: String,
    pub node_id: String,
    pub html_url: url::Url,
    pub comments_url: url::Url,
    pub commit: Commit,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub author: Option<NullableSimpleUser>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub committer: Option<NullableSimpleUser>,
    pub parents: Vec<Parents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stats: Option<Stats>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<DiffEntry>>,
}

impl std::fmt::Display for Commit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Commit {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            self.sha.clone(),
            self.node_id.clone(),
            format!("{:?}", self.html_url),
            format!("{:?}", self.comments_url),
            format!("{:?}", self.commit),
            format!("{:?}", self.author),
            format!("{:?}", self.committer),
            format!("{:?}", self.parents),
            if let Some(stats) = &self.stats {
                format!("{:?}", stats)
            } else {
                String::new()
            },
            if let Some(files) = &self.files {
                format!("{:?}", files)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "sha".to_string(),
            "node_id".to_string(),
            "html_url".to_string(),
            "comments_url".to_string(),
            "commit".to_string(),
            "author".to_string(),
            "committer".to_string(),
            "parents".to_string(),
            "stats".to_string(),
            "files".to_string(),
        ]
    }
}

#[doc = "Branch With Protection"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BranchWithProtection {
    pub name: String,
    #[doc = "Commit"]
    pub commit: Commit,
    #[serde(rename = "_links")]
    pub links: Links,
    pub protected: bool,
    #[doc = "Branch Protection"]
    pub protection: BranchProtection,
    pub protection_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_approving_review_count: Option<i64>,
}

impl std::fmt::Display for BranchWithProtection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for BranchWithProtection {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.commit),
            format!("{:?}", self.links),
            format!("{:?}", self.protected),
            format!("{:?}", self.protection),
            format!("{:?}", self.protection_url),
            if let Some(pattern) = &self.pattern {
                format!("{:?}", pattern)
            } else {
                String::new()
            },
            if let Some(required_approving_review_count) = &self.required_approving_review_count {
                format!("{:?}", required_approving_review_count)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "commit".to_string(),
            "links".to_string(),
            "protected".to_string(),
            "protection".to_string(),
            "protection_url".to_string(),
            "pattern".to_string(),
            "required_approving_review_count".to_string(),
        ]
    }
}

#[doc = "Status Check Policy"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct StatusCheckPolicy {
    pub url: url::Url,
    pub strict: bool,
    pub contexts: Vec<String>,
    pub checks: Vec<Checks>,
    pub contexts_url: url::Url,
}

impl std::fmt::Display for StatusCheckPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for StatusCheckPolicy {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.strict),
            format!("{:?}", self.contexts),
            format!("{:?}", self.checks),
            format!("{:?}", self.contexts_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "strict".to_string(),
            "contexts".to_string(),
            "checks".to_string(),
            "contexts_url".to_string(),
        ]
    }
}

#[doc = "Branch protections protect branches"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProtectedBranch {
    pub url: url::Url,
    #[doc = "Status Check Policy"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_status_checks: Option<StatusCheckPolicy>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_pull_request_reviews: Option<RequiredPullRequestReviews>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_signatures: Option<RequiredSignatures>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enforce_admins: Option<EnforceAdmins>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_linear_history: Option<RequiredLinearHistory>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_force_pushes: Option<AllowForcePushes>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_deletions: Option<AllowDeletions>,
    #[doc = "Branch Restriction Policy"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restrictions: Option<BranchRestrictionPolicy>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required_conversation_resolution: Option<RequiredConversationResolution>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block_creations: Option<BlockCreations>,
}

impl std::fmt::Display for ProtectedBranch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProtectedBranch {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            if let Some(required_status_checks) = &self.required_status_checks {
                format!("{:?}", required_status_checks)
            } else {
                String::new()
            },
            if let Some(required_pull_request_reviews) = &self.required_pull_request_reviews {
                format!("{:?}", required_pull_request_reviews)
            } else {
                String::new()
            },
            if let Some(required_signatures) = &self.required_signatures {
                format!("{:?}", required_signatures)
            } else {
                String::new()
            },
            if let Some(enforce_admins) = &self.enforce_admins {
                format!("{:?}", enforce_admins)
            } else {
                String::new()
            },
            if let Some(required_linear_history) = &self.required_linear_history {
                format!("{:?}", required_linear_history)
            } else {
                String::new()
            },
            if let Some(allow_force_pushes) = &self.allow_force_pushes {
                format!("{:?}", allow_force_pushes)
            } else {
                String::new()
            },
            if let Some(allow_deletions) = &self.allow_deletions {
                format!("{:?}", allow_deletions)
            } else {
                String::new()
            },
            if let Some(restrictions) = &self.restrictions {
                format!("{:?}", restrictions)
            } else {
                String::new()
            },
            if let Some(required_conversation_resolution) = &self.required_conversation_resolution {
                format!("{:?}", required_conversation_resolution)
            } else {
                String::new()
            },
            if let Some(block_creations) = &self.block_creations {
                format!("{:?}", block_creations)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "required_status_checks".to_string(),
            "required_pull_request_reviews".to_string(),
            "required_signatures".to_string(),
            "enforce_admins".to_string(),
            "required_linear_history".to_string(),
            "allow_force_pushes".to_string(),
            "allow_deletions".to_string(),
            "restrictions".to_string(),
            "required_conversation_resolution".to_string(),
            "block_creations".to_string(),
        ]
    }
}

#[doc = "A deployment created as the result of an Actions check run from a workflow that references an environment"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeploymentSimple {
    pub url: url::Url,
    #[doc = "Unique identifier of the deployment"]
    pub id: i64,
    pub node_id: String,
    #[doc = "Parameter to specify a task to execute"]
    pub task: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub original_environment: Option<String>,
    #[doc = "Name for the target deployment environment."]
    pub environment: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub statuses_url: url::Url,
    pub repository_url: url::Url,
    #[doc = "Specifies if the given environment is will no longer exist at some point in the future. Default: false."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transient_environment: Option<bool>,
    #[doc = "Specifies if the given environment is one that end-users directly interact with. Default: false."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub production_environment: Option<bool>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
}

impl std::fmt::Display for DeploymentSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeploymentSimple {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.task.clone(),
            if let Some(original_environment) = &self.original_environment {
                format!("{:?}", original_environment)
            } else {
                String::new()
            },
            self.environment.clone(),
            format!("{:?}", self.description),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.statuses_url),
            format!("{:?}", self.repository_url),
            if let Some(transient_environment) = &self.transient_environment {
                format!("{:?}", transient_environment)
            } else {
                String::new()
            },
            if let Some(production_environment) = &self.production_environment {
                format!("{:?}", production_environment)
            } else {
                String::new()
            },
            if let Some(performed_via_github_app) = &self.performed_via_github_app {
                format!("{:?}", performed_via_github_app)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "task".to_string(),
            "original_environment".to_string(),
            "environment".to_string(),
            "description".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "statuses_url".to_string(),
            "repository_url".to_string(),
            "transient_environment".to_string(),
            "production_environment".to_string(),
            "performed_via_github_app".to_string(),
        ]
    }
}

#[doc = "A check performed on the code of a given code change"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckRun {
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub external_id: Option<String>,
    pub url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    #[doc = "The phase of the lifecycle that the check is currently in."]
    pub status: Status,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conclusion: Option<Conclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    pub output: Output,
    #[doc = "The name of the check."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub check_suite: Option<CheckSuite>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app: Option<NullableIntegration>,
    pub pull_requests: Vec<PullRequestMinimal>,
    #[doc = "A deployment created as the result of an Actions check run from a workflow that references an environment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<DeploymentSimple>,
}

impl std::fmt::Display for CheckRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckRun {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.head_sha.clone(),
            self.node_id.clone(),
            format!("{:?}", self.external_id),
            self.url.clone(),
            format!("{:?}", self.html_url),
            format!("{:?}", self.details_url),
            format!("{:?}", self.status),
            format!("{:?}", self.conclusion),
            format!("{:?}", self.started_at),
            format!("{:?}", self.completed_at),
            format!("{:?}", self.output),
            self.name.clone(),
            format!("{:?}", self.check_suite),
            format!("{:?}", self.app),
            format!("{:?}", self.pull_requests),
            if let Some(deployment) = &self.deployment {
                format!("{:?}", deployment)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "head_sha".to_string(),
            "node_id".to_string(),
            "external_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "details_url".to_string(),
            "status".to_string(),
            "conclusion".to_string(),
            "started_at".to_string(),
            "completed_at".to_string(),
            "output".to_string(),
            "name".to_string(),
            "check_suite".to_string(),
            "app".to_string(),
            "pull_requests".to_string(),
            "deployment".to_string(),
        ]
    }
}

#[doc = "Check Annotation"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckAnnotation {
    pub path: String,
    pub start_line: i64,
    pub end_line: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotation_level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub raw_details: Option<String>,
    pub blob_href: String,
}

impl std::fmt::Display for CheckAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckAnnotation {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            self.path.clone(),
            format!("{:?}", self.start_line),
            format!("{:?}", self.end_line),
            format!("{:?}", self.start_column),
            format!("{:?}", self.end_column),
            format!("{:?}", self.annotation_level),
            format!("{:?}", self.title),
            format!("{:?}", self.message),
            format!("{:?}", self.raw_details),
            self.blob_href.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "path".to_string(),
            "start_line".to_string(),
            "end_line".to_string(),
            "start_column".to_string(),
            "end_column".to_string(),
            "annotation_level".to_string(),
            "title".to_string(),
            "message".to_string(),
            "raw_details".to_string(),
            "blob_href".to_string(),
        ]
    }
}

#[doc = "Simple Commit"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SimpleCommit {
    pub id: String,
    pub tree_id: String,
    pub message: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub author: Option<Author>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub committer: Option<Committer>,
}

impl std::fmt::Display for SimpleCommit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SimpleCommit {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            self.id.clone(),
            self.tree_id.clone(),
            self.message.clone(),
            format!("{:?}", self.timestamp),
            format!("{:?}", self.author),
            format!("{:?}", self.committer),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "tree_id".to_string(),
            "message".to_string(),
            "timestamp".to_string(),
            "author".to_string(),
            "committer".to_string(),
        ]
    }
}

#[doc = "A suite of checks performed on the code of a given code change"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckSuite {
    pub id: i64,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<Status>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conclusion: Option<Conclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub before: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub after: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<Vec<PullRequestMinimal>>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app: Option<NullableIntegration>,
    #[doc = "Minimal Repository"]
    pub repository: MinimalRepository,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Simple Commit"]
    pub head_commit: SimpleCommit,
    pub latest_check_runs_count: i64,
    pub check_runs_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rerequestable: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub runs_rerequestable: Option<bool>,
}

impl std::fmt::Display for CheckSuite {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckSuite {
    const LENGTH: usize = 19;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.head_branch),
            self.head_sha.clone(),
            format!("{:?}", self.status),
            format!("{:?}", self.conclusion),
            format!("{:?}", self.url),
            format!("{:?}", self.before),
            format!("{:?}", self.after),
            format!("{:?}", self.pull_requests),
            format!("{:?}", self.app),
            format!("{:?}", self.repository),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.head_commit),
            format!("{:?}", self.latest_check_runs_count),
            self.check_runs_url.clone(),
            if let Some(rerequestable) = &self.rerequestable {
                format!("{:?}", rerequestable)
            } else {
                String::new()
            },
            if let Some(runs_rerequestable) = &self.runs_rerequestable {
                format!("{:?}", runs_rerequestable)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "head_branch".to_string(),
            "head_sha".to_string(),
            "status".to_string(),
            "conclusion".to_string(),
            "url".to_string(),
            "before".to_string(),
            "after".to_string(),
            "pull_requests".to_string(),
            "app".to_string(),
            "repository".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "head_commit".to_string(),
            "latest_check_runs_count".to_string(),
            "check_runs_url".to_string(),
            "rerequestable".to_string(),
            "runs_rerequestable".to_string(),
        ]
    }
}

#[doc = "Check suite configuration preferences for a repository."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckSuitePreference {
    pub preferences: Preferences,
    #[doc = "Minimal Repository"]
    pub repository: MinimalRepository,
}

impl std::fmt::Display for CheckSuitePreference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckSuitePreference {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.preferences),
            format!("{:?}", self.repository),
        ]
    }

    fn headers() -> Vec<String> {
        vec!["preferences".to_string(), "repository".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertRuleSummary {
    #[doc = "A unique identifier for the rule used to detect the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The name of the rule used to detect the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "A set of tags applicable for the rule."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    #[doc = "The severity of the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<Severity>,
    #[doc = "A short description of the rule used to detect the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

impl std::fmt::Display for CodeScanningAlertRuleSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertRuleSummary {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(tags) = &self.tags {
                format!("{:?}", tags)
            } else {
                String::new()
            },
            if let Some(severity) = &self.severity {
                format!("{:?}", severity)
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{:?}", description)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "name".to_string(),
            "tags".to_string(),
            "severity".to_string(),
            "description".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertItems {
    #[doc = "The security alert number."]
    pub number: i64,
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The REST API URL of the alert resource."]
    pub url: url::Url,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: url::Url,
    #[doc = "The REST API URL for fetching the list of instances for an alert."]
    pub instances_url: url::Url,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertState,
    #[doc = "The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fixed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_by: Option<NullableSimpleUser>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "**Required when the state is dismissed.** The reason for dismissing or closing the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
    #[doc = "The dismissal comment associated with the dismissal of the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_comment: Option<String>,
    pub rule: CodeScanningAlertRuleSummary,
    pub tool: CodeScanningAnalysisTool,
    pub most_recent_instance: CodeScanningAlertInstance,
}

impl std::fmt::Display for CodeScanningAlertItems {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertItems {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.number),
            format!("{:?}", self.created_at),
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.instances_url),
            format!("{:?}", self.state),
            if let Some(fixed_at) = &self.fixed_at {
                format!("{:?}", fixed_at)
            } else {
                String::new()
            },
            format!("{:?}", self.dismissed_by),
            format!("{:?}", self.dismissed_at),
            format!("{:?}", self.dismissed_reason),
            if let Some(dismissed_comment) = &self.dismissed_comment {
                format!("{:?}", dismissed_comment)
            } else {
                String::new()
            },
            format!("{:?}", self.rule),
            format!("{:?}", self.tool),
            format!("{:?}", self.most_recent_instance),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "number".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "instances_url".to_string(),
            "state".to_string(),
            "fixed_at".to_string(),
            "dismissed_by".to_string(),
            "dismissed_at".to_string(),
            "dismissed_reason".to_string(),
            "dismissed_comment".to_string(),
            "rule".to_string(),
            "tool".to_string(),
            "most_recent_instance".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlert {
    #[doc = "The security alert number."]
    pub number: i64,
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The REST API URL of the alert resource."]
    pub url: url::Url,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: url::Url,
    #[doc = "The REST API URL for fetching the list of instances for an alert."]
    pub instances_url: url::Url,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertState,
    #[doc = "The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fixed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_by: Option<NullableSimpleUser>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "**Required when the state is dismissed.** The reason for dismissing or closing the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
    #[doc = "The dismissal comment associated with the dismissal of the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_comment: Option<String>,
    pub rule: CodeScanningAlertRule,
    pub tool: CodeScanningAnalysisTool,
    pub most_recent_instance: CodeScanningAlertInstance,
}

impl std::fmt::Display for CodeScanningAlert {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlert {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.number),
            format!("{:?}", self.created_at),
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.instances_url),
            format!("{:?}", self.state),
            if let Some(fixed_at) = &self.fixed_at {
                format!("{:?}", fixed_at)
            } else {
                String::new()
            },
            format!("{:?}", self.dismissed_by),
            format!("{:?}", self.dismissed_at),
            format!("{:?}", self.dismissed_reason),
            if let Some(dismissed_comment) = &self.dismissed_comment {
                format!("{:?}", dismissed_comment)
            } else {
                String::new()
            },
            format!("{:?}", self.rule),
            format!("{:?}", self.tool),
            format!("{:?}", self.most_recent_instance),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "number".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "instances_url".to_string(),
            "state".to_string(),
            "fixed_at".to_string(),
            "dismissed_by".to_string(),
            "dismissed_at".to_string(),
            "dismissed_reason".to_string(),
            "dismissed_comment".to_string(),
            "rule".to_string(),
            "tool".to_string(),
            "most_recent_instance".to_string(),
        ]
    }
}

#[doc = "Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CodeScanningAlertSetState {
    #[serde(rename = "open")]
    #[display("open")]
    Open,
    #[serde(rename = "dismissed")]
    #[display("dismissed")]
    Dismissed,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAnalysis {
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "The SHA of the commit to which the analysis you are uploading relates."]
    pub commit_sha: String,
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: String,
    #[doc = "Identifies the variable values associated with the environment in which this analysis was performed."]
    pub environment: String,
    #[doc = "Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<String>,
    pub error: String,
    #[doc = "The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The total number of results in the analysis."]
    pub results_count: i64,
    #[doc = "The total number of rules used in the analysis."]
    pub rules_count: i64,
    #[doc = "Unique identifier for this analysis."]
    pub id: i64,
    #[doc = "The REST API URL of the analysis resource."]
    pub url: url::Url,
    #[doc = "An identifier for the upload."]
    pub sarif_id: String,
    pub tool: CodeScanningAnalysisTool,
    pub deletable: bool,
    #[doc = "Warning generated when processing the analysis"]
    pub warning: String,
}

impl std::fmt::Display for CodeScanningAnalysis {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAnalysis {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            self.ref_.clone(),
            self.commit_sha.clone(),
            self.analysis_key.clone(),
            self.environment.clone(),
            if let Some(category) = &self.category {
                format!("{:?}", category)
            } else {
                String::new()
            },
            self.error.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.results_count),
            format!("{:?}", self.rules_count),
            format!("{:?}", self.id),
            format!("{:?}", self.url),
            self.sarif_id.clone(),
            format!("{:?}", self.tool),
            format!("{:?}", self.deletable),
            self.warning.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "ref_".to_string(),
            "commit_sha".to_string(),
            "analysis_key".to_string(),
            "environment".to_string(),
            "category".to_string(),
            "error".to_string(),
            "created_at".to_string(),
            "results_count".to_string(),
            "rules_count".to_string(),
            "id".to_string(),
            "url".to_string(),
            "sarif_id".to_string(),
            "tool".to_string(),
            "deletable".to_string(),
            "warning".to_string(),
        ]
    }
}

#[doc = "Successful deletion of a code scanning analysis"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAnalysisDeletion {
    #[doc = "Next deletable analysis in chain, without last analysis deletion confirmation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_analysis_url: Option<url::Url>,
    #[doc = "Next deletable analysis in chain, with last analysis deletion confirmation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub confirm_delete_url: Option<url::Url>,
}

impl std::fmt::Display for CodeScanningAnalysisDeletion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAnalysisDeletion {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.next_analysis_url),
            format!("{:?}", self.confirm_delete_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "next_analysis_url".to_string(),
            "confirm_delete_url".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningSarifsReceipt {
    #[doc = "An identifier for the upload."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The REST API URL for checking the status of the upload."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<url::Url>,
}

impl std::fmt::Display for CodeScanningSarifsReceipt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningSarifsReceipt {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["id".to_string(), "url".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningSarifsStatus {
    #[doc = "`pending` files have not yet been processed, while `complete` means results from the SARIF have been stored. `failed` files have either not been processed at all, or could only be partially processed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub processing_status: Option<ProcessingStatus>,
    #[doc = "The REST API URL for getting the analyses associated with the upload."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub analyses_url: Option<url::Url>,
    #[doc = "Any errors that ocurred during processing of the delivery."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<String>>,
}

impl std::fmt::Display for CodeScanningSarifsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningSarifsStatus {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(processing_status) = &self.processing_status {
                format!("{:?}", processing_status)
            } else {
                String::new()
            },
            if let Some(analyses_url) = &self.analyses_url {
                format!("{:?}", analyses_url)
            } else {
                String::new()
            },
            if let Some(errors) = &self.errors {
                format!("{:?}", errors)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "processing_status".to_string(),
            "analyses_url".to_string(),
            "errors".to_string(),
        ]
    }
}

#[doc = "A list of errors found in a repo's CODEOWNERS file"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeownersErrors {
    pub errors: Vec<Errors>,
}

impl std::fmt::Display for CodeownersErrors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeownersErrors {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.errors)]
    }

    fn headers() -> Vec<String> {
        vec!["errors".to_string()]
    }
}

#[doc = "A description of the machine powering a codespace."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodespaceMachine {
    #[doc = "The name of the machine."]
    pub name: String,
    #[doc = "The display name of the machine includes cores, memory, and storage."]
    pub display_name: String,
    #[doc = "The operating system of the machine."]
    pub operating_system: String,
    #[doc = "How much storage is available to the codespace."]
    pub storage_in_bytes: i64,
    #[doc = "How much memory is available to the codespace."]
    pub memory_in_bytes: i64,
    #[doc = "How many cores are available to the codespace."]
    pub cpus: i64,
    #[doc = "Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be \"null\" if prebuilds are not supported or prebuild availability could not be determined. Value will be \"none\" if no prebuild is available. Latest values \"ready\" and \"in_progress\" indicate the prebuild availability status."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prebuild_availability: Option<PrebuildAvailability>,
}

impl std::fmt::Display for CodespaceMachine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodespaceMachine {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            self.display_name.clone(),
            self.operating_system.clone(),
            format!("{:?}", self.storage_in_bytes),
            format!("{:?}", self.memory_in_bytes),
            format!("{:?}", self.cpus),
            format!("{:?}", self.prebuild_availability),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "display_name".to_string(),
            "operating_system".to_string(),
            "storage_in_bytes".to_string(),
            "memory_in_bytes".to_string(),
            "cpus".to_string(),
            "prebuild_availability".to_string(),
        ]
    }
}

#[doc = "Set repository secrets for GitHub Codespaces."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepoCodespacesSecret {
    #[doc = "The name of the secret."]
    pub name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for RepoCodespacesSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepoCodespacesSecret {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
        ]
    }
}

#[doc = "The public key used for setting Codespaces secrets."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodespacesPublicKey {
    #[doc = "The identifier for the key."]
    pub key_id: String,
    #[doc = "The Base64 encoded public key."]
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
}

impl std::fmt::Display for CodespacesPublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodespacesPublicKey {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            self.key_id.clone(),
            self.key.clone(),
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(title) = &self.title {
                format!("{:?}", title)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "key_id".to_string(),
            "key".to_string(),
            "id".to_string(),
            "url".to_string(),
            "title".to_string(),
            "created_at".to_string(),
        ]
    }
}

#[doc = "Collaborator"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Collaborator {
    pub login: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub avatar_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gravatar_id: Option<String>,
    pub url: url::Url,
    pub html_url: url::Url,
    pub followers_url: url::Url,
    pub following_url: String,
    pub gists_url: String,
    pub starred_url: String,
    pub subscriptions_url: url::Url,
    pub organizations_url: url::Url,
    pub repos_url: url::Url,
    pub events_url: String,
    pub received_events_url: url::Url,
    #[serde(rename = "type")]
    pub type_: String,
    pub site_admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    pub role_name: String,
}

impl std::fmt::Display for Collaborator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Collaborator {
    const LENGTH: usize = 22;
    fn fields(&self) -> Vec<String> {
        vec![
            self.login.clone(),
            format!("{:?}", self.id),
            if let Some(email) = &self.email {
                format!("{:?}", email)
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            self.node_id.clone(),
            format!("{:?}", self.avatar_url),
            format!("{:?}", self.gravatar_id),
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.followers_url),
            self.following_url.clone(),
            self.gists_url.clone(),
            self.starred_url.clone(),
            format!("{:?}", self.subscriptions_url),
            format!("{:?}", self.organizations_url),
            format!("{:?}", self.repos_url),
            self.events_url.clone(),
            format!("{:?}", self.received_events_url),
            self.type_.clone(),
            format!("{:?}", self.site_admin),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            self.role_name.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "login".to_string(),
            "id".to_string(),
            "email".to_string(),
            "name".to_string(),
            "node_id".to_string(),
            "avatar_url".to_string(),
            "gravatar_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "followers_url".to_string(),
            "following_url".to_string(),
            "gists_url".to_string(),
            "starred_url".to_string(),
            "subscriptions_url".to_string(),
            "organizations_url".to_string(),
            "repos_url".to_string(),
            "events_url".to_string(),
            "received_events_url".to_string(),
            "type_".to_string(),
            "site_admin".to_string(),
            "permissions".to_string(),
            "role_name".to_string(),
        ]
    }
}

#[doc = "Repository invitations let you manage who you collaborate with."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryInvitation {
    #[doc = "Unique identifier of the repository invitation."]
    pub id: i64,
    #[doc = "Minimal Repository"]
    pub repository: MinimalRepository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub invitee: Option<NullableSimpleUser>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inviter: Option<NullableSimpleUser>,
    #[doc = "The permission associated with the invitation."]
    pub permissions: Permissions,
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Whether or not the invitation has expired"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expired: Option<bool>,
    #[doc = "URL for the repository invitation"]
    pub url: String,
    pub html_url: String,
    pub node_id: String,
}

impl std::fmt::Display for RepositoryInvitation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryInvitation {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            format!("{:?}", self.repository),
            format!("{:?}", self.invitee),
            format!("{:?}", self.inviter),
            format!("{:?}", self.permissions),
            format!("{:?}", self.created_at),
            if let Some(expired) = &self.expired {
                format!("{:?}", expired)
            } else {
                String::new()
            },
            self.url.clone(),
            self.html_url.clone(),
            self.node_id.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "repository".to_string(),
            "invitee".to_string(),
            "inviter".to_string(),
            "permissions".to_string(),
            "created_at".to_string(),
            "expired".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "node_id".to_string(),
        ]
    }
}

#[doc = "Collaborator"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableCollaborator {
    pub login: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub avatar_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gravatar_id: Option<String>,
    pub url: url::Url,
    pub html_url: url::Url,
    pub followers_url: url::Url,
    pub following_url: String,
    pub gists_url: String,
    pub starred_url: String,
    pub subscriptions_url: url::Url,
    pub organizations_url: url::Url,
    pub repos_url: url::Url,
    pub events_url: String,
    pub received_events_url: url::Url,
    #[serde(rename = "type")]
    pub type_: String,
    pub site_admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    pub role_name: String,
}

impl std::fmt::Display for NullableCollaborator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableCollaborator {
    const LENGTH: usize = 22;
    fn fields(&self) -> Vec<String> {
        vec![
            self.login.clone(),
            format!("{:?}", self.id),
            if let Some(email) = &self.email {
                format!("{:?}", email)
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            self.node_id.clone(),
            format!("{:?}", self.avatar_url),
            format!("{:?}", self.gravatar_id),
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.followers_url),
            self.following_url.clone(),
            self.gists_url.clone(),
            self.starred_url.clone(),
            format!("{:?}", self.subscriptions_url),
            format!("{:?}", self.organizations_url),
            format!("{:?}", self.repos_url),
            self.events_url.clone(),
            format!("{:?}", self.received_events_url),
            self.type_.clone(),
            format!("{:?}", self.site_admin),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            self.role_name.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "login".to_string(),
            "id".to_string(),
            "email".to_string(),
            "name".to_string(),
            "node_id".to_string(),
            "avatar_url".to_string(),
            "gravatar_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "followers_url".to_string(),
            "following_url".to_string(),
            "gists_url".to_string(),
            "starred_url".to_string(),
            "subscriptions_url".to_string(),
            "organizations_url".to_string(),
            "repos_url".to_string(),
            "events_url".to_string(),
            "received_events_url".to_string(),
            "type_".to_string(),
            "site_admin".to_string(),
            "permissions".to_string(),
            "role_name".to_string(),
        ]
    }
}

#[doc = "Repository Collaborator Permission"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryCollaboratorPermission {
    pub permission: String,
    pub role_name: String,
    #[doc = "Collaborator"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableCollaborator>,
}

impl std::fmt::Display for RepositoryCollaboratorPermission {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryCollaboratorPermission {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.permission.clone(),
            self.role_name.clone(),
            format!("{:?}", self.user),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "permission".to_string(),
            "role_name".to_string(),
            "user".to_string(),
        ]
    }
}

#[doc = "Commit Comment"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CommitComment {
    pub html_url: url::Url,
    pub url: url::Url,
    pub id: i64,
    pub node_id: String,
    pub body: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub line: Option<i64>,
    pub commit_id: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

impl std::fmt::Display for CommitComment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CommitComment {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.html_url),
            format!("{:?}", self.url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.body.clone(),
            format!("{:?}", self.path),
            format!("{:?}", self.position),
            format!("{:?}", self.line),
            self.commit_id.clone(),
            format!("{:?}", self.user),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.author_association),
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "html_url".to_string(),
            "url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "body".to_string(),
            "path".to_string(),
            "position".to_string(),
            "line".to_string(),
            "commit_id".to_string(),
            "user".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "author_association".to_string(),
            "reactions".to_string(),
        ]
    }
}

#[doc = "Branch Short"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BranchShort {
    pub name: String,
    pub commit: Commit,
    pub protected: bool,
}

impl std::fmt::Display for BranchShort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for BranchShort {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.commit),
            format!("{:?}", self.protected),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "commit".to_string(),
            "protected".to_string(),
        ]
    }
}

#[doc = "Hypermedia Link"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Link {
    pub href: String,
}

impl std::fmt::Display for Link {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Link {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.href.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["href".to_string()]
    }
}

#[doc = "The status of auto merging a pull request."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AutoMerge {
    #[doc = "Simple User"]
    pub enabled_by: SimpleUser,
    #[doc = "The merge method to use."]
    pub merge_method: MergeMethod,
    #[doc = "Title for the merge commit message."]
    pub commit_title: String,
    #[doc = "Commit message for the merge commit."]
    pub commit_message: String,
}

impl std::fmt::Display for AutoMerge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for AutoMerge {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.enabled_by),
            format!("{:?}", self.merge_method),
            self.commit_title.clone(),
            self.commit_message.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enabled_by".to_string(),
            "merge_method".to_string(),
            "commit_title".to_string(),
            "commit_message".to_string(),
        ]
    }
}

#[doc = "Pull Request Simple"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestSimple {
    pub url: url::Url,
    pub id: i64,
    pub node_id: String,
    pub html_url: url::Url,
    pub diff_url: url::Url,
    pub patch_url: url::Url,
    pub issue_url: url::Url,
    pub commits_url: url::Url,
    pub review_comments_url: url::Url,
    pub review_comment_url: String,
    pub comments_url: url::Url,
    pub statuses_url: url::Url,
    pub number: i64,
    pub state: String,
    pub locked: bool,
    pub title: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    pub labels: Vec<Labels>,
    #[doc = "A collection of related issues and pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub milestone: Option<NullableMilestone>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active_lock_reason: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignees: Option<Vec<SimpleUser>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_reviewers: Option<Vec<SimpleUser>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    pub head: Head,
    pub base: Base,
    #[serde(rename = "_links")]
    pub links: Links,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[doc = "The status of auto merging a pull request."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auto_merge: Option<AutoMerge>,
    #[doc = "Indicates whether or not the pull request is a draft."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
}

impl std::fmt::Display for PullRequestSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestSimple {
    const LENGTH: usize = 36;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.html_url),
            format!("{:?}", self.diff_url),
            format!("{:?}", self.patch_url),
            format!("{:?}", self.issue_url),
            format!("{:?}", self.commits_url),
            format!("{:?}", self.review_comments_url),
            self.review_comment_url.clone(),
            format!("{:?}", self.comments_url),
            format!("{:?}", self.statuses_url),
            format!("{:?}", self.number),
            self.state.clone(),
            format!("{:?}", self.locked),
            self.title.clone(),
            format!("{:?}", self.user),
            format!("{:?}", self.body),
            format!("{:?}", self.labels),
            format!("{:?}", self.milestone),
            if let Some(active_lock_reason) = &self.active_lock_reason {
                format!("{:?}", active_lock_reason)
            } else {
                String::new()
            },
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.closed_at),
            format!("{:?}", self.merged_at),
            format!("{:?}", self.merge_commit_sha),
            format!("{:?}", self.assignee),
            if let Some(assignees) = &self.assignees {
                format!("{:?}", assignees)
            } else {
                String::new()
            },
            if let Some(requested_reviewers) = &self.requested_reviewers {
                format!("{:?}", requested_reviewers)
            } else {
                String::new()
            },
            if let Some(requested_teams) = &self.requested_teams {
                format!("{:?}", requested_teams)
            } else {
                String::new()
            },
            format!("{:?}", self.head),
            format!("{:?}", self.base),
            format!("{:?}", self.links),
            format!("{:?}", self.author_association),
            format!("{:?}", self.auto_merge),
            if let Some(draft) = &self.draft {
                format!("{:?}", draft)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "html_url".to_string(),
            "diff_url".to_string(),
            "patch_url".to_string(),
            "issue_url".to_string(),
            "commits_url".to_string(),
            "review_comments_url".to_string(),
            "review_comment_url".to_string(),
            "comments_url".to_string(),
            "statuses_url".to_string(),
            "number".to_string(),
            "state".to_string(),
            "locked".to_string(),
            "title".to_string(),
            "user".to_string(),
            "body".to_string(),
            "labels".to_string(),
            "milestone".to_string(),
            "active_lock_reason".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "closed_at".to_string(),
            "merged_at".to_string(),
            "merge_commit_sha".to_string(),
            "assignee".to_string(),
            "assignees".to_string(),
            "requested_reviewers".to_string(),
            "requested_teams".to_string(),
            "head".to_string(),
            "base".to_string(),
            "links".to_string(),
            "author_association".to_string(),
            "auto_merge".to_string(),
            "draft".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SimpleCommitStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub id: i64,
    pub node_id: String,
    pub state: String,
    pub context: String,
    pub target_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<url::Url>,
    pub url: url::Url,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for SimpleCommitStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SimpleCommitStatus {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.description),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.state.clone(),
            self.context.clone(),
            format!("{:?}", self.target_url),
            if let Some(required) = &self.required {
                format!("{:?}", required)
            } else {
                String::new()
            },
            format!("{:?}", self.avatar_url),
            format!("{:?}", self.url),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "description".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "state".to_string(),
            "context".to_string(),
            "target_url".to_string(),
            "required".to_string(),
            "avatar_url".to_string(),
            "url".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
        ]
    }
}

#[doc = "Combined Commit Status"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CombinedCommitStatus {
    pub state: String,
    pub statuses: Vec<SimpleCommitStatus>,
    pub sha: String,
    pub total_count: i64,
    #[doc = "Minimal Repository"]
    pub repository: MinimalRepository,
    pub commit_url: url::Url,
    pub url: url::Url,
}

impl std::fmt::Display for CombinedCommitStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CombinedCommitStatus {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            self.state.clone(),
            format!("{:?}", self.statuses),
            self.sha.clone(),
            format!("{:?}", self.total_count),
            format!("{:?}", self.repository),
            format!("{:?}", self.commit_url),
            format!("{:?}", self.url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "state".to_string(),
            "statuses".to_string(),
            "sha".to_string(),
            "total_count".to_string(),
            "repository".to_string(),
            "commit_url".to_string(),
            "url".to_string(),
        ]
    }
}

#[doc = "The status of a commit."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Status {
    pub url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<String>,
    pub id: i64,
    pub node_id: String,
    pub state: String,
    pub description: String,
    pub target_url: String,
    pub context: String,
    pub created_at: String,
    pub updated_at: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
}

impl std::fmt::Display for Status {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Status {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            self.url.clone(),
            format!("{:?}", self.avatar_url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.state.clone(),
            self.description.clone(),
            self.target_url.clone(),
            self.context.clone(),
            self.created_at.clone(),
            self.updated_at.clone(),
            format!("{:?}", self.creator),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "avatar_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "state".to_string(),
            "description".to_string(),
            "target_url".to_string(),
            "context".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "creator".to_string(),
        ]
    }
}

#[doc = "Code of Conduct Simple"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableCodeOfConductSimple {
    pub url: url::Url,
    pub key: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
}

impl std::fmt::Display for NullableCodeOfConductSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableCodeOfConductSimple {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            self.key.clone(),
            self.name.clone(),
            format!("{:?}", self.html_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "key".to_string(),
            "name".to_string(),
            "html_url".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableCommunityHealthFile {
    pub url: url::Url,
    pub html_url: url::Url,
}

impl std::fmt::Display for NullableCommunityHealthFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableCommunityHealthFile {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.url), format!("{:?}", self.html_url)]
    }

    fn headers() -> Vec<String> {
        vec!["url".to_string(), "html_url".to_string()]
    }
}

#[doc = "Community Profile"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CommunityProfile {
    pub health_percentage: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation: Option<String>,
    pub files: Files,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_reports_enabled: Option<bool>,
}

impl std::fmt::Display for CommunityProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CommunityProfile {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.health_percentage),
            format!("{:?}", self.description),
            format!("{:?}", self.documentation),
            format!("{:?}", self.files),
            format!("{:?}", self.updated_at),
            if let Some(content_reports_enabled) = &self.content_reports_enabled {
                format!("{:?}", content_reports_enabled)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "health_percentage".to_string(),
            "description".to_string(),
            "documentation".to_string(),
            "files".to_string(),
            "updated_at".to_string(),
            "content_reports_enabled".to_string(),
        ]
    }
}

#[doc = "Commit Comparison"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CommitComparison {
    pub url: url::Url,
    pub html_url: url::Url,
    pub permalink_url: url::Url,
    pub diff_url: url::Url,
    pub patch_url: url::Url,
    #[doc = "Commit"]
    pub base_commit: Commit,
    #[doc = "Commit"]
    pub merge_base_commit: Commit,
    pub status: Status,
    pub ahead_by: i64,
    pub behind_by: i64,
    pub total_commits: i64,
    pub commits: Vec<Commit>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<DiffEntry>>,
}

impl std::fmt::Display for CommitComparison {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CommitComparison {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.permalink_url),
            format!("{:?}", self.diff_url),
            format!("{:?}", self.patch_url),
            format!("{:?}", self.base_commit),
            format!("{:?}", self.merge_base_commit),
            format!("{:?}", self.status),
            format!("{:?}", self.ahead_by),
            format!("{:?}", self.behind_by),
            format!("{:?}", self.total_commits),
            format!("{:?}", self.commits),
            if let Some(files) = &self.files {
                format!("{:?}", files)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "html_url".to_string(),
            "permalink_url".to_string(),
            "diff_url".to_string(),
            "patch_url".to_string(),
            "base_commit".to_string(),
            "merge_base_commit".to_string(),
            "status".to_string(),
            "ahead_by".to_string(),
            "behind_by".to_string(),
            "total_commits".to_string(),
            "commits".to_string(),
            "files".to_string(),
        ]
    }
}

#[doc = "Content Tree"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ContentTree {
    #[serde(rename = "type")]
    pub type_: String,
    pub size: i64,
    pub name: String,
    pub path: String,
    pub sha: String,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub download_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<Vec<Entries>>,
    #[serde(rename = "_links")]
    pub links: Links,
}

impl std::fmt::Display for ContentTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ContentTree {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            self.type_.clone(),
            format!("{:?}", self.size),
            self.name.clone(),
            self.path.clone(),
            self.sha.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.git_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.download_url),
            if let Some(entries) = &self.entries {
                format!("{:?}", entries)
            } else {
                String::new()
            },
            format!("{:?}", self.links),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "type_".to_string(),
            "size".to_string(),
            "name".to_string(),
            "path".to_string(),
            "sha".to_string(),
            "url".to_string(),
            "git_url".to_string(),
            "html_url".to_string(),
            "download_url".to_string(),
            "entries".to_string(),
            "links".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ContentDirectory {
    #[serde(rename = "type")]
    pub type_: String,
    pub size: i64,
    pub name: String,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,
    pub sha: String,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub download_url: Option<url::Url>,
    #[serde(rename = "_links")]
    pub links: Links,
}

impl std::fmt::Display for ContentDirectory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ContentDirectory {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            self.type_.clone(),
            format!("{:?}", self.size),
            self.name.clone(),
            self.path.clone(),
            if let Some(content) = &self.content {
                format!("{:?}", content)
            } else {
                String::new()
            },
            self.sha.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.git_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.download_url),
            format!("{:?}", self.links),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "type_".to_string(),
            "size".to_string(),
            "name".to_string(),
            "path".to_string(),
            "content".to_string(),
            "sha".to_string(),
            "url".to_string(),
            "git_url".to_string(),
            "html_url".to_string(),
            "download_url".to_string(),
            "links".to_string(),
        ]
    }
}

#[doc = "Content File"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ContentFile {
    #[serde(rename = "type")]
    pub type_: String,
    pub encoding: String,
    pub size: i64,
    pub name: String,
    pub path: String,
    pub content: String,
    pub sha: String,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub download_url: Option<url::Url>,
    #[serde(rename = "_links")]
    pub links: Links,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub submodule_git_url: Option<String>,
}

impl std::fmt::Display for ContentFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ContentFile {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            self.type_.clone(),
            self.encoding.clone(),
            format!("{:?}", self.size),
            self.name.clone(),
            self.path.clone(),
            self.content.clone(),
            self.sha.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.git_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.download_url),
            format!("{:?}", self.links),
            if let Some(target) = &self.target {
                format!("{:?}", target)
            } else {
                String::new()
            },
            if let Some(submodule_git_url) = &self.submodule_git_url {
                format!("{:?}", submodule_git_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "type_".to_string(),
            "encoding".to_string(),
            "size".to_string(),
            "name".to_string(),
            "path".to_string(),
            "content".to_string(),
            "sha".to_string(),
            "url".to_string(),
            "git_url".to_string(),
            "html_url".to_string(),
            "download_url".to_string(),
            "links".to_string(),
            "target".to_string(),
            "submodule_git_url".to_string(),
        ]
    }
}

#[doc = "An object describing a symlink"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ContentSymlink {
    #[serde(rename = "type")]
    pub type_: String,
    pub target: String,
    pub size: i64,
    pub name: String,
    pub path: String,
    pub sha: String,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub download_url: Option<url::Url>,
    #[serde(rename = "_links")]
    pub links: Links,
}

impl std::fmt::Display for ContentSymlink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ContentSymlink {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            self.type_.clone(),
            self.target.clone(),
            format!("{:?}", self.size),
            self.name.clone(),
            self.path.clone(),
            self.sha.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.git_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.download_url),
            format!("{:?}", self.links),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "type_".to_string(),
            "target".to_string(),
            "size".to_string(),
            "name".to_string(),
            "path".to_string(),
            "sha".to_string(),
            "url".to_string(),
            "git_url".to_string(),
            "html_url".to_string(),
            "download_url".to_string(),
            "links".to_string(),
        ]
    }
}

#[doc = "An object describing a symlink"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ContentSubmodule {
    #[serde(rename = "type")]
    pub type_: String,
    pub submodule_git_url: url::Url,
    pub size: i64,
    pub name: String,
    pub path: String,
    pub sha: String,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub download_url: Option<url::Url>,
    #[serde(rename = "_links")]
    pub links: Links,
}

impl std::fmt::Display for ContentSubmodule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ContentSubmodule {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            self.type_.clone(),
            format!("{:?}", self.submodule_git_url),
            format!("{:?}", self.size),
            self.name.clone(),
            self.path.clone(),
            self.sha.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.git_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.download_url),
            format!("{:?}", self.links),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "type_".to_string(),
            "submodule_git_url".to_string(),
            "size".to_string(),
            "name".to_string(),
            "path".to_string(),
            "sha".to_string(),
            "url".to_string(),
            "git_url".to_string(),
            "html_url".to_string(),
            "download_url".to_string(),
            "links".to_string(),
        ]
    }
}

#[doc = "File Commit"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileCommit {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content: Option<Content>,
    pub commit: Commit,
}

impl std::fmt::Display for FileCommit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for FileCommit {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.content), format!("{:?}", self.commit)]
    }

    fn headers() -> Vec<String> {
        vec!["content".to_string(), "commit".to_string()]
    }
}

#[doc = "Contributor"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Contributor {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub login: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub followers_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub following_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscriptions_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organizations_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repos_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub events_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub received_events_url: Option<url::Url>,
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub site_admin: Option<bool>,
    pub contributions: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for Contributor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Contributor {
    const LENGTH: usize = 21;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(login) = &self.login {
                format!("{:?}", login)
            } else {
                String::new()
            },
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(node_id) = &self.node_id {
                format!("{:?}", node_id)
            } else {
                String::new()
            },
            if let Some(avatar_url) = &self.avatar_url {
                format!("{:?}", avatar_url)
            } else {
                String::new()
            },
            if let Some(gravatar_id) = &self.gravatar_id {
                format!("{:?}", gravatar_id)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
            if let Some(followers_url) = &self.followers_url {
                format!("{:?}", followers_url)
            } else {
                String::new()
            },
            if let Some(following_url) = &self.following_url {
                format!("{:?}", following_url)
            } else {
                String::new()
            },
            if let Some(gists_url) = &self.gists_url {
                format!("{:?}", gists_url)
            } else {
                String::new()
            },
            if let Some(starred_url) = &self.starred_url {
                format!("{:?}", starred_url)
            } else {
                String::new()
            },
            if let Some(subscriptions_url) = &self.subscriptions_url {
                format!("{:?}", subscriptions_url)
            } else {
                String::new()
            },
            if let Some(organizations_url) = &self.organizations_url {
                format!("{:?}", organizations_url)
            } else {
                String::new()
            },
            if let Some(repos_url) = &self.repos_url {
                format!("{:?}", repos_url)
            } else {
                String::new()
            },
            if let Some(events_url) = &self.events_url {
                format!("{:?}", events_url)
            } else {
                String::new()
            },
            if let Some(received_events_url) = &self.received_events_url {
                format!("{:?}", received_events_url)
            } else {
                String::new()
            },
            self.type_.clone(),
            if let Some(site_admin) = &self.site_admin {
                format!("{:?}", site_admin)
            } else {
                String::new()
            },
            format!("{:?}", self.contributions),
            if let Some(email) = &self.email {
                format!("{:?}", email)
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "login".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "avatar_url".to_string(),
            "gravatar_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "followers_url".to_string(),
            "following_url".to_string(),
            "gists_url".to_string(),
            "starred_url".to_string(),
            "subscriptions_url".to_string(),
            "organizations_url".to_string(),
            "repos_url".to_string(),
            "events_url".to_string(),
            "received_events_url".to_string(),
            "type_".to_string(),
            "site_admin".to_string(),
            "contributions".to_string(),
            "email".to_string(),
            "name".to_string(),
        ]
    }
}

#[doc = "Set secrets for Dependabot."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DependabotSecret {
    #[doc = "The name of the secret."]
    pub name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for DependabotSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DependabotSecret {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DependencyGraphDiff {
    pub change_type: ChangeType,
    pub manifest: String,
    pub ecosystem: String,
    pub name: String,
    pub version: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub package_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source_repository_url: Option<String>,
    pub vulnerabilities: Vec<Vulnerabilities>,
}

impl std::fmt::Display for DependencyGraphDiff {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DependencyGraphDiff {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.change_type),
            self.manifest.clone(),
            self.ecosystem.clone(),
            self.name.clone(),
            self.version.clone(),
            format!("{:?}", self.package_url),
            format!("{:?}", self.license),
            format!("{:?}", self.source_repository_url),
            format!("{:?}", self.vulnerabilities),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "change_type".to_string(),
            "manifest".to_string(),
            "ecosystem".to_string(),
            "name".to_string(),
            "version".to_string(),
            "package_url".to_string(),
            "license".to_string(),
            "source_repository_url".to_string(),
            "vulnerabilities".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
)]
pub enum Metadata {
    String(String),
    f64(f64),
    bool(bool),
}

#[doc = "A single package dependency."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Dependency {
    #[doc = "Package-url (PURL) of dependency. See https://github.com/package-url/purl-spec for more details."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub package_url: Option<String>,
    #[doc = "User-defined metadata to store domain-specific information limited to 8 keys with scalar values."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, Option<Metadata>>>,
    #[doc = "A notation of whether a dependency is requested directly by this manifest or is a dependency of another dependency."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub relationship: Option<Relationship>,
    #[doc = "A notation of whether the dependency is required for the primary build artifact (runtime) or is only used for development. Future versions of this specification may allow for more granular scopes."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<Scope>,
    #[doc = "Array of package-url (PURLs) of direct child dependencies."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dependencies: Option<Vec<String>>,
}

impl std::fmt::Display for Dependency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Dependency {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(package_url) = &self.package_url {
                format!("{:?}", package_url)
            } else {
                String::new()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata)
            } else {
                String::new()
            },
            if let Some(relationship) = &self.relationship {
                format!("{:?}", relationship)
            } else {
                String::new()
            },
            if let Some(scope) = &self.scope {
                format!("{:?}", scope)
            } else {
                String::new()
            },
            if let Some(dependencies) = &self.dependencies {
                format!("{:?}", dependencies)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "package_url".to_string(),
            "metadata".to_string(),
            "relationship".to_string(),
            "scope".to_string(),
            "dependencies".to_string(),
        ]
    }
}

#[doc = "A collection of related dependencies declared in a file or representing a logical group of dependencies."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Manifest {
    #[doc = "The name of the manifest."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub file: Option<File>,
    #[doc = "User-defined metadata to store domain-specific information limited to 8 keys with scalar values."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, Option<Metadata>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolved: Option<serde_json::Value>,
}

impl std::fmt::Display for Manifest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Manifest {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            if let Some(file) = &self.file {
                format!("{:?}", file)
            } else {
                String::new()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata)
            } else {
                String::new()
            },
            if let Some(resolved) = &self.resolved {
                format!("{:?}", resolved)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "file".to_string(),
            "metadata".to_string(),
            "resolved".to_string(),
        ]
    }
}

#[doc = "Create a new snapshot of a repository's dependencies."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Snapshot {
    #[doc = "The version of the repository snapshot submission."]
    pub version: i64,
    pub job: Job,
    #[doc = "The commit SHA associated with this dependency snapshot."]
    pub sha: String,
    #[doc = "The repository branch that triggered this snapshot."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "A description of the detector used."]
    pub detector: Detector,
    #[doc = "User-defined metadata to store domain-specific information limited to 8 keys with scalar values."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, Option<Metadata>>>,
    #[doc = "A collection of package manifests"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub manifests: Option<std::collections::HashMap<String, Manifest>>,
    #[doc = "The time at which the snapshot was scanned."]
    pub scanned: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Snapshot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Snapshot {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.version),
            format!("{:?}", self.job),
            self.sha.clone(),
            self.ref_.clone(),
            format!("{:?}", self.detector),
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata)
            } else {
                String::new()
            },
            if let Some(manifests) = &self.manifests {
                format!("{:?}", manifests)
            } else {
                String::new()
            },
            format!("{:?}", self.scanned),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "version".to_string(),
            "job".to_string(),
            "sha".to_string(),
            "ref_".to_string(),
            "detector".to_string(),
            "metadata".to_string(),
            "manifests".to_string(),
            "scanned".to_string(),
        ]
    }
}

#[doc = "The status of a deployment."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeploymentStatus {
    pub url: url::Url,
    pub id: i64,
    pub node_id: String,
    #[doc = "The state of the status."]
    pub state: State,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
    #[doc = "A short description of the status."]
    pub description: String,
    #[doc = "The environment of the deployment that the status is for."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environment: Option<String>,
    #[doc = "Deprecated: the URL to associate with this status."]
    pub target_url: url::Url,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub deployment_url: url::Url,
    pub repository_url: url::Url,
    #[doc = "The URL for accessing your environment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environment_url: Option<url::Url>,
    #[doc = "The URL to associate with this status."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log_url: Option<url::Url>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
}

impl std::fmt::Display for DeploymentStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeploymentStatus {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.state),
            format!("{:?}", self.creator),
            self.description.clone(),
            if let Some(environment) = &self.environment {
                format!("{:?}", environment)
            } else {
                String::new()
            },
            format!("{:?}", self.target_url),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.deployment_url),
            format!("{:?}", self.repository_url),
            if let Some(environment_url) = &self.environment_url {
                format!("{:?}", environment_url)
            } else {
                String::new()
            },
            if let Some(log_url) = &self.log_url {
                format!("{:?}", log_url)
            } else {
                String::new()
            },
            if let Some(performed_via_github_app) = &self.performed_via_github_app {
                format!("{:?}", performed_via_github_app)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "state".to_string(),
            "creator".to_string(),
            "description".to_string(),
            "environment".to_string(),
            "target_url".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "deployment_url".to_string(),
            "repository_url".to_string(),
            "environment_url".to_string(),
            "log_url".to_string(),
            "performed_via_github_app".to_string(),
        ]
    }
}

#[doc = "The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeploymentBranchPolicy {
    #[doc = "Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`."]
    pub protected_branches: bool,
    #[doc = "Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`."]
    pub custom_branch_policies: bool,
}

impl std::fmt::Display for DeploymentBranchPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeploymentBranchPolicy {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.protected_branches),
            format!("{:?}", self.custom_branch_policies),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "protected_branches".to_string(),
            "custom_branch_policies".to_string(),
        ]
    }
}

#[doc = "Details of a deployment environment"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Environment {
    #[doc = "The id of the environment."]
    pub id: i64,
    pub node_id: String,
    #[doc = "The name of the environment."]
    pub name: String,
    pub url: String,
    pub html_url: String,
    #[doc = "The time that the environment was created, in ISO 8601 format."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The time that the environment was last updated, in ISO 8601 format."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protection_rules: Option<Vec<ProtectionRules>>,
    #[doc = "The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment_branch_policy: Option<DeploymentBranchPolicy>,
}

impl std::fmt::Display for Environment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Environment {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.url.clone(),
            self.html_url.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(protection_rules) = &self.protection_rules {
                format!("{:?}", protection_rules)
            } else {
                String::new()
            },
            if let Some(deployment_branch_policy) = &self.deployment_branch_policy {
                format!("{:?}", deployment_branch_policy)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "protection_rules".to_string(),
            "deployment_branch_policy".to_string(),
        ]
    }
}

#[doc = "Short Blob"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ShortBlob {
    pub url: String,
    pub sha: String,
}

impl std::fmt::Display for ShortBlob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ShortBlob {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.url.clone(), self.sha.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["url".to_string(), "sha".to_string()]
    }
}

#[doc = "Blob"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Blob {
    pub content: String,
    pub encoding: String,
    pub url: url::Url,
    pub sha: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<i64>,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub highlighted_content: Option<String>,
}

impl std::fmt::Display for Blob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Blob {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            self.content.clone(),
            self.encoding.clone(),
            format!("{:?}", self.url),
            self.sha.clone(),
            format!("{:?}", self.size),
            self.node_id.clone(),
            if let Some(highlighted_content) = &self.highlighted_content {
                format!("{:?}", highlighted_content)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "content".to_string(),
            "encoding".to_string(),
            "url".to_string(),
            "sha".to_string(),
            "size".to_string(),
            "node_id".to_string(),
            "highlighted_content".to_string(),
        ]
    }
}

#[doc = "Low-level Git commit operations within a repository"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GitCommit {
    #[doc = "SHA for the commit"]
    pub sha: String,
    pub node_id: String,
    pub url: url::Url,
    #[doc = "Identifying information for the git-user"]
    pub author: Author,
    #[doc = "Identifying information for the git-user"]
    pub committer: Committer,
    #[doc = "Message describing the purpose of the commit"]
    pub message: String,
    pub tree: Tree,
    pub parents: Vec<Parents>,
    pub verification: Verification,
    pub html_url: url::Url,
}

impl std::fmt::Display for GitCommit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GitCommit {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            self.sha.clone(),
            self.node_id.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.author),
            format!("{:?}", self.committer),
            self.message.clone(),
            format!("{:?}", self.tree),
            format!("{:?}", self.parents),
            format!("{:?}", self.verification),
            format!("{:?}", self.html_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sha".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "author".to_string(),
            "committer".to_string(),
            "message".to_string(),
            "tree".to_string(),
            "parents".to_string(),
            "verification".to_string(),
            "html_url".to_string(),
        ]
    }
}

#[doc = "Git references within a repository"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GitRef {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub node_id: String,
    pub url: url::Url,
    pub object: Object,
}

impl std::fmt::Display for GitRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GitRef {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            self.ref_.clone(),
            self.node_id.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.object),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "ref_".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "object".to_string(),
        ]
    }
}

#[doc = "Metadata for a Git tag"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GitTag {
    pub node_id: String,
    #[doc = "Name of the tag"]
    pub tag: String,
    pub sha: String,
    #[doc = "URL for the tag"]
    pub url: url::Url,
    #[doc = "Message describing the purpose of the tag"]
    pub message: String,
    pub tagger: Tagger,
    pub object: Object,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verification: Option<Verification>,
}

impl std::fmt::Display for GitTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GitTag {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            self.node_id.clone(),
            self.tag.clone(),
            self.sha.clone(),
            format!("{:?}", self.url),
            self.message.clone(),
            format!("{:?}", self.tagger),
            format!("{:?}", self.object),
            if let Some(verification) = &self.verification {
                format!("{:?}", verification)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "node_id".to_string(),
            "tag".to_string(),
            "sha".to_string(),
            "url".to_string(),
            "message".to_string(),
            "tagger".to_string(),
            "object".to_string(),
            "verification".to_string(),
        ]
    }
}

#[doc = "The hierarchy between files in a Git repository."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GitTree {
    pub sha: String,
    pub url: url::Url,
    pub truncated: bool,
    #[doc = "Objects specifying a tree structure"]
    pub tree: Vec<Tree>,
}

impl std::fmt::Display for GitTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GitTree {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            self.sha.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.truncated),
            format!("{:?}", self.tree),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sha".to_string(),
            "url".to_string(),
            "truncated".to_string(),
            "tree".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct HookResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

impl std::fmt::Display for HookResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for HookResponse {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.code),
            format!("{:?}", self.status),
            format!("{:?}", self.message),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "code".to_string(),
            "status".to_string(),
            "message".to_string(),
        ]
    }
}

#[doc = "Webhooks for repositories."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Hook {
    #[serde(rename = "type")]
    pub type_: String,
    #[doc = "Unique identifier of the webhook."]
    pub id: i64,
    #[doc = "The name of a valid service, use 'web' for a webhook."]
    pub name: String,
    #[doc = "Determines whether the hook is actually triggered on pushes."]
    pub active: bool,
    #[doc = "Determines what events the hook is triggered for. Default: ['push']."]
    pub events: Vec<String>,
    pub config: Config,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub url: url::Url,
    pub test_url: url::Url,
    pub ping_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deliveries_url: Option<url::Url>,
    pub last_response: HookResponse,
}

impl std::fmt::Display for Hook {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Hook {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            self.type_.clone(),
            format!("{:?}", self.id),
            self.name.clone(),
            format!("{:?}", self.active),
            format!("{:?}", self.events),
            format!("{:?}", self.config),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.created_at),
            format!("{:?}", self.url),
            format!("{:?}", self.test_url),
            format!("{:?}", self.ping_url),
            if let Some(deliveries_url) = &self.deliveries_url {
                format!("{:?}", deliveries_url)
            } else {
                String::new()
            },
            format!("{:?}", self.last_response),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "type_".to_string(),
            "id".to_string(),
            "name".to_string(),
            "active".to_string(),
            "events".to_string(),
            "config".to_string(),
            "updated_at".to_string(),
            "created_at".to_string(),
            "url".to_string(),
            "test_url".to_string(),
            "ping_url".to_string(),
            "deliveries_url".to_string(),
            "last_response".to_string(),
        ]
    }
}

#[doc = "A repository import from an external source."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Import {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vcs: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub use_lfs: Option<bool>,
    #[doc = "The URL of the originating repository."]
    pub vcs_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub svc_root: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tfvc_project: Option<String>,
    pub status: Status,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failed_step: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub import_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub push_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_large_files: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub large_files_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub large_files_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_choices: Option<Vec<ProjectChoices>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authors_count: Option<i64>,
    pub url: url::Url,
    pub html_url: url::Url,
    pub authors_url: url::Url,
    pub repository_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub svn_root: Option<String>,
}

impl std::fmt::Display for Import {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Import {
    const LENGTH: usize = 23;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.vcs),
            if let Some(use_lfs) = &self.use_lfs {
                format!("{:?}", use_lfs)
            } else {
                String::new()
            },
            self.vcs_url.clone(),
            if let Some(svc_root) = &self.svc_root {
                format!("{:?}", svc_root)
            } else {
                String::new()
            },
            if let Some(tfvc_project) = &self.tfvc_project {
                format!("{:?}", tfvc_project)
            } else {
                String::new()
            },
            format!("{:?}", self.status),
            if let Some(status_text) = &self.status_text {
                format!("{:?}", status_text)
            } else {
                String::new()
            },
            if let Some(failed_step) = &self.failed_step {
                format!("{:?}", failed_step)
            } else {
                String::new()
            },
            if let Some(error_message) = &self.error_message {
                format!("{:?}", error_message)
            } else {
                String::new()
            },
            if let Some(import_percent) = &self.import_percent {
                format!("{:?}", import_percent)
            } else {
                String::new()
            },
            if let Some(commit_count) = &self.commit_count {
                format!("{:?}", commit_count)
            } else {
                String::new()
            },
            if let Some(push_percent) = &self.push_percent {
                format!("{:?}", push_percent)
            } else {
                String::new()
            },
            if let Some(has_large_files) = &self.has_large_files {
                format!("{:?}", has_large_files)
            } else {
                String::new()
            },
            if let Some(large_files_size) = &self.large_files_size {
                format!("{:?}", large_files_size)
            } else {
                String::new()
            },
            if let Some(large_files_count) = &self.large_files_count {
                format!("{:?}", large_files_count)
            } else {
                String::new()
            },
            if let Some(project_choices) = &self.project_choices {
                format!("{:?}", project_choices)
            } else {
                String::new()
            },
            if let Some(message) = &self.message {
                format!("{:?}", message)
            } else {
                String::new()
            },
            if let Some(authors_count) = &self.authors_count {
                format!("{:?}", authors_count)
            } else {
                String::new()
            },
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.authors_url),
            format!("{:?}", self.repository_url),
            if let Some(svn_root) = &self.svn_root {
                format!("{:?}", svn_root)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "vcs".to_string(),
            "use_lfs".to_string(),
            "vcs_url".to_string(),
            "svc_root".to_string(),
            "tfvc_project".to_string(),
            "status".to_string(),
            "status_text".to_string(),
            "failed_step".to_string(),
            "error_message".to_string(),
            "import_percent".to_string(),
            "commit_count".to_string(),
            "push_percent".to_string(),
            "has_large_files".to_string(),
            "large_files_size".to_string(),
            "large_files_count".to_string(),
            "project_choices".to_string(),
            "message".to_string(),
            "authors_count".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "authors_url".to_string(),
            "repository_url".to_string(),
            "svn_root".to_string(),
        ]
    }
}

#[doc = "Porter Author"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PorterAuthor {
    pub id: i64,
    pub remote_id: String,
    pub remote_name: String,
    pub email: String,
    pub name: String,
    pub url: url::Url,
    pub import_url: url::Url,
}

impl std::fmt::Display for PorterAuthor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PorterAuthor {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.remote_id.clone(),
            self.remote_name.clone(),
            self.email.clone(),
            self.name.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.import_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "remote_id".to_string(),
            "remote_name".to_string(),
            "email".to_string(),
            "name".to_string(),
            "url".to_string(),
            "import_url".to_string(),
        ]
    }
}

#[doc = "Porter Large File"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PorterLargeFile {
    pub ref_name: String,
    pub path: String,
    pub oid: String,
    pub size: i64,
}

impl std::fmt::Display for PorterLargeFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PorterLargeFile {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            self.ref_name.clone(),
            self.path.clone(),
            self.oid.clone(),
            format!("{:?}", self.size),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "ref_name".to_string(),
            "path".to_string(),
            "oid".to_string(),
            "size".to_string(),
        ]
    }
}

#[doc = "Issues are a great way to keep track of tasks, enhancements, and bugs for your projects."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NullableIssue {
    pub id: i64,
    pub node_id: String,
    #[doc = "URL for the issue"]
    pub url: url::Url,
    pub repository_url: url::Url,
    pub labels_url: String,
    pub comments_url: url::Url,
    pub events_url: url::Url,
    pub html_url: url::Url,
    #[doc = "Number uniquely identifying the issue within its repository"]
    pub number: i64,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    pub state: String,
    #[doc = "The reason for the current state"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state_reason: Option<String>,
    #[doc = "Title of the issue"]
    pub title: String,
    #[doc = "Contents of the issue"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[doc = "Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"]
    pub labels: Vec<Labels>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignees: Option<Vec<SimpleUser>>,
    #[doc = "A collection of related issues and pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub milestone: Option<NullableMilestone>,
    pub locked: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active_lock_reason: Option<String>,
    pub comments: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<PullRequest>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub closed_by: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeline_url: Option<url::Url>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

impl std::fmt::Display for NullableIssue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for NullableIssue {
    const LENGTH: usize = 34;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.repository_url),
            self.labels_url.clone(),
            format!("{:?}", self.comments_url),
            format!("{:?}", self.events_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.number),
            self.state.clone(),
            if let Some(state_reason) = &self.state_reason {
                format!("{:?}", state_reason)
            } else {
                String::new()
            },
            self.title.clone(),
            if let Some(body) = &self.body {
                format!("{:?}", body)
            } else {
                String::new()
            },
            format!("{:?}", self.user),
            format!("{:?}", self.labels),
            format!("{:?}", self.assignee),
            if let Some(assignees) = &self.assignees {
                format!("{:?}", assignees)
            } else {
                String::new()
            },
            format!("{:?}", self.milestone),
            format!("{:?}", self.locked),
            if let Some(active_lock_reason) = &self.active_lock_reason {
                format!("{:?}", active_lock_reason)
            } else {
                String::new()
            },
            format!("{:?}", self.comments),
            if let Some(pull_request) = &self.pull_request {
                format!("{:?}", pull_request)
            } else {
                String::new()
            },
            format!("{:?}", self.closed_at),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            if let Some(draft) = &self.draft {
                format!("{:?}", draft)
            } else {
                String::new()
            },
            if let Some(closed_by) = &self.closed_by {
                format!("{:?}", closed_by)
            } else {
                String::new()
            },
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
            if let Some(timeline_url) = &self.timeline_url {
                format!("{:?}", timeline_url)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(performed_via_github_app) = &self.performed_via_github_app {
                format!("{:?}", performed_via_github_app)
            } else {
                String::new()
            },
            format!("{:?}", self.author_association),
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "repository_url".to_string(),
            "labels_url".to_string(),
            "comments_url".to_string(),
            "events_url".to_string(),
            "html_url".to_string(),
            "number".to_string(),
            "state".to_string(),
            "state_reason".to_string(),
            "title".to_string(),
            "body".to_string(),
            "user".to_string(),
            "labels".to_string(),
            "assignee".to_string(),
            "assignees".to_string(),
            "milestone".to_string(),
            "locked".to_string(),
            "active_lock_reason".to_string(),
            "comments".to_string(),
            "pull_request".to_string(),
            "closed_at".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "draft".to_string(),
            "closed_by".to_string(),
            "body_html".to_string(),
            "body_text".to_string(),
            "timeline_url".to_string(),
            "repository".to_string(),
            "performed_via_github_app".to_string(),
            "author_association".to_string(),
            "reactions".to_string(),
        ]
    }
}

#[doc = "Issue Event Label"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueEventLabel {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
}

impl std::fmt::Display for IssueEventLabel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueEventLabel {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.name), format!("{:?}", self.color)]
    }

    fn headers() -> Vec<String> {
        vec!["name".to_string(), "color".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueEventDismissedReview {
    pub state: String,
    pub review_id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissal_message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissal_commit_id: Option<String>,
}

impl std::fmt::Display for IssueEventDismissedReview {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueEventDismissedReview {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            self.state.clone(),
            format!("{:?}", self.review_id),
            format!("{:?}", self.dismissal_message),
            if let Some(dismissal_commit_id) = &self.dismissal_commit_id {
                format!("{:?}", dismissal_commit_id)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "state".to_string(),
            "review_id".to_string(),
            "dismissal_message".to_string(),
            "dismissal_commit_id".to_string(),
        ]
    }
}

#[doc = "Issue Event Milestone"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueEventMilestone {
    pub title: String,
}

impl std::fmt::Display for IssueEventMilestone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueEventMilestone {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.title.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["title".to_string()]
    }
}

#[doc = "Issue Event Project Card"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueEventProjectCard {
    pub url: url::Url,
    pub id: i64,
    pub project_url: url::Url,
    pub project_id: i64,
    pub column_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_column_name: Option<String>,
}

impl std::fmt::Display for IssueEventProjectCard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueEventProjectCard {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.id),
            format!("{:?}", self.project_url),
            format!("{:?}", self.project_id),
            self.column_name.clone(),
            if let Some(previous_column_name) = &self.previous_column_name {
                format!("{:?}", previous_column_name)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "id".to_string(),
            "project_url".to_string(),
            "project_id".to_string(),
            "column_name".to_string(),
            "previous_column_name".to_string(),
        ]
    }
}

#[doc = "Issue Event Rename"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueEventRename {
    pub from: String,
    pub to: String,
}

impl std::fmt::Display for IssueEventRename {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueEventRename {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.from.clone(), self.to.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["from".to_string(), "to".to_string()]
    }
}

#[doc = "Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: url::Url,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actor: Option<NullableSimpleUser>,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Issues are a great way to keep track of tasks, enhancements, and bugs for your projects."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issue: Option<NullableIssue>,
    #[doc = "Issue Event Label"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<IssueEventLabel>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assigner: Option<NullableSimpleUser>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub review_requester: Option<NullableSimpleUser>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_reviewer: Option<NullableSimpleUser>,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_team: Option<Team>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_review: Option<IssueEventDismissedReview>,
    #[doc = "Issue Event Milestone"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub milestone: Option<IssueEventMilestone>,
    #[doc = "Issue Event Project Card"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_card: Option<IssueEventProjectCard>,
    #[doc = "Issue Event Rename"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rename: Option<IssueEventRename>,
    #[doc = "How the author is associated with the repository."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lock_reason: Option<String>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
}

impl std::fmt::Display for IssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueEvent {
    const LENGTH: usize = 22;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            format!("{:?}", self.created_at),
            if let Some(issue) = &self.issue {
                format!("{:?}", issue)
            } else {
                String::new()
            },
            if let Some(label) = &self.label {
                format!("{:?}", label)
            } else {
                String::new()
            },
            if let Some(assignee) = &self.assignee {
                format!("{:?}", assignee)
            } else {
                String::new()
            },
            if let Some(assigner) = &self.assigner {
                format!("{:?}", assigner)
            } else {
                String::new()
            },
            if let Some(review_requester) = &self.review_requester {
                format!("{:?}", review_requester)
            } else {
                String::new()
            },
            if let Some(requested_reviewer) = &self.requested_reviewer {
                format!("{:?}", requested_reviewer)
            } else {
                String::new()
            },
            if let Some(requested_team) = &self.requested_team {
                format!("{:?}", requested_team)
            } else {
                String::new()
            },
            if let Some(dismissed_review) = &self.dismissed_review {
                format!("{:?}", dismissed_review)
            } else {
                String::new()
            },
            if let Some(milestone) = &self.milestone {
                format!("{:?}", milestone)
            } else {
                String::new()
            },
            if let Some(project_card) = &self.project_card {
                format!("{:?}", project_card)
            } else {
                String::new()
            },
            if let Some(rename) = &self.rename {
                format!("{:?}", rename)
            } else {
                String::new()
            },
            if let Some(author_association) = &self.author_association {
                format!("{:?}", author_association)
            } else {
                String::new()
            },
            if let Some(lock_reason) = &self.lock_reason {
                format!("{:?}", lock_reason)
            } else {
                String::new()
            },
            if let Some(performed_via_github_app) = &self.performed_via_github_app {
                format!("{:?}", performed_via_github_app)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "issue".to_string(),
            "label".to_string(),
            "assignee".to_string(),
            "assigner".to_string(),
            "review_requester".to_string(),
            "requested_reviewer".to_string(),
            "requested_team".to_string(),
            "dismissed_review".to_string(),
            "milestone".to_string(),
            "project_card".to_string(),
            "rename".to_string(),
            "author_association".to_string(),
            "lock_reason".to_string(),
            "performed_via_github_app".to_string(),
        ]
    }
}

#[doc = "Labeled Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct LabeledIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    pub label: Label,
}

impl std::fmt::Display for LabeledIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for LabeledIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.label),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "label".to_string(),
        ]
    }
}

#[doc = "Unlabeled Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnlabeledIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    pub label: Label,
}

impl std::fmt::Display for UnlabeledIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UnlabeledIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.label),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "label".to_string(),
        ]
    }
}

#[doc = "Assigned Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AssignedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    pub performed_via_github_app: Integration,
    #[doc = "Simple User"]
    pub assignee: SimpleUser,
    #[doc = "Simple User"]
    pub assigner: SimpleUser,
}

impl std::fmt::Display for AssignedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for AssignedIssueEvent {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.assignee),
            format!("{:?}", self.assigner),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "assignee".to_string(),
            "assigner".to_string(),
        ]
    }
}

#[doc = "Unassigned Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnassignedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[doc = "Simple User"]
    pub assignee: SimpleUser,
    #[doc = "Simple User"]
    pub assigner: SimpleUser,
}

impl std::fmt::Display for UnassignedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UnassignedIssueEvent {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.assignee),
            format!("{:?}", self.assigner),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "assignee".to_string(),
            "assigner".to_string(),
        ]
    }
}

#[doc = "Milestoned Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MilestonedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    pub milestone: Milestone,
}

impl std::fmt::Display for MilestonedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MilestonedIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.milestone),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "milestone".to_string(),
        ]
    }
}

#[doc = "Demilestoned Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DemilestonedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    pub milestone: Milestone,
}

impl std::fmt::Display for DemilestonedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DemilestonedIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.milestone),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "milestone".to_string(),
        ]
    }
}

#[doc = "Renamed Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RenamedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    pub rename: Rename,
}

impl std::fmt::Display for RenamedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RenamedIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.rename),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "rename".to_string(),
        ]
    }
}

#[doc = "Review Requested Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReviewRequestedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[doc = "Simple User"]
    pub review_requester: SimpleUser,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_team: Option<Team>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_reviewer: Option<SimpleUser>,
}

impl std::fmt::Display for ReviewRequestedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReviewRequestedIssueEvent {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.review_requester),
            if let Some(requested_team) = &self.requested_team {
                format!("{:?}", requested_team)
            } else {
                String::new()
            },
            if let Some(requested_reviewer) = &self.requested_reviewer {
                format!("{:?}", requested_reviewer)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "review_requester".to_string(),
            "requested_team".to_string(),
            "requested_reviewer".to_string(),
        ]
    }
}

#[doc = "Review Request Removed Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReviewRequestRemovedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[doc = "Simple User"]
    pub review_requester: SimpleUser,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_team: Option<Team>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_reviewer: Option<SimpleUser>,
}

impl std::fmt::Display for ReviewRequestRemovedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReviewRequestRemovedIssueEvent {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.review_requester),
            if let Some(requested_team) = &self.requested_team {
                format!("{:?}", requested_team)
            } else {
                String::new()
            },
            if let Some(requested_reviewer) = &self.requested_reviewer {
                format!("{:?}", requested_reviewer)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "review_requester".to_string(),
            "requested_team".to_string(),
            "requested_reviewer".to_string(),
        ]
    }
}

#[doc = "Review Dismissed Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReviewDismissedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    pub dismissed_review: DismissedReview,
}

impl std::fmt::Display for ReviewDismissedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReviewDismissedIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.dismissed_review),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "dismissed_review".to_string(),
        ]
    }
}

#[doc = "Locked Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct LockedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lock_reason: Option<String>,
}

impl std::fmt::Display for LockedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for LockedIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.lock_reason),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "lock_reason".to_string(),
        ]
    }
}

#[doc = "Added to Project Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AddedToProjectIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_card: Option<ProjectCard>,
}

impl std::fmt::Display for AddedToProjectIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for AddedToProjectIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            if let Some(project_card) = &self.project_card {
                format!("{:?}", project_card)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "project_card".to_string(),
        ]
    }
}

#[doc = "Moved Column in Project Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MovedColumnInProjectIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_card: Option<ProjectCard>,
}

impl std::fmt::Display for MovedColumnInProjectIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MovedColumnInProjectIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            if let Some(project_card) = &self.project_card {
                format!("{:?}", project_card)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "project_card".to_string(),
        ]
    }
}

#[doc = "Removed from Project Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RemovedFromProjectIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_card: Option<ProjectCard>,
}

impl std::fmt::Display for RemovedFromProjectIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RemovedFromProjectIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            if let Some(project_card) = &self.project_card {
                format!("{:?}", project_card)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "project_card".to_string(),
        ]
    }
}

#[doc = "Converted Note to Issue Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ConvertedNoteToIssueIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    pub performed_via_github_app: Integration,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_card: Option<ProjectCard>,
}

impl std::fmt::Display for ConvertedNoteToIssueIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ConvertedNoteToIssueIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            if let Some(project_card) = &self.project_card {
                format!("{:?}", project_card)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "project_card".to_string(),
        ]
    }
}

#[doc = "Issue Event for Issue"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueEventForIssue {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub event: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<Integration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<SimpleUser>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assigner: Option<SimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rename: Option<Rename>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub review_requester: Option<SimpleUser>,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_team: Option<Team>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_reviewer: Option<SimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_review: Option<DismissedReview>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lock_reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_card: Option<ProjectCard>,
}

impl std::fmt::Display for IssueEventForIssue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueEventForIssue {
    const LENGTH: usize = 20;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(node_id) = &self.node_id {
                format!("{:?}", node_id)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(actor) = &self.actor {
                format!("{:?}", actor)
            } else {
                String::new()
            },
            if let Some(event) = &self.event {
                format!("{:?}", event)
            } else {
                String::new()
            },
            if let Some(commit_id) = &self.commit_id {
                format!("{:?}", commit_id)
            } else {
                String::new()
            },
            if let Some(commit_url) = &self.commit_url {
                format!("{:?}", commit_url)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
            if let Some(performed_via_github_app) = &self.performed_via_github_app {
                format!("{:?}", performed_via_github_app)
            } else {
                String::new()
            },
            if let Some(label) = &self.label {
                format!("{:?}", label)
            } else {
                String::new()
            },
            if let Some(assignee) = &self.assignee {
                format!("{:?}", assignee)
            } else {
                String::new()
            },
            if let Some(assigner) = &self.assigner {
                format!("{:?}", assigner)
            } else {
                String::new()
            },
            if let Some(milestone) = &self.milestone {
                format!("{:?}", milestone)
            } else {
                String::new()
            },
            if let Some(rename) = &self.rename {
                format!("{:?}", rename)
            } else {
                String::new()
            },
            if let Some(review_requester) = &self.review_requester {
                format!("{:?}", review_requester)
            } else {
                String::new()
            },
            if let Some(requested_team) = &self.requested_team {
                format!("{:?}", requested_team)
            } else {
                String::new()
            },
            if let Some(requested_reviewer) = &self.requested_reviewer {
                format!("{:?}", requested_reviewer)
            } else {
                String::new()
            },
            if let Some(dismissed_review) = &self.dismissed_review {
                format!("{:?}", dismissed_review)
            } else {
                String::new()
            },
            if let Some(lock_reason) = &self.lock_reason {
                format!("{:?}", lock_reason)
            } else {
                String::new()
            },
            if let Some(project_card) = &self.project_card {
                format!("{:?}", project_card)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "label".to_string(),
            "assignee".to_string(),
            "assigner".to_string(),
            "milestone".to_string(),
            "rename".to_string(),
            "review_requester".to_string(),
            "requested_team".to_string(),
            "requested_reviewer".to_string(),
            "dismissed_review".to_string(),
            "lock_reason".to_string(),
            "project_card".to_string(),
        ]
    }
}

#[doc = "Color-coded labels help you categorize and filter your issues (just like labels in Gmail)."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Label {
    pub id: i64,
    pub node_id: String,
    #[doc = "URL for the label"]
    pub url: url::Url,
    #[doc = "The name of the label."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "6-character hex code, without the leading #, identifying the color"]
    pub color: String,
    pub default: bool,
}

impl std::fmt::Display for Label {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Label {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            self.name.clone(),
            format!("{:?}", self.description),
            self.color.clone(),
            format!("{:?}", self.default),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "name".to_string(),
            "description".to_string(),
            "color".to_string(),
            "default".to_string(),
        ]
    }
}

#[doc = "Timeline Comment Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimelineCommentEvent {
    pub event: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    #[doc = "Unique identifier of the issue comment"]
    pub id: i64,
    pub node_id: String,
    #[doc = "URL for the issue comment"]
    pub url: url::Url,
    #[doc = "Contents of the issue comment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    pub html_url: url::Url,
    #[doc = "Simple User"]
    pub user: SimpleUser,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub issue_url: url::Url,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

impl std::fmt::Display for TimelineCommentEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TimelineCommentEvent {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            self.event.clone(),
            format!("{:?}", self.actor),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            if let Some(body) = &self.body {
                format!("{:?}", body)
            } else {
                String::new()
            },
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            format!("{:?}", self.html_url),
            format!("{:?}", self.user),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.issue_url),
            format!("{:?}", self.author_association),
            if let Some(performed_via_github_app) = &self.performed_via_github_app {
                format!("{:?}", performed_via_github_app)
            } else {
                String::new()
            },
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "event".to_string(),
            "actor".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "body".to_string(),
            "body_text".to_string(),
            "body_html".to_string(),
            "html_url".to_string(),
            "user".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "issue_url".to_string(),
            "author_association".to_string(),
            "performed_via_github_app".to_string(),
            "reactions".to_string(),
        ]
    }
}

#[doc = "Timeline Cross Referenced Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimelineCrossReferencedEvent {
    pub event: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actor: Option<SimpleUser>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub source: Source,
}

impl std::fmt::Display for TimelineCrossReferencedEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TimelineCrossReferencedEvent {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            self.event.clone(),
            if let Some(actor) = &self.actor {
                format!("{:?}", actor)
            } else {
                String::new()
            },
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.source),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "event".to_string(),
            "actor".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "source".to_string(),
        ]
    }
}

#[doc = "Timeline Committed Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimelineCommittedEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub event: Option<String>,
    #[doc = "SHA for the commit"]
    pub sha: String,
    pub node_id: String,
    pub url: url::Url,
    #[doc = "Identifying information for the git-user"]
    pub author: Author,
    #[doc = "Identifying information for the git-user"]
    pub committer: Committer,
    #[doc = "Message describing the purpose of the commit"]
    pub message: String,
    pub tree: Tree,
    pub parents: Vec<Parents>,
    pub verification: Verification,
    pub html_url: url::Url,
}

impl std::fmt::Display for TimelineCommittedEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TimelineCommittedEvent {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(event) = &self.event {
                format!("{:?}", event)
            } else {
                String::new()
            },
            self.sha.clone(),
            self.node_id.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.author),
            format!("{:?}", self.committer),
            self.message.clone(),
            format!("{:?}", self.tree),
            format!("{:?}", self.parents),
            format!("{:?}", self.verification),
            format!("{:?}", self.html_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "event".to_string(),
            "sha".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "author".to_string(),
            "committer".to_string(),
            "message".to_string(),
            "tree".to_string(),
            "parents".to_string(),
            "verification".to_string(),
            "html_url".to_string(),
        ]
    }
}

#[doc = "Timeline Reviewed Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimelineReviewedEvent {
    pub event: String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    pub node_id: String,
    #[doc = "Simple User"]
    pub user: SimpleUser,
    #[doc = "The text of the review."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    pub state: String,
    pub html_url: url::Url,
    pub pull_request_url: url::Url,
    #[serde(rename = "_links")]
    pub links: Links,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub submitted_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
}

impl std::fmt::Display for TimelineReviewedEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TimelineReviewedEvent {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            self.event.clone(),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.user),
            format!("{:?}", self.body),
            self.state.clone(),
            format!("{:?}", self.html_url),
            format!("{:?}", self.pull_request_url),
            format!("{:?}", self.links),
            if let Some(submitted_at) = &self.submitted_at {
                format!("{:?}", submitted_at)
            } else {
                String::new()
            },
            self.commit_id.clone(),
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
            format!("{:?}", self.author_association),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "event".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "user".to_string(),
            "body".to_string(),
            "state".to_string(),
            "html_url".to_string(),
            "pull_request_url".to_string(),
            "links".to_string(),
            "submitted_at".to_string(),
            "commit_id".to_string(),
            "body_html".to_string(),
            "body_text".to_string(),
            "author_association".to_string(),
        ]
    }
}

#[doc = "Pull Request Review Comments are comments on a portion of the Pull Request's diff."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReviewComment {
    #[doc = "URL for the pull request review comment"]
    pub url: String,
    #[doc = "The ID of the pull request review to which the comment belongs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request_review_id: Option<i64>,
    #[doc = "The ID of the pull request review comment."]
    pub id: i64,
    #[doc = "The node ID of the pull request review comment."]
    pub node_id: String,
    #[doc = "The diff of the line that the comment refers to."]
    pub diff_hunk: String,
    #[doc = "The relative path of the file to which the comment applies."]
    pub path: String,
    #[doc = "The line index in the diff to which the comment applies. This field is deprecated; use `line` instead."]
    pub position: i64,
    #[doc = "The index of the original line in the diff to which the comment applies. This field is deprecated; use `original_line` instead."]
    pub original_position: i64,
    #[doc = "The SHA of the commit to which the comment applies."]
    pub commit_id: String,
    #[doc = "The SHA of the original commit to which the comment applies."]
    pub original_commit_id: String,
    #[doc = "The comment ID to reply to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub in_reply_to_id: Option<i64>,
    #[doc = "Simple User"]
    pub user: SimpleUser,
    #[doc = "The text of the comment."]
    pub body: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "HTML URL for the pull request review comment."]
    pub html_url: url::Url,
    #[doc = "URL for the pull request that the review comment belongs to."]
    pub pull_request_url: url::Url,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[serde(rename = "_links")]
    pub links: Links,
    #[doc = "The first line of the range for a multi-line comment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
    #[doc = "The first line of the range for a multi-line comment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub original_start_line: Option<i64>,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_side: Option<StartSide>,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub line: Option<i64>,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub original_line: Option<i64>,
    #[doc = "The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub side: Option<Side>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
}

impl std::fmt::Display for PullRequestReviewComment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReviewComment {
    const LENGTH: usize = 28;
    fn fields(&self) -> Vec<String> {
        vec![
            self.url.clone(),
            format!("{:?}", self.pull_request_review_id),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.diff_hunk.clone(),
            self.path.clone(),
            format!("{:?}", self.position),
            format!("{:?}", self.original_position),
            self.commit_id.clone(),
            self.original_commit_id.clone(),
            if let Some(in_reply_to_id) = &self.in_reply_to_id {
                format!("{:?}", in_reply_to_id)
            } else {
                String::new()
            },
            format!("{:?}", self.user),
            self.body.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.html_url),
            format!("{:?}", self.pull_request_url),
            format!("{:?}", self.author_association),
            format!("{:?}", self.links),
            if let Some(start_line) = &self.start_line {
                format!("{:?}", start_line)
            } else {
                String::new()
            },
            if let Some(original_start_line) = &self.original_start_line {
                format!("{:?}", original_start_line)
            } else {
                String::new()
            },
            if let Some(start_side) = &self.start_side {
                format!("{:?}", start_side)
            } else {
                String::new()
            },
            if let Some(line) = &self.line {
                format!("{:?}", line)
            } else {
                String::new()
            },
            if let Some(original_line) = &self.original_line {
                format!("{:?}", original_line)
            } else {
                String::new()
            },
            if let Some(side) = &self.side {
                format!("{:?}", side)
            } else {
                String::new()
            },
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "pull_request_review_id".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "diff_hunk".to_string(),
            "path".to_string(),
            "position".to_string(),
            "original_position".to_string(),
            "commit_id".to_string(),
            "original_commit_id".to_string(),
            "in_reply_to_id".to_string(),
            "user".to_string(),
            "body".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "html_url".to_string(),
            "pull_request_url".to_string(),
            "author_association".to_string(),
            "links".to_string(),
            "start_line".to_string(),
            "original_start_line".to_string(),
            "start_side".to_string(),
            "line".to_string(),
            "original_line".to_string(),
            "side".to_string(),
            "reactions".to_string(),
            "body_html".to_string(),
            "body_text".to_string(),
        ]
    }
}

#[doc = "Timeline Line Commented Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimelineLineCommentedEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub event: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comments: Option<Vec<PullRequestReviewComment>>,
}

impl std::fmt::Display for TimelineLineCommentedEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TimelineLineCommentedEvent {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(event) = &self.event {
                format!("{:?}", event)
            } else {
                String::new()
            },
            if let Some(node_id) = &self.node_id {
                format!("{:?}", node_id)
            } else {
                String::new()
            },
            if let Some(comments) = &self.comments {
                format!("{:?}", comments)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "event".to_string(),
            "node_id".to_string(),
            "comments".to_string(),
        ]
    }
}

#[doc = "Timeline Commit Commented Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimelineCommitCommentedEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub event: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comments: Option<Vec<CommitComment>>,
}

impl std::fmt::Display for TimelineCommitCommentedEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TimelineCommitCommentedEvent {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(event) = &self.event {
                format!("{:?}", event)
            } else {
                String::new()
            },
            if let Some(node_id) = &self.node_id {
                format!("{:?}", node_id)
            } else {
                String::new()
            },
            if let Some(commit_id) = &self.commit_id {
                format!("{:?}", commit_id)
            } else {
                String::new()
            },
            if let Some(comments) = &self.comments {
                format!("{:?}", comments)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "event".to_string(),
            "node_id".to_string(),
            "commit_id".to_string(),
            "comments".to_string(),
        ]
    }
}

#[doc = "Timeline Assigned Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimelineAssignedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[doc = "Simple User"]
    pub assignee: SimpleUser,
}

impl std::fmt::Display for TimelineAssignedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TimelineAssignedIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.assignee),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "assignee".to_string(),
        ]
    }
}

#[doc = "Timeline Unassigned Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimelineUnassignedIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[doc = "Simple User"]
    pub assignee: SimpleUser,
}

impl std::fmt::Display for TimelineUnassignedIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TimelineUnassignedIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            format!("{:?}", self.assignee),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "assignee".to_string(),
        ]
    }
}

#[doc = "State Change Issue Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct StateChangeIssueEvent {
    pub id: i64,
    pub node_id: String,
    pub url: String,
    #[doc = "Simple User"]
    pub actor: SimpleUser,
    pub event: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_url: Option<String>,
    pub created_at: String,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state_reason: Option<String>,
}

impl std::fmt::Display for StateChangeIssueEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for StateChangeIssueEvent {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.url.clone(),
            format!("{:?}", self.actor),
            self.event.clone(),
            format!("{:?}", self.commit_id),
            format!("{:?}", self.commit_url),
            self.created_at.clone(),
            format!("{:?}", self.performed_via_github_app),
            if let Some(state_reason) = &self.state_reason {
                format!("{:?}", state_reason)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "actor".to_string(),
            "event".to_string(),
            "commit_id".to_string(),
            "commit_url".to_string(),
            "created_at".to_string(),
            "performed_via_github_app".to_string(),
            "state_reason".to_string(),
        ]
    }
}

#[doc = "Timeline Event"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimelineIssueEvents {}

impl std::fmt::Display for TimelineIssueEvents {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TimelineIssueEvents {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<String> {
        vec![]
    }

    fn headers() -> Vec<String> {
        vec![]
    }
}

#[doc = "An SSH key granting access to a single repository."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeployKey {
    pub id: i64,
    pub key: String,
    pub url: String,
    pub title: String,
    pub verified: bool,
    pub created_at: String,
    pub read_only: bool,
}

impl std::fmt::Display for DeployKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeployKey {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.key.clone(),
            self.url.clone(),
            self.title.clone(),
            format!("{:?}", self.verified),
            self.created_at.clone(),
            format!("{:?}", self.read_only),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "key".to_string(),
            "url".to_string(),
            "title".to_string(),
            "verified".to_string(),
            "created_at".to_string(),
            "read_only".to_string(),
        ]
    }
}

#[doc = "License Content"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct LicenseContent {
    pub name: String,
    pub path: String,
    pub sha: String,
    pub size: i64,
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub download_url: Option<url::Url>,
    #[serde(rename = "type")]
    pub type_: String,
    pub content: String,
    pub encoding: String,
    #[serde(rename = "_links")]
    pub links: Links,
    #[doc = "License Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
}

impl std::fmt::Display for LicenseContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for LicenseContent {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            self.path.clone(),
            self.sha.clone(),
            format!("{:?}", self.size),
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.git_url),
            format!("{:?}", self.download_url),
            self.type_.clone(),
            self.content.clone(),
            self.encoding.clone(),
            format!("{:?}", self.links),
            format!("{:?}", self.license),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "path".to_string(),
            "sha".to_string(),
            "size".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "git_url".to_string(),
            "download_url".to_string(),
            "type_".to_string(),
            "content".to_string(),
            "encoding".to_string(),
            "links".to_string(),
            "license".to_string(),
        ]
    }
}

#[doc = "Results of a successful merge upstream request"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MergedUpstream {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub merge_type: Option<MergeType>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub base_branch: Option<String>,
}

impl std::fmt::Display for MergedUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MergedUpstream {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(message) = &self.message {
                format!("{:?}", message)
            } else {
                String::new()
            },
            if let Some(merge_type) = &self.merge_type {
                format!("{:?}", merge_type)
            } else {
                String::new()
            },
            if let Some(base_branch) = &self.base_branch {
                format!("{:?}", base_branch)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "message".to_string(),
            "merge_type".to_string(),
            "base_branch".to_string(),
        ]
    }
}

#[doc = "A collection of related issues and pull requests."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Milestone {
    pub url: url::Url,
    pub html_url: url::Url,
    pub labels_url: url::Url,
    pub id: i64,
    pub node_id: String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    #[doc = "The state of the milestone."]
    pub state: State,
    #[doc = "The title of the milestone."]
    pub title: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
    pub open_issues: i64,
    pub closed_issues: i64,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub due_on: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for Milestone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Milestone {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.labels_url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.number),
            format!("{:?}", self.state),
            self.title.clone(),
            format!("{:?}", self.description),
            format!("{:?}", self.creator),
            format!("{:?}", self.open_issues),
            format!("{:?}", self.closed_issues),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.closed_at),
            format!("{:?}", self.due_on),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "html_url".to_string(),
            "labels_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "number".to_string(),
            "state".to_string(),
            "title".to_string(),
            "description".to_string(),
            "creator".to_string(),
            "open_issues".to_string(),
            "closed_issues".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "closed_at".to_string(),
            "due_on".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PagesSourceHash {
    pub branch: String,
    pub path: String,
}

impl std::fmt::Display for PagesSourceHash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PagesSourceHash {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.branch.clone(), self.path.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["branch".to_string(), "path".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PagesHttpsCertificate {
    pub state: State,
    pub description: String,
    #[doc = "Array of the domain set and its alternate name (if it is configured)"]
    pub domains: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<chrono::NaiveDate>,
}

impl std::fmt::Display for PagesHttpsCertificate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PagesHttpsCertificate {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.state),
            self.description.clone(),
            format!("{:?}", self.domains),
            if let Some(expires_at) = &self.expires_at {
                format!("{:?}", expires_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "state".to_string(),
            "description".to_string(),
            "domains".to_string(),
            "expires_at".to_string(),
        ]
    }
}

#[doc = "The configuration for GitHub Pages for a repository."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Page {
    #[doc = "The API address for accessing this Page resource."]
    pub url: url::Url,
    #[doc = "The status of the most recent build of the Page."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<Status>,
    #[doc = "The Pages site's custom domain"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cname: Option<String>,
    #[doc = "The state if the domain is verified"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protected_domain_state: Option<ProtectedDomainState>,
    #[doc = "The timestamp when a pending domain becomes unverified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pending_domain_unverified_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Whether the Page has a custom 404 page."]
    pub custom_404: bool,
    #[doc = "The web address the Page can be accessed from."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[doc = "The process in which the Page will be built."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub build_type: Option<BuildType>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<PagesSourceHash>,
    #[doc = "Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site."]
    pub public: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub https_certificate: Option<PagesHttpsCertificate>,
    #[doc = "Whether https is enabled on the domain"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub https_enforced: Option<bool>,
}

impl std::fmt::Display for Page {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Page {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.status),
            format!("{:?}", self.cname),
            if let Some(protected_domain_state) = &self.protected_domain_state {
                format!("{:?}", protected_domain_state)
            } else {
                String::new()
            },
            if let Some(pending_domain_unverified_at) = &self.pending_domain_unverified_at {
                format!("{:?}", pending_domain_unverified_at)
            } else {
                String::new()
            },
            format!("{:?}", self.custom_404),
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
            if let Some(build_type) = &self.build_type {
                format!("{:?}", build_type)
            } else {
                String::new()
            },
            if let Some(source) = &self.source {
                format!("{:?}", source)
            } else {
                String::new()
            },
            format!("{:?}", self.public),
            if let Some(https_certificate) = &self.https_certificate {
                format!("{:?}", https_certificate)
            } else {
                String::new()
            },
            if let Some(https_enforced) = &self.https_enforced {
                format!("{:?}", https_enforced)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "status".to_string(),
            "cname".to_string(),
            "protected_domain_state".to_string(),
            "pending_domain_unverified_at".to_string(),
            "custom_404".to_string(),
            "html_url".to_string(),
            "build_type".to_string(),
            "source".to_string(),
            "public".to_string(),
            "https_certificate".to_string(),
            "https_enforced".to_string(),
        ]
    }
}

#[doc = "Page Build"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PageBuild {
    pub url: url::Url,
    pub status: String,
    pub error: Error,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pusher: Option<NullableSimpleUser>,
    pub commit: String,
    pub duration: i64,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for PageBuild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PageBuild {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            self.status.clone(),
            format!("{:?}", self.error),
            format!("{:?}", self.pusher),
            self.commit.clone(),
            format!("{:?}", self.duration),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "status".to_string(),
            "error".to_string(),
            "pusher".to_string(),
            "commit".to_string(),
            "duration".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
        ]
    }
}

#[doc = "Page Build Status"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PageBuildStatus {
    pub url: url::Url,
    pub status: String,
}

impl std::fmt::Display for PageBuildStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PageBuildStatus {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.url), self.status.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["url".to_string(), "status".to_string()]
    }
}

#[doc = "The GitHub Pages deployment status."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PageDeployment {
    #[doc = "The URI to monitor GitHub Pages deployment status."]
    pub status_url: url::Url,
    #[doc = "The URI to the deployed GitHub Pages."]
    pub page_url: url::Url,
    #[doc = "The URI to the deployed GitHub Pages preview."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preview_url: Option<url::Url>,
}

impl std::fmt::Display for PageDeployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PageDeployment {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.status_url),
            format!("{:?}", self.page_url),
            if let Some(preview_url) = &self.preview_url {
                format!("{:?}", preview_url)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "status_url".to_string(),
            "page_url".to_string(),
            "preview_url".to_string(),
        ]
    }
}

#[doc = "Pages Health Check Status"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PagesHealthCheck {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<Domain>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alt_domain: Option<AltDomain>,
}

impl std::fmt::Display for PagesHealthCheck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PagesHealthCheck {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(domain) = &self.domain {
                format!("{:?}", domain)
            } else {
                String::new()
            },
            if let Some(alt_domain) = &self.alt_domain {
                format!("{:?}", alt_domain)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["domain".to_string(), "alt_domain".to_string()]
    }
}

#[doc = "Groups of organization members that gives permissions on specified repositories."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamSimple {
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub node_id: String,
    #[doc = "URL for the team"]
    pub url: url::Url,
    pub members_url: String,
    #[doc = "Name of the team"]
    pub name: String,
    #[doc = "Description of the team"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: String,
    #[doc = "The level of privacy this team should have"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privacy: Option<String>,
    pub html_url: url::Url,
    pub repositories_url: url::Url,
    pub slug: String,
    #[doc = "Distinguished Name (DN) that team maps to within LDAP environment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ldap_dn: Option<String>,
}

impl std::fmt::Display for TeamSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamSimple {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            self.members_url.clone(),
            self.name.clone(),
            format!("{:?}", self.description),
            self.permission.clone(),
            if let Some(privacy) = &self.privacy {
                format!("{:?}", privacy)
            } else {
                String::new()
            },
            format!("{:?}", self.html_url),
            format!("{:?}", self.repositories_url),
            self.slug.clone(),
            if let Some(ldap_dn) = &self.ldap_dn {
                format!("{:?}", ldap_dn)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "members_url".to_string(),
            "name".to_string(),
            "description".to_string(),
            "permission".to_string(),
            "privacy".to_string(),
            "html_url".to_string(),
            "repositories_url".to_string(),
            "slug".to_string(),
            "ldap_dn".to_string(),
        ]
    }
}

#[doc = "Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequest {
    pub url: url::Url,
    pub id: i64,
    pub node_id: String,
    pub html_url: url::Url,
    pub diff_url: url::Url,
    pub patch_url: url::Url,
    pub issue_url: url::Url,
    pub commits_url: url::Url,
    pub review_comments_url: url::Url,
    pub review_comment_url: String,
    pub comments_url: url::Url,
    pub statuses_url: url::Url,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    #[doc = "State of this Pull Request. Either `open` or `closed`."]
    pub state: State,
    pub locked: bool,
    #[doc = "The title of the pull request."]
    pub title: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    pub labels: Vec<Labels>,
    #[doc = "A collection of related issues and pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub milestone: Option<NullableMilestone>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active_lock_reason: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignees: Option<Vec<SimpleUser>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_reviewers: Option<Vec<SimpleUser>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_teams: Option<Vec<TeamSimple>>,
    pub head: Head,
    pub base: Base,
    #[serde(rename = "_links")]
    pub links: Links,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[doc = "The status of auto merging a pull request."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auto_merge: Option<AutoMerge>,
    #[doc = "Indicates whether or not the pull request is a draft."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    pub merged: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rebaseable: Option<bool>,
    pub mergeable_state: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub merged_by: Option<NullableSimpleUser>,
    pub comments: i64,
    pub review_comments: i64,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub commits: i64,
    pub additions: i64,
    pub deletions: i64,
    pub changed_files: i64,
}

impl std::fmt::Display for PullRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequest {
    const LENGTH: usize = 48;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.html_url),
            format!("{:?}", self.diff_url),
            format!("{:?}", self.patch_url),
            format!("{:?}", self.issue_url),
            format!("{:?}", self.commits_url),
            format!("{:?}", self.review_comments_url),
            self.review_comment_url.clone(),
            format!("{:?}", self.comments_url),
            format!("{:?}", self.statuses_url),
            format!("{:?}", self.number),
            format!("{:?}", self.state),
            format!("{:?}", self.locked),
            self.title.clone(),
            format!("{:?}", self.user),
            format!("{:?}", self.body),
            format!("{:?}", self.labels),
            format!("{:?}", self.milestone),
            if let Some(active_lock_reason) = &self.active_lock_reason {
                format!("{:?}", active_lock_reason)
            } else {
                String::new()
            },
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.closed_at),
            format!("{:?}", self.merged_at),
            format!("{:?}", self.merge_commit_sha),
            format!("{:?}", self.assignee),
            if let Some(assignees) = &self.assignees {
                format!("{:?}", assignees)
            } else {
                String::new()
            },
            if let Some(requested_reviewers) = &self.requested_reviewers {
                format!("{:?}", requested_reviewers)
            } else {
                String::new()
            },
            if let Some(requested_teams) = &self.requested_teams {
                format!("{:?}", requested_teams)
            } else {
                String::new()
            },
            format!("{:?}", self.head),
            format!("{:?}", self.base),
            format!("{:?}", self.links),
            format!("{:?}", self.author_association),
            format!("{:?}", self.auto_merge),
            if let Some(draft) = &self.draft {
                format!("{:?}", draft)
            } else {
                String::new()
            },
            format!("{:?}", self.merged),
            format!("{:?}", self.mergeable),
            if let Some(rebaseable) = &self.rebaseable {
                format!("{:?}", rebaseable)
            } else {
                String::new()
            },
            self.mergeable_state.clone(),
            format!("{:?}", self.merged_by),
            format!("{:?}", self.comments),
            format!("{:?}", self.review_comments),
            format!("{:?}", self.maintainer_can_modify),
            format!("{:?}", self.commits),
            format!("{:?}", self.additions),
            format!("{:?}", self.deletions),
            format!("{:?}", self.changed_files),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "html_url".to_string(),
            "diff_url".to_string(),
            "patch_url".to_string(),
            "issue_url".to_string(),
            "commits_url".to_string(),
            "review_comments_url".to_string(),
            "review_comment_url".to_string(),
            "comments_url".to_string(),
            "statuses_url".to_string(),
            "number".to_string(),
            "state".to_string(),
            "locked".to_string(),
            "title".to_string(),
            "user".to_string(),
            "body".to_string(),
            "labels".to_string(),
            "milestone".to_string(),
            "active_lock_reason".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "closed_at".to_string(),
            "merged_at".to_string(),
            "merge_commit_sha".to_string(),
            "assignee".to_string(),
            "assignees".to_string(),
            "requested_reviewers".to_string(),
            "requested_teams".to_string(),
            "head".to_string(),
            "base".to_string(),
            "links".to_string(),
            "author_association".to_string(),
            "auto_merge".to_string(),
            "draft".to_string(),
            "merged".to_string(),
            "mergeable".to_string(),
            "rebaseable".to_string(),
            "mergeable_state".to_string(),
            "merged_by".to_string(),
            "comments".to_string(),
            "review_comments".to_string(),
            "maintainer_can_modify".to_string(),
            "commits".to_string(),
            "additions".to_string(),
            "deletions".to_string(),
            "changed_files".to_string(),
        ]
    }
}

#[doc = "Pull Request Merge Result"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestMergeResult {
    pub sha: String,
    pub merged: bool,
    pub message: String,
}

impl std::fmt::Display for PullRequestMergeResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestMergeResult {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.sha.clone(),
            format!("{:?}", self.merged),
            self.message.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sha".to_string(),
            "merged".to_string(),
            "message".to_string(),
        ]
    }
}

#[doc = "Pull Request Review Request"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReviewRequest {
    pub users: Vec<SimpleUser>,
    pub teams: Vec<Team>,
}

impl std::fmt::Display for PullRequestReviewRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReviewRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.users), format!("{:?}", self.teams)]
    }

    fn headers() -> Vec<String> {
        vec!["users".to_string(), "teams".to_string()]
    }
}

#[doc = "Pull Request Reviews are reviews on pull requests."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReview {
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    pub node_id: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[doc = "The text of the review."]
    pub body: String,
    pub state: String,
    pub html_url: url::Url,
    pub pull_request_url: url::Url,
    #[serde(rename = "_links")]
    pub links: Links,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub submitted_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
}

impl std::fmt::Display for PullRequestReview {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReview {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.user),
            self.body.clone(),
            self.state.clone(),
            format!("{:?}", self.html_url),
            format!("{:?}", self.pull_request_url),
            format!("{:?}", self.links),
            if let Some(submitted_at) = &self.submitted_at {
                format!("{:?}", submitted_at)
            } else {
                String::new()
            },
            self.commit_id.clone(),
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
            format!("{:?}", self.author_association),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "user".to_string(),
            "body".to_string(),
            "state".to_string(),
            "html_url".to_string(),
            "pull_request_url".to_string(),
            "links".to_string(),
            "submitted_at".to_string(),
            "commit_id".to_string(),
            "body_html".to_string(),
            "body_text".to_string(),
            "author_association".to_string(),
        ]
    }
}

#[doc = "Legacy Review Comment"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReviewComment {
    pub url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request_review_id: Option<i64>,
    pub id: i64,
    pub node_id: String,
    pub diff_hunk: String,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<i64>,
    pub original_position: i64,
    pub commit_id: String,
    pub original_commit_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub in_reply_to_id: Option<i64>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    pub body: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub html_url: url::Url,
    pub pull_request_url: url::Url,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[serde(rename = "_links")]
    pub links: Links,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub side: Option<Side>,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_side: Option<StartSide>,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub line: Option<i64>,
    #[doc = "The original line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub original_line: Option<i64>,
    #[doc = "The first line of the range for a multi-line comment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
    #[doc = "The original first line of the range for a multi-line comment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub original_start_line: Option<i64>,
}

impl std::fmt::Display for ReviewComment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReviewComment {
    const LENGTH: usize = 28;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.pull_request_review_id),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.diff_hunk.clone(),
            self.path.clone(),
            format!("{:?}", self.position),
            format!("{:?}", self.original_position),
            self.commit_id.clone(),
            self.original_commit_id.clone(),
            if let Some(in_reply_to_id) = &self.in_reply_to_id {
                format!("{:?}", in_reply_to_id)
            } else {
                String::new()
            },
            format!("{:?}", self.user),
            self.body.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.html_url),
            format!("{:?}", self.pull_request_url),
            format!("{:?}", self.author_association),
            format!("{:?}", self.links),
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
            if let Some(side) = &self.side {
                format!("{:?}", side)
            } else {
                String::new()
            },
            if let Some(start_side) = &self.start_side {
                format!("{:?}", start_side)
            } else {
                String::new()
            },
            if let Some(line) = &self.line {
                format!("{:?}", line)
            } else {
                String::new()
            },
            if let Some(original_line) = &self.original_line {
                format!("{:?}", original_line)
            } else {
                String::new()
            },
            if let Some(start_line) = &self.start_line {
                format!("{:?}", start_line)
            } else {
                String::new()
            },
            if let Some(original_start_line) = &self.original_start_line {
                format!("{:?}", original_start_line)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "pull_request_review_id".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "diff_hunk".to_string(),
            "path".to_string(),
            "position".to_string(),
            "original_position".to_string(),
            "commit_id".to_string(),
            "original_commit_id".to_string(),
            "in_reply_to_id".to_string(),
            "user".to_string(),
            "body".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "html_url".to_string(),
            "pull_request_url".to_string(),
            "author_association".to_string(),
            "links".to_string(),
            "body_text".to_string(),
            "body_html".to_string(),
            "reactions".to_string(),
            "side".to_string(),
            "start_side".to_string(),
            "line".to_string(),
            "original_line".to_string(),
            "start_line".to_string(),
            "original_start_line".to_string(),
        ]
    }
}

#[doc = "Pull Request Thread Comments are comments in a thread on the Pull Request."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestThreadComment {
    #[doc = "URL for the pull request thread comment"]
    pub url: String,
    #[doc = "The ID of the pull request review to which the comment belongs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request_thread_id: Option<i64>,
    #[doc = "The ID of the pull request thread comment."]
    pub id: i64,
    #[doc = "The node ID of the pull request thread comment."]
    pub node_id: String,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[doc = "Simple User"]
    pub user: SimpleUser,
    #[doc = "The text of the comment."]
    pub body: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "HTML URL for the pull request thread comment."]
    pub html_url: url::Url,
    #[doc = "URL for the pull request that the thread comment belongs to."]
    pub pull_request_url: url::Url,
    #[doc = "URL for the thread that the thread comment belongs to."]
    pub thread_url: url::Url,
    #[serde(rename = "_links")]
    pub links: Links,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
}

impl std::fmt::Display for PullRequestThreadComment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestThreadComment {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            self.url.clone(),
            format!("{:?}", self.pull_request_thread_id),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.author_association),
            format!("{:?}", self.user),
            self.body.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.html_url),
            format!("{:?}", self.pull_request_url),
            format!("{:?}", self.thread_url),
            format!("{:?}", self.links),
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "pull_request_thread_id".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "author_association".to_string(),
            "user".to_string(),
            "body".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "html_url".to_string(),
            "pull_request_url".to_string(),
            "thread_url".to_string(),
            "links".to_string(),
            "reactions".to_string(),
            "body_html".to_string(),
            "body_text".to_string(),
        ]
    }
}

#[doc = "Data related to a release."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReleaseAsset {
    pub url: url::Url,
    pub browser_download_url: url::Url,
    pub id: i64,
    pub node_id: String,
    #[doc = "The file name of the asset."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[doc = "State of the release asset."]
    pub state: State,
    pub content_type: String,
    pub size: i64,
    pub download_count: i64,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uploader: Option<NullableSimpleUser>,
}

impl std::fmt::Display for ReleaseAsset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReleaseAsset {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.browser_download_url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            format!("{:?}", self.label),
            format!("{:?}", self.state),
            self.content_type.clone(),
            format!("{:?}", self.size),
            format!("{:?}", self.download_count),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.uploader),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "browser_download_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "label".to_string(),
            "state".to_string(),
            "content_type".to_string(),
            "size".to_string(),
            "download_count".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "uploader".to_string(),
        ]
    }
}

#[doc = "A release."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Release {
    pub url: url::Url,
    pub html_url: url::Url,
    pub assets_url: url::Url,
    pub upload_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tarball_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zipball_url: Option<url::Url>,
    pub id: i64,
    pub node_id: String,
    #[doc = "The name of the tag."]
    pub tag_name: String,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[doc = "true to create a draft (unpublished) release, false to create a published one."]
    pub draft: bool,
    #[doc = "Whether to identify the release as a prerelease or a full release."]
    pub prerelease: bool,
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub published_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Simple User"]
    pub author: SimpleUser,
    pub assets: Vec<ReleaseAsset>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mentions_count: Option<i64>,
    #[doc = "The URL of the release discussion."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discussion_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

impl std::fmt::Display for Release {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Release {
    const LENGTH: usize = 23;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.assets_url),
            self.upload_url.clone(),
            format!("{:?}", self.tarball_url),
            format!("{:?}", self.zipball_url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.tag_name.clone(),
            self.target_commitish.clone(),
            format!("{:?}", self.name),
            if let Some(body) = &self.body {
                format!("{:?}", body)
            } else {
                String::new()
            },
            format!("{:?}", self.draft),
            format!("{:?}", self.prerelease),
            format!("{:?}", self.created_at),
            format!("{:?}", self.published_at),
            format!("{:?}", self.author),
            format!("{:?}", self.assets),
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
            if let Some(mentions_count) = &self.mentions_count {
                format!("{:?}", mentions_count)
            } else {
                String::new()
            },
            if let Some(discussion_url) = &self.discussion_url {
                format!("{:?}", discussion_url)
            } else {
                String::new()
            },
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "html_url".to_string(),
            "assets_url".to_string(),
            "upload_url".to_string(),
            "tarball_url".to_string(),
            "zipball_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "tag_name".to_string(),
            "target_commitish".to_string(),
            "name".to_string(),
            "body".to_string(),
            "draft".to_string(),
            "prerelease".to_string(),
            "created_at".to_string(),
            "published_at".to_string(),
            "author".to_string(),
            "assets".to_string(),
            "body_html".to_string(),
            "body_text".to_string(),
            "mentions_count".to_string(),
            "discussion_url".to_string(),
            "reactions".to_string(),
        ]
    }
}

#[doc = "Generated name and body describing a release"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReleaseNotesContent {
    #[doc = "The generated name of the release"]
    pub name: String,
    #[doc = "The generated body describing the contents of the release supporting markdown formatting"]
    pub body: String,
}

impl std::fmt::Display for ReleaseNotesContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReleaseNotesContent {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.name.clone(), self.body.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["name".to_string(), "body".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RuntimeDeploy {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(rename = "ref", default, skip_serializing_if = "Option::is_none")]
    pub ref_: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<Status>,
}

impl std::fmt::Display for RuntimeDeploy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RuntimeDeploy {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(ref_) = &self.ref_ {
                format!("{:?}", ref_)
            } else {
                String::new()
            },
            if let Some(path) = &self.path {
                format!("{:?}", path)
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{:?}", status)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "ref_".to_string(),
            "path".to_string(),
            "status".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RuntimeDeployLogs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub streaming_log_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log_access_token: Option<String>,
}

impl std::fmt::Display for RuntimeDeployLogs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RuntimeDeployLogs {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(streaming_log_url) = &self.streaming_log_url {
                format!("{:?}", streaming_log_url)
            } else {
                String::new()
            },
            if let Some(log_access_token) = &self.log_access_token {
                format!("{:?}", log_access_token)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "streaming_log_url".to_string(),
            "log_access_token".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecretScanningAlert {
    #[doc = "The security alert number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i64>,
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The REST API URL of the alert resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<url::Url>,
    #[doc = "The GitHub URL of the alert resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<url::Url>,
    #[doc = "The REST API URL of the code locations for this alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locations_url: Option<url::Url>,
    #[doc = "Sets the state of the secret scanning alert. Can be either `open` or `resolved`. You must provide `resolution` when you set the state to `resolved`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<SecretScanningAlertState>,
    #[doc = "**Required when the `state` is `resolved`.** The reason for resolving the alert."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SecretScanningAlertResolution>,
    #[doc = "The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolved_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolved_by: Option<NullableSimpleUser>,
    #[doc = "The type of secret that secret scanning detected."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_type: Option<String>,
    #[doc = "User-friendly name for the detected secret, matching the `secret_type`.\nFor a list of built-in patterns, see \"[Secret scanning patterns](https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security).\""]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_type_display_name: Option<String>,
    #[doc = "The secret that was detected."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    #[doc = "Whether push protection was bypassed for the detected secret."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub push_protection_bypassed: Option<bool>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub push_protection_bypassed_by: Option<NullableSimpleUser>,
    #[doc = "The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub push_protection_bypassed_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for SecretScanningAlert {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecretScanningAlert {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(number) = &self.number {
                format!("{:?}", number)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(html_url) = &self.html_url {
                format!("{:?}", html_url)
            } else {
                String::new()
            },
            if let Some(locations_url) = &self.locations_url {
                format!("{:?}", locations_url)
            } else {
                String::new()
            },
            if let Some(state) = &self.state {
                format!("{:?}", state)
            } else {
                String::new()
            },
            if let Some(resolution) = &self.resolution {
                format!("{:?}", resolution)
            } else {
                String::new()
            },
            if let Some(resolved_at) = &self.resolved_at {
                format!("{:?}", resolved_at)
            } else {
                String::new()
            },
            if let Some(resolved_by) = &self.resolved_by {
                format!("{:?}", resolved_by)
            } else {
                String::new()
            },
            if let Some(secret_type) = &self.secret_type {
                format!("{:?}", secret_type)
            } else {
                String::new()
            },
            if let Some(secret_type_display_name) = &self.secret_type_display_name {
                format!("{:?}", secret_type_display_name)
            } else {
                String::new()
            },
            if let Some(secret) = &self.secret {
                format!("{:?}", secret)
            } else {
                String::new()
            },
            if let Some(push_protection_bypassed) = &self.push_protection_bypassed {
                format!("{:?}", push_protection_bypassed)
            } else {
                String::new()
            },
            if let Some(push_protection_bypassed_by) = &self.push_protection_bypassed_by {
                format!("{:?}", push_protection_bypassed_by)
            } else {
                String::new()
            },
            if let Some(push_protection_bypassed_at) = &self.push_protection_bypassed_at {
                format!("{:?}", push_protection_bypassed_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "number".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "locations_url".to_string(),
            "state".to_string(),
            "resolution".to_string(),
            "resolved_at".to_string(),
            "resolved_by".to_string(),
            "secret_type".to_string(),
            "secret_type_display_name".to_string(),
            "secret".to_string(),
            "push_protection_bypassed".to_string(),
            "push_protection_bypassed_by".to_string(),
            "push_protection_bypassed_at".to_string(),
        ]
    }
}

#[doc = "Represents a 'commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecretScanningLocationCommit {
    #[doc = "The file path in the repository"]
    pub path: String,
    #[doc = "Line number at which the secret starts in the file"]
    pub start_line: f64,
    #[doc = "Line number at which the secret ends in the file"]
    pub end_line: f64,
    #[doc = "The column at which the secret starts within the start line when the file is interpreted as 8BIT ASCII"]
    pub start_column: f64,
    #[doc = "The column at which the secret ends within the end line when the file is interpreted as 8BIT ASCII"]
    pub end_column: f64,
    #[doc = "SHA-1 hash ID of the associated blob"]
    pub blob_sha: String,
    #[doc = "The API URL to get the associated blob resource"]
    pub blob_url: String,
    #[doc = "SHA-1 hash ID of the associated commit"]
    pub commit_sha: String,
    #[doc = "The API URL to get the associated commit resource"]
    pub commit_url: String,
}

impl std::fmt::Display for SecretScanningLocationCommit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecretScanningLocationCommit {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            self.path.clone(),
            format!("{:?}", self.start_line),
            format!("{:?}", self.end_line),
            format!("{:?}", self.start_column),
            format!("{:?}", self.end_column),
            self.blob_sha.clone(),
            self.blob_url.clone(),
            self.commit_sha.clone(),
            self.commit_url.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "path".to_string(),
            "start_line".to_string(),
            "end_line".to_string(),
            "start_column".to_string(),
            "end_column".to_string(),
            "blob_sha".to_string(),
            "blob_url".to_string(),
            "commit_sha".to_string(),
            "commit_url".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecretScanningLocation {
    #[doc = "The location type. Because secrets may be found in different types of resources (ie. code, comments, issues), this field identifies the type of resource where the secret was found."]
    #[serde(rename = "type")]
    pub type_: Type,
    pub details: SecretScanningLocationCommit,
}

impl std::fmt::Display for SecretScanningLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecretScanningLocation {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.type_), format!("{:?}", self.details)]
    }

    fn headers() -> Vec<String> {
        vec!["type_".to_string(), "details".to_string()]
    }
}

#[doc = "Stargazer"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Stargazer {
    pub starred_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
}

impl std::fmt::Display for Stargazer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Stargazer {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.starred_at), format!("{:?}", self.user)]
    }

    fn headers() -> Vec<String> {
        vec!["starred_at".to_string(), "user".to_string()]
    }
}

#[doc = "Commit Activity"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CommitActivity {
    pub days: Vec<i64>,
    pub total: i64,
    pub week: i64,
}

impl std::fmt::Display for CommitActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CommitActivity {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.days),
            format!("{:?}", self.total),
            format!("{:?}", self.week),
        ]
    }

    fn headers() -> Vec<String> {
        vec!["days".to_string(), "total".to_string(), "week".to_string()]
    }
}

#[doc = "Contributor Activity"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ContributorActivity {
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub author: Option<NullableSimpleUser>,
    pub total: i64,
    pub weeks: Vec<Weeks>,
}

impl std::fmt::Display for ContributorActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ContributorActivity {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.author),
            format!("{:?}", self.total),
            format!("{:?}", self.weeks),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "author".to_string(),
            "total".to_string(),
            "weeks".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ParticipationStats {
    pub all: Vec<i64>,
    pub owner: Vec<i64>,
}

impl std::fmt::Display for ParticipationStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ParticipationStats {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.all), format!("{:?}", self.owner)]
    }

    fn headers() -> Vec<String> {
        vec!["all".to_string(), "owner".to_string()]
    }
}

#[doc = "Repository invitations let you manage who you collaborate with."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositorySubscription {
    #[doc = "Determines if notifications should be received from this repository."]
    pub subscribed: bool,
    #[doc = "Determines if all notifications should be blocked from this repository."]
    pub ignored: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub url: url::Url,
    pub repository_url: url::Url,
}

impl std::fmt::Display for RepositorySubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositorySubscription {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.subscribed),
            format!("{:?}", self.ignored),
            format!("{:?}", self.reason),
            format!("{:?}", self.created_at),
            format!("{:?}", self.url),
            format!("{:?}", self.repository_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "subscribed".to_string(),
            "ignored".to_string(),
            "reason".to_string(),
            "created_at".to_string(),
            "url".to_string(),
            "repository_url".to_string(),
        ]
    }
}

#[doc = "Tag"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Tag {
    pub name: String,
    pub commit: Commit,
    pub zipball_url: url::Url,
    pub tarball_url: url::Url,
    pub node_id: String,
}

impl std::fmt::Display for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Tag {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.commit),
            format!("{:?}", self.zipball_url),
            format!("{:?}", self.tarball_url),
            self.node_id.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "commit".to_string(),
            "zipball_url".to_string(),
            "tarball_url".to_string(),
            "node_id".to_string(),
        ]
    }
}

#[doc = "Tag protection"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TagProtection {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    pub pattern: String,
}

impl std::fmt::Display for TagProtection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TagProtection {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            if let Some(enabled) = &self.enabled {
                format!("{:?}", enabled)
            } else {
                String::new()
            },
            self.pattern.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "enabled".to_string(),
            "pattern".to_string(),
        ]
    }
}

#[doc = "A topic aggregates entities that are related to a subject."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Topic {
    pub names: Vec<String>,
}

impl std::fmt::Display for Topic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Topic {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.names)]
    }

    fn headers() -> Vec<String> {
        vec!["names".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Traffic {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub uniques: i64,
    pub count: i64,
}

impl std::fmt::Display for Traffic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Traffic {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.timestamp),
            format!("{:?}", self.uniques),
            format!("{:?}", self.count),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "timestamp".to_string(),
            "uniques".to_string(),
            "count".to_string(),
        ]
    }
}

#[doc = "Clone Traffic"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CloneTraffic {
    pub count: i64,
    pub uniques: i64,
    pub clones: Vec<Traffic>,
}

impl std::fmt::Display for CloneTraffic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CloneTraffic {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.count),
            format!("{:?}", self.uniques),
            format!("{:?}", self.clones),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "count".to_string(),
            "uniques".to_string(),
            "clones".to_string(),
        ]
    }
}

#[doc = "Content Traffic"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ContentTraffic {
    pub path: String,
    pub title: String,
    pub count: i64,
    pub uniques: i64,
}

impl std::fmt::Display for ContentTraffic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ContentTraffic {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            self.path.clone(),
            self.title.clone(),
            format!("{:?}", self.count),
            format!("{:?}", self.uniques),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "path".to_string(),
            "title".to_string(),
            "count".to_string(),
            "uniques".to_string(),
        ]
    }
}

#[doc = "Referrer Traffic"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReferrerTraffic {
    pub referrer: String,
    pub count: i64,
    pub uniques: i64,
}

impl std::fmt::Display for ReferrerTraffic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReferrerTraffic {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.referrer.clone(),
            format!("{:?}", self.count),
            format!("{:?}", self.uniques),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "referrer".to_string(),
            "count".to_string(),
            "uniques".to_string(),
        ]
    }
}

#[doc = "View Traffic"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ViewTraffic {
    pub count: i64,
    pub uniques: i64,
    pub views: Vec<Traffic>,
}

impl std::fmt::Display for ViewTraffic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ViewTraffic {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.count),
            format!("{:?}", self.uniques),
            format!("{:?}", self.views),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "count".to_string(),
            "uniques".to_string(),
            "views".to_string(),
        ]
    }
}

#[doc = "The result of kicking off an actions dynamic workflow"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ActionsDynamicWorkflowRun {
    #[doc = "The identifier for the actions workflow execution."]
    pub execution_id: String,
    #[doc = "The workflow originally passed in"]
    pub workflow: String,
    #[doc = "Minimal Repository"]
    pub repository: MinimalRepository,
}

impl std::fmt::Display for ActionsDynamicWorkflowRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ActionsDynamicWorkflowRun {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.execution_id.clone(),
            self.workflow.clone(),
            format!("{:?}", self.repository),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "execution_id".to_string(),
            "workflow".to_string(),
            "repository".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PagesResponse {
    pub status: String,
}

impl std::fmt::Display for PagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PagesResponse {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.status.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["status".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ScimGroupListEnterprise {
    pub schemas: Vec<String>,
    #[serde(rename = "totalResults")]
    pub total_results: f64,
    #[serde(rename = "itemsPerPage")]
    pub items_per_page: f64,
    #[serde(rename = "startIndex")]
    pub start_index: f64,
    #[serde(rename = "Resources")]
    pub resources: Vec<Resources>,
}

impl std::fmt::Display for ScimGroupListEnterprise {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ScimGroupListEnterprise {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.schemas),
            format!("{:?}", self.total_results),
            format!("{:?}", self.items_per_page),
            format!("{:?}", self.start_index),
            format!("{:?}", self.resources),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "schemas".to_string(),
            "total_results".to_string(),
            "items_per_page".to_string(),
            "start_index".to_string(),
            "resources".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ScimEnterpriseGroup {
    pub schemas: Vec<String>,
    pub id: String,
    #[serde(
        rename = "externalId",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub external_id: Option<String>,
    #[serde(
        rename = "displayName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub display_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<Vec<Members>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub meta: Option<Meta>,
}

impl std::fmt::Display for ScimEnterpriseGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ScimEnterpriseGroup {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.schemas),
            self.id.clone(),
            if let Some(external_id) = &self.external_id {
                format!("{:?}", external_id)
            } else {
                String::new()
            },
            if let Some(display_name) = &self.display_name {
                format!("{:?}", display_name)
            } else {
                String::new()
            },
            if let Some(members) = &self.members {
                format!("{:?}", members)
            } else {
                String::new()
            },
            if let Some(meta) = &self.meta {
                format!("{:?}", meta)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "schemas".to_string(),
            "id".to_string(),
            "external_id".to_string(),
            "display_name".to_string(),
            "members".to_string(),
            "meta".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ScimUserListEnterprise {
    pub schemas: Vec<String>,
    #[serde(rename = "totalResults")]
    pub total_results: f64,
    #[serde(rename = "itemsPerPage")]
    pub items_per_page: f64,
    #[serde(rename = "startIndex")]
    pub start_index: f64,
    #[serde(rename = "Resources")]
    pub resources: Vec<Resources>,
}

impl std::fmt::Display for ScimUserListEnterprise {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ScimUserListEnterprise {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.schemas),
            format!("{:?}", self.total_results),
            format!("{:?}", self.items_per_page),
            format!("{:?}", self.start_index),
            format!("{:?}", self.resources),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "schemas".to_string(),
            "total_results".to_string(),
            "items_per_page".to_string(),
            "start_index".to_string(),
            "resources".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ScimEnterpriseUser {
    pub schemas: Vec<String>,
    pub id: String,
    #[serde(
        rename = "externalId",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub external_id: Option<String>,
    #[serde(rename = "userName", default, skip_serializing_if = "Option::is_none")]
    pub user_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<Name>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emails: Option<Vec<Emails>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<Groups>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub meta: Option<Meta>,
}

impl std::fmt::Display for ScimEnterpriseUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ScimEnterpriseUser {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.schemas),
            self.id.clone(),
            if let Some(external_id) = &self.external_id {
                format!("{:?}", external_id)
            } else {
                String::new()
            },
            if let Some(user_name) = &self.user_name {
                format!("{:?}", user_name)
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(emails) = &self.emails {
                format!("{:?}", emails)
            } else {
                String::new()
            },
            if let Some(groups) = &self.groups {
                format!("{:?}", groups)
            } else {
                String::new()
            },
            if let Some(active) = &self.active {
                format!("{:?}", active)
            } else {
                String::new()
            },
            if let Some(meta) = &self.meta {
                format!("{:?}", meta)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "schemas".to_string(),
            "id".to_string(),
            "external_id".to_string(),
            "user_name".to_string(),
            "name".to_string(),
            "emails".to_string(),
            "groups".to_string(),
            "active".to_string(),
            "meta".to_string(),
        ]
    }
}

#[doc = "SCIM /Users provisioning endpoints"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ScimUser {
    #[doc = "SCIM schema used."]
    pub schemas: Vec<String>,
    #[doc = "Unique identifier of an external identity"]
    pub id: String,
    #[doc = "The ID of the User."]
    #[serde(
        rename = "externalId",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub external_id: Option<String>,
    #[doc = "Configured by the admin. Could be an email, login, or username"]
    #[serde(rename = "userName", default, skip_serializing_if = "Option::is_none")]
    pub user_name: Option<String>,
    #[doc = "The name of the user, suitable for display to end-users"]
    #[serde(
        rename = "displayName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub display_name: Option<String>,
    pub name: Name,
    #[doc = "user emails"]
    pub emails: Vec<Emails>,
    #[doc = "The active status of the User."]
    pub active: bool,
    pub meta: Meta,
    #[doc = "The ID of the organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_id: Option<i64>,
    #[doc = "Set of operations to be performed"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<Operations>>,
    #[doc = "associated groups"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<serde_json::Value>>,
}

impl std::fmt::Display for ScimUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ScimUser {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.schemas),
            self.id.clone(),
            format!("{:?}", self.external_id),
            format!("{:?}", self.user_name),
            if let Some(display_name) = &self.display_name {
                format!("{:?}", display_name)
            } else {
                String::new()
            },
            format!("{:?}", self.name),
            format!("{:?}", self.emails),
            format!("{:?}", self.active),
            format!("{:?}", self.meta),
            if let Some(organization_id) = &self.organization_id {
                format!("{:?}", organization_id)
            } else {
                String::new()
            },
            if let Some(operations) = &self.operations {
                format!("{:?}", operations)
            } else {
                String::new()
            },
            if let Some(groups) = &self.groups {
                format!("{:?}", groups)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "schemas".to_string(),
            "id".to_string(),
            "external_id".to_string(),
            "user_name".to_string(),
            "display_name".to_string(),
            "name".to_string(),
            "emails".to_string(),
            "active".to_string(),
            "meta".to_string(),
            "organization_id".to_string(),
            "operations".to_string(),
            "groups".to_string(),
        ]
    }
}

#[doc = "SCIM User List"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ScimUserList {
    #[doc = "SCIM schema used."]
    pub schemas: Vec<String>,
    #[serde(rename = "totalResults")]
    pub total_results: i64,
    #[serde(rename = "itemsPerPage")]
    pub items_per_page: i64,
    #[serde(rename = "startIndex")]
    pub start_index: i64,
    #[serde(rename = "Resources")]
    pub resources: Vec<ScimUser>,
}

impl std::fmt::Display for ScimUserList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ScimUserList {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.schemas),
            format!("{:?}", self.total_results),
            format!("{:?}", self.items_per_page),
            format!("{:?}", self.start_index),
            format!("{:?}", self.resources),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "schemas".to_string(),
            "total_results".to_string(),
            "items_per_page".to_string(),
            "start_index".to_string(),
            "resources".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SearchResultTextMatches {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub property: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fragment: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<Matches>>,
}

impl std::fmt::Display for SearchResultTextMatches {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SearchResultTextMatches {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(object_url) = &self.object_url {
                format!("{:?}", object_url)
            } else {
                String::new()
            },
            if let Some(object_type) = &self.object_type {
                format!("{:?}", object_type)
            } else {
                String::new()
            },
            if let Some(property) = &self.property {
                format!("{:?}", property)
            } else {
                String::new()
            },
            if let Some(fragment) = &self.fragment {
                format!("{:?}", fragment)
            } else {
                String::new()
            },
            if let Some(matches) = &self.matches {
                format!("{:?}", matches)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "object_url".to_string(),
            "object_type".to_string(),
            "property".to_string(),
            "fragment".to_string(),
            "matches".to_string(),
        ]
    }
}

#[doc = "Code Search Result Item"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeSearchResultItem {
    pub name: String,
    pub path: String,
    pub sha: String,
    pub url: url::Url,
    pub git_url: url::Url,
    pub html_url: url::Url,
    #[doc = "Minimal Repository"]
    pub repository: MinimalRepository,
    pub score: f64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub file_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_modified_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub line_numbers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text_matches: Option<Vec<SearchResultTextMatches>>,
}

impl std::fmt::Display for CodeSearchResultItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeSearchResultItem {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            self.path.clone(),
            self.sha.clone(),
            format!("{:?}", self.url),
            format!("{:?}", self.git_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.repository),
            format!("{:?}", self.score),
            if let Some(file_size) = &self.file_size {
                format!("{:?}", file_size)
            } else {
                String::new()
            },
            if let Some(language) = &self.language {
                format!("{:?}", language)
            } else {
                String::new()
            },
            if let Some(last_modified_at) = &self.last_modified_at {
                format!("{:?}", last_modified_at)
            } else {
                String::new()
            },
            if let Some(line_numbers) = &self.line_numbers {
                format!("{:?}", line_numbers)
            } else {
                String::new()
            },
            if let Some(text_matches) = &self.text_matches {
                format!("{:?}", text_matches)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "path".to_string(),
            "sha".to_string(),
            "url".to_string(),
            "git_url".to_string(),
            "html_url".to_string(),
            "repository".to_string(),
            "score".to_string(),
            "file_size".to_string(),
            "language".to_string(),
            "last_modified_at".to_string(),
            "line_numbers".to_string(),
            "text_matches".to_string(),
        ]
    }
}

#[doc = "Commit Search Result Item"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CommitSearchResultItem {
    pub url: url::Url,
    pub sha: String,
    pub html_url: url::Url,
    pub comments_url: url::Url,
    pub commit: Commit,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub author: Option<NullableSimpleUser>,
    #[doc = "Metaproperties for Git author/committer information."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub committer: Option<NullableGitUser>,
    pub parents: Vec<Parents>,
    #[doc = "Minimal Repository"]
    pub repository: MinimalRepository,
    pub score: f64,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text_matches: Option<Vec<SearchResultTextMatches>>,
}

impl std::fmt::Display for CommitSearchResultItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CommitSearchResultItem {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            self.sha.clone(),
            format!("{:?}", self.html_url),
            format!("{:?}", self.comments_url),
            format!("{:?}", self.commit),
            format!("{:?}", self.author),
            format!("{:?}", self.committer),
            format!("{:?}", self.parents),
            format!("{:?}", self.repository),
            format!("{:?}", self.score),
            self.node_id.clone(),
            if let Some(text_matches) = &self.text_matches {
                format!("{:?}", text_matches)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "sha".to_string(),
            "html_url".to_string(),
            "comments_url".to_string(),
            "commit".to_string(),
            "author".to_string(),
            "committer".to_string(),
            "parents".to_string(),
            "repository".to_string(),
            "score".to_string(),
            "node_id".to_string(),
            "text_matches".to_string(),
        ]
    }
}

#[doc = "Issue Search Result Item"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueSearchResultItem {
    pub url: url::Url,
    pub repository_url: url::Url,
    pub labels_url: String,
    pub comments_url: url::Url,
    pub events_url: url::Url,
    pub html_url: url::Url,
    pub id: i64,
    pub node_id: String,
    pub number: i64,
    pub title: String,
    pub locked: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignees: Option<Vec<SimpleUser>>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    pub labels: Vec<Labels>,
    pub state: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state_reason: Option<String>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[doc = "A collection of related issues and pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub milestone: Option<NullableMilestone>,
    pub comments: i64,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text_matches: Option<Vec<SearchResultTextMatches>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<PullRequest>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    pub score: f64,
    #[doc = "How the author is associated with the repository."]
    pub author_association: AuthorAssociation,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_html: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body_text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeline_url: Option<url::Url>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

impl std::fmt::Display for IssueSearchResultItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueSearchResultItem {
    const LENGTH: usize = 35;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.repository_url),
            self.labels_url.clone(),
            format!("{:?}", self.comments_url),
            format!("{:?}", self.events_url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.number),
            self.title.clone(),
            format!("{:?}", self.locked),
            if let Some(active_lock_reason) = &self.active_lock_reason {
                format!("{:?}", active_lock_reason)
            } else {
                String::new()
            },
            if let Some(assignees) = &self.assignees {
                format!("{:?}", assignees)
            } else {
                String::new()
            },
            format!("{:?}", self.user),
            format!("{:?}", self.labels),
            self.state.clone(),
            if let Some(state_reason) = &self.state_reason {
                format!("{:?}", state_reason)
            } else {
                String::new()
            },
            format!("{:?}", self.assignee),
            format!("{:?}", self.milestone),
            format!("{:?}", self.comments),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.closed_at),
            if let Some(text_matches) = &self.text_matches {
                format!("{:?}", text_matches)
            } else {
                String::new()
            },
            if let Some(pull_request) = &self.pull_request {
                format!("{:?}", pull_request)
            } else {
                String::new()
            },
            if let Some(body) = &self.body {
                format!("{:?}", body)
            } else {
                String::new()
            },
            format!("{:?}", self.score),
            format!("{:?}", self.author_association),
            if let Some(draft) = &self.draft {
                format!("{:?}", draft)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(body_html) = &self.body_html {
                format!("{:?}", body_html)
            } else {
                String::new()
            },
            if let Some(body_text) = &self.body_text {
                format!("{:?}", body_text)
            } else {
                String::new()
            },
            if let Some(timeline_url) = &self.timeline_url {
                format!("{:?}", timeline_url)
            } else {
                String::new()
            },
            if let Some(performed_via_github_app) = &self.performed_via_github_app {
                format!("{:?}", performed_via_github_app)
            } else {
                String::new()
            },
            if let Some(reactions) = &self.reactions {
                format!("{:?}", reactions)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "repository_url".to_string(),
            "labels_url".to_string(),
            "comments_url".to_string(),
            "events_url".to_string(),
            "html_url".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "number".to_string(),
            "title".to_string(),
            "locked".to_string(),
            "active_lock_reason".to_string(),
            "assignees".to_string(),
            "user".to_string(),
            "labels".to_string(),
            "state".to_string(),
            "state_reason".to_string(),
            "assignee".to_string(),
            "milestone".to_string(),
            "comments".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "closed_at".to_string(),
            "text_matches".to_string(),
            "pull_request".to_string(),
            "body".to_string(),
            "score".to_string(),
            "author_association".to_string(),
            "draft".to_string(),
            "repository".to_string(),
            "body_html".to_string(),
            "body_text".to_string(),
            "timeline_url".to_string(),
            "performed_via_github_app".to_string(),
            "reactions".to_string(),
        ]
    }
}

#[doc = "Label Search Result Item"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct LabelSearchResultItem {
    pub id: i64,
    pub node_id: String,
    pub url: url::Url,
    pub name: String,
    pub color: String,
    pub default: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub score: f64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text_matches: Option<Vec<SearchResultTextMatches>>,
}

impl std::fmt::Display for LabelSearchResultItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for LabelSearchResultItem {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.url),
            self.name.clone(),
            self.color.clone(),
            format!("{:?}", self.default),
            format!("{:?}", self.description),
            format!("{:?}", self.score),
            if let Some(text_matches) = &self.text_matches {
                format!("{:?}", text_matches)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "url".to_string(),
            "name".to_string(),
            "color".to_string(),
            "default".to_string(),
            "description".to_string(),
            "score".to_string(),
            "text_matches".to_string(),
        ]
    }
}

#[doc = "Repo Search Result Item"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepoSearchResultItem {
    pub id: i64,
    pub node_id: String,
    pub name: String,
    pub full_name: String,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    pub private: bool,
    pub html_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub fork: bool,
    pub url: url::Url,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub pushed_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<url::Url>,
    pub size: i64,
    pub stargazers_count: i64,
    pub watchers_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    pub forks_count: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub default_branch: String,
    pub score: f64,
    pub forks_url: url::Url,
    pub keys_url: String,
    pub collaborators_url: String,
    pub teams_url: url::Url,
    pub hooks_url: url::Url,
    pub issue_events_url: String,
    pub events_url: url::Url,
    pub assignees_url: String,
    pub branches_url: String,
    pub tags_url: url::Url,
    pub blobs_url: String,
    pub git_tags_url: String,
    pub git_refs_url: String,
    pub trees_url: String,
    pub statuses_url: String,
    pub languages_url: url::Url,
    pub stargazers_url: url::Url,
    pub contributors_url: url::Url,
    pub subscribers_url: url::Url,
    pub subscription_url: url::Url,
    pub commits_url: String,
    pub git_commits_url: String,
    pub comments_url: String,
    pub issue_comment_url: String,
    pub contents_url: String,
    pub compare_url: String,
    pub merges_url: url::Url,
    pub archive_url: String,
    pub downloads_url: url::Url,
    pub issues_url: String,
    pub pulls_url: String,
    pub milestones_url: String,
    pub notifications_url: String,
    pub labels_url: String,
    pub releases_url: String,
    pub deployments_url: url::Url,
    pub git_url: String,
    pub ssh_url: String,
    pub clone_url: String,
    pub svn_url: url::Url,
    pub forks: i64,
    pub open_issues: i64,
    pub watchers: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror_url: Option<url::Url>,
    pub has_issues: bool,
    pub has_projects: bool,
    pub has_pages: bool,
    pub has_wiki: bool,
    pub has_downloads: bool,
    pub archived: bool,
    #[doc = "Returns whether or not this repository disabled."]
    pub disabled: bool,
    #[doc = "The repository visibility: public, private, or internal."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub visibility: Option<String>,
    #[doc = "License Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text_matches: Option<Vec<SearchResultTextMatches>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_template: Option<bool>,
}

impl std::fmt::Display for RepoSearchResultItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepoSearchResultItem {
    const LENGTH: usize = 87;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            self.name.clone(),
            self.full_name.clone(),
            format!("{:?}", self.owner),
            format!("{:?}", self.private),
            format!("{:?}", self.html_url),
            format!("{:?}", self.description),
            format!("{:?}", self.fork),
            format!("{:?}", self.url),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.pushed_at),
            format!("{:?}", self.homepage),
            format!("{:?}", self.size),
            format!("{:?}", self.stargazers_count),
            format!("{:?}", self.watchers_count),
            format!("{:?}", self.language),
            format!("{:?}", self.forks_count),
            format!("{:?}", self.open_issues_count),
            if let Some(master_branch) = &self.master_branch {
                format!("{:?}", master_branch)
            } else {
                String::new()
            },
            self.default_branch.clone(),
            format!("{:?}", self.score),
            format!("{:?}", self.forks_url),
            self.keys_url.clone(),
            self.collaborators_url.clone(),
            format!("{:?}", self.teams_url),
            format!("{:?}", self.hooks_url),
            self.issue_events_url.clone(),
            format!("{:?}", self.events_url),
            self.assignees_url.clone(),
            self.branches_url.clone(),
            format!("{:?}", self.tags_url),
            self.blobs_url.clone(),
            self.git_tags_url.clone(),
            self.git_refs_url.clone(),
            self.trees_url.clone(),
            self.statuses_url.clone(),
            format!("{:?}", self.languages_url),
            format!("{:?}", self.stargazers_url),
            format!("{:?}", self.contributors_url),
            format!("{:?}", self.subscribers_url),
            format!("{:?}", self.subscription_url),
            self.commits_url.clone(),
            self.git_commits_url.clone(),
            self.comments_url.clone(),
            self.issue_comment_url.clone(),
            self.contents_url.clone(),
            self.compare_url.clone(),
            format!("{:?}", self.merges_url),
            self.archive_url.clone(),
            format!("{:?}", self.downloads_url),
            self.issues_url.clone(),
            self.pulls_url.clone(),
            self.milestones_url.clone(),
            self.notifications_url.clone(),
            self.labels_url.clone(),
            self.releases_url.clone(),
            format!("{:?}", self.deployments_url),
            self.git_url.clone(),
            self.ssh_url.clone(),
            self.clone_url.clone(),
            format!("{:?}", self.svn_url),
            format!("{:?}", self.forks),
            format!("{:?}", self.open_issues),
            format!("{:?}", self.watchers),
            if let Some(topics) = &self.topics {
                format!("{:?}", topics)
            } else {
                String::new()
            },
            format!("{:?}", self.mirror_url),
            format!("{:?}", self.has_issues),
            format!("{:?}", self.has_projects),
            format!("{:?}", self.has_pages),
            format!("{:?}", self.has_wiki),
            format!("{:?}", self.has_downloads),
            format!("{:?}", self.archived),
            format!("{:?}", self.disabled),
            if let Some(visibility) = &self.visibility {
                format!("{:?}", visibility)
            } else {
                String::new()
            },
            format!("{:?}", self.license),
            if let Some(permissions) = &self.permissions {
                format!("{:?}", permissions)
            } else {
                String::new()
            },
            if let Some(text_matches) = &self.text_matches {
                format!("{:?}", text_matches)
            } else {
                String::new()
            },
            if let Some(temp_clone_token) = &self.temp_clone_token {
                format!("{:?}", temp_clone_token)
            } else {
                String::new()
            },
            if let Some(allow_merge_commit) = &self.allow_merge_commit {
                format!("{:?}", allow_merge_commit)
            } else {
                String::new()
            },
            if let Some(allow_squash_merge) = &self.allow_squash_merge {
                format!("{:?}", allow_squash_merge)
            } else {
                String::new()
            },
            if let Some(allow_rebase_merge) = &self.allow_rebase_merge {
                format!("{:?}", allow_rebase_merge)
            } else {
                String::new()
            },
            if let Some(allow_auto_merge) = &self.allow_auto_merge {
                format!("{:?}", allow_auto_merge)
            } else {
                String::new()
            },
            if let Some(delete_branch_on_merge) = &self.delete_branch_on_merge {
                format!("{:?}", delete_branch_on_merge)
            } else {
                String::new()
            },
            if let Some(allow_forking) = &self.allow_forking {
                format!("{:?}", allow_forking)
            } else {
                String::new()
            },
            if let Some(is_template) = &self.is_template {
                format!("{:?}", is_template)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "name".to_string(),
            "full_name".to_string(),
            "owner".to_string(),
            "private".to_string(),
            "html_url".to_string(),
            "description".to_string(),
            "fork".to_string(),
            "url".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "pushed_at".to_string(),
            "homepage".to_string(),
            "size".to_string(),
            "stargazers_count".to_string(),
            "watchers_count".to_string(),
            "language".to_string(),
            "forks_count".to_string(),
            "open_issues_count".to_string(),
            "master_branch".to_string(),
            "default_branch".to_string(),
            "score".to_string(),
            "forks_url".to_string(),
            "keys_url".to_string(),
            "collaborators_url".to_string(),
            "teams_url".to_string(),
            "hooks_url".to_string(),
            "issue_events_url".to_string(),
            "events_url".to_string(),
            "assignees_url".to_string(),
            "branches_url".to_string(),
            "tags_url".to_string(),
            "blobs_url".to_string(),
            "git_tags_url".to_string(),
            "git_refs_url".to_string(),
            "trees_url".to_string(),
            "statuses_url".to_string(),
            "languages_url".to_string(),
            "stargazers_url".to_string(),
            "contributors_url".to_string(),
            "subscribers_url".to_string(),
            "subscription_url".to_string(),
            "commits_url".to_string(),
            "git_commits_url".to_string(),
            "comments_url".to_string(),
            "issue_comment_url".to_string(),
            "contents_url".to_string(),
            "compare_url".to_string(),
            "merges_url".to_string(),
            "archive_url".to_string(),
            "downloads_url".to_string(),
            "issues_url".to_string(),
            "pulls_url".to_string(),
            "milestones_url".to_string(),
            "notifications_url".to_string(),
            "labels_url".to_string(),
            "releases_url".to_string(),
            "deployments_url".to_string(),
            "git_url".to_string(),
            "ssh_url".to_string(),
            "clone_url".to_string(),
            "svn_url".to_string(),
            "forks".to_string(),
            "open_issues".to_string(),
            "watchers".to_string(),
            "topics".to_string(),
            "mirror_url".to_string(),
            "has_issues".to_string(),
            "has_projects".to_string(),
            "has_pages".to_string(),
            "has_wiki".to_string(),
            "has_downloads".to_string(),
            "archived".to_string(),
            "disabled".to_string(),
            "visibility".to_string(),
            "license".to_string(),
            "permissions".to_string(),
            "text_matches".to_string(),
            "temp_clone_token".to_string(),
            "allow_merge_commit".to_string(),
            "allow_squash_merge".to_string(),
            "allow_rebase_merge".to_string(),
            "allow_auto_merge".to_string(),
            "delete_branch_on_merge".to_string(),
            "allow_forking".to_string(),
            "is_template".to_string(),
        ]
    }
}

#[doc = "Topic Search Result Item"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TopicSearchResultItem {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub short_description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_by: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub released: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub featured: bool,
    pub curated: bool,
    pub score: f64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logo_url: Option<url::Url>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text_matches: Option<Vec<SearchResultTextMatches>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub related: Option<Vec<Related>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<Aliases>>,
}

impl std::fmt::Display for TopicSearchResultItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TopicSearchResultItem {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.display_name),
            format!("{:?}", self.short_description),
            format!("{:?}", self.description),
            format!("{:?}", self.created_by),
            format!("{:?}", self.released),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.featured),
            format!("{:?}", self.curated),
            format!("{:?}", self.score),
            if let Some(repository_count) = &self.repository_count {
                format!("{:?}", repository_count)
            } else {
                String::new()
            },
            if let Some(logo_url) = &self.logo_url {
                format!("{:?}", logo_url)
            } else {
                String::new()
            },
            if let Some(text_matches) = &self.text_matches {
                format!("{:?}", text_matches)
            } else {
                String::new()
            },
            if let Some(related) = &self.related {
                format!("{:?}", related)
            } else {
                String::new()
            },
            if let Some(aliases) = &self.aliases {
                format!("{:?}", aliases)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "display_name".to_string(),
            "short_description".to_string(),
            "description".to_string(),
            "created_by".to_string(),
            "released".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "featured".to_string(),
            "curated".to_string(),
            "score".to_string(),
            "repository_count".to_string(),
            "logo_url".to_string(),
            "text_matches".to_string(),
            "related".to_string(),
            "aliases".to_string(),
        ]
    }
}

#[doc = "User Search Result Item"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UserSearchResultItem {
    pub login: String,
    pub id: i64,
    pub node_id: String,
    pub avatar_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gravatar_id: Option<String>,
    pub url: url::Url,
    pub html_url: url::Url,
    pub followers_url: url::Url,
    pub subscriptions_url: url::Url,
    pub organizations_url: url::Url,
    pub repos_url: url::Url,
    pub received_events_url: url::Url,
    #[serde(rename = "type")]
    pub type_: String,
    pub score: f64,
    pub following_url: String,
    pub gists_url: String,
    pub starred_url: String,
    pub events_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_repos: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_gists: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub followers: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub following: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bio: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    pub site_admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hireable: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text_matches: Option<Vec<SearchResultTextMatches>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blog: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suspended_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for UserSearchResultItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UserSearchResultItem {
    const LENGTH: usize = 34;
    fn fields(&self) -> Vec<String> {
        vec![
            self.login.clone(),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.avatar_url),
            format!("{:?}", self.gravatar_id),
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.followers_url),
            format!("{:?}", self.subscriptions_url),
            format!("{:?}", self.organizations_url),
            format!("{:?}", self.repos_url),
            format!("{:?}", self.received_events_url),
            self.type_.clone(),
            format!("{:?}", self.score),
            self.following_url.clone(),
            self.gists_url.clone(),
            self.starred_url.clone(),
            self.events_url.clone(),
            if let Some(public_repos) = &self.public_repos {
                format!("{:?}", public_repos)
            } else {
                String::new()
            },
            if let Some(public_gists) = &self.public_gists {
                format!("{:?}", public_gists)
            } else {
                String::new()
            },
            if let Some(followers) = &self.followers {
                format!("{:?}", followers)
            } else {
                String::new()
            },
            if let Some(following) = &self.following {
                format!("{:?}", following)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            if let Some(bio) = &self.bio {
                format!("{:?}", bio)
            } else {
                String::new()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email)
            } else {
                String::new()
            },
            if let Some(location) = &self.location {
                format!("{:?}", location)
            } else {
                String::new()
            },
            format!("{:?}", self.site_admin),
            if let Some(hireable) = &self.hireable {
                format!("{:?}", hireable)
            } else {
                String::new()
            },
            if let Some(text_matches) = &self.text_matches {
                format!("{:?}", text_matches)
            } else {
                String::new()
            },
            if let Some(blog) = &self.blog {
                format!("{:?}", blog)
            } else {
                String::new()
            },
            if let Some(company) = &self.company {
                format!("{:?}", company)
            } else {
                String::new()
            },
            if let Some(suspended_at) = &self.suspended_at {
                format!("{:?}", suspended_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "login".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "avatar_url".to_string(),
            "gravatar_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "followers_url".to_string(),
            "subscriptions_url".to_string(),
            "organizations_url".to_string(),
            "repos_url".to_string(),
            "received_events_url".to_string(),
            "type_".to_string(),
            "score".to_string(),
            "following_url".to_string(),
            "gists_url".to_string(),
            "starred_url".to_string(),
            "events_url".to_string(),
            "public_repos".to_string(),
            "public_gists".to_string(),
            "followers".to_string(),
            "following".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "name".to_string(),
            "bio".to_string(),
            "email".to_string(),
            "location".to_string(),
            "site_admin".to_string(),
            "hireable".to_string(),
            "text_matches".to_string(),
            "blog".to_string(),
            "company".to_string(),
            "suspended_at".to_string(),
        ]
    }
}

#[doc = "Private User"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PrivateUser {
    pub login: String,
    pub id: i64,
    pub node_id: String,
    pub avatar_url: url::Url,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gravatar_id: Option<String>,
    pub url: url::Url,
    pub html_url: url::Url,
    pub followers_url: url::Url,
    pub following_url: String,
    pub gists_url: String,
    pub starred_url: String,
    pub subscriptions_url: url::Url,
    pub organizations_url: url::Url,
    pub repos_url: url::Url,
    pub events_url: String,
    pub received_events_url: url::Url,
    #[serde(rename = "type")]
    pub type_: String,
    pub site_admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blog: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hireable: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bio: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub twitter_username: Option<String>,
    pub public_repos: i64,
    pub public_gists: i64,
    pub followers: i64,
    pub following: i64,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub private_gists: i64,
    pub total_private_repos: i64,
    pub owned_private_repos: i64,
    pub disk_usage: i64,
    pub collaborators: i64,
    pub two_factor_authentication: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plan: Option<Plan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suspended_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub business_plus: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ldap_dn: Option<String>,
}

impl std::fmt::Display for PrivateUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PrivateUser {
    const LENGTH: usize = 42;
    fn fields(&self) -> Vec<String> {
        vec![
            self.login.clone(),
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.avatar_url),
            format!("{:?}", self.gravatar_id),
            format!("{:?}", self.url),
            format!("{:?}", self.html_url),
            format!("{:?}", self.followers_url),
            self.following_url.clone(),
            self.gists_url.clone(),
            self.starred_url.clone(),
            format!("{:?}", self.subscriptions_url),
            format!("{:?}", self.organizations_url),
            format!("{:?}", self.repos_url),
            self.events_url.clone(),
            format!("{:?}", self.received_events_url),
            self.type_.clone(),
            format!("{:?}", self.site_admin),
            format!("{:?}", self.name),
            format!("{:?}", self.company),
            format!("{:?}", self.blog),
            format!("{:?}", self.location),
            format!("{:?}", self.email),
            format!("{:?}", self.hireable),
            format!("{:?}", self.bio),
            if let Some(twitter_username) = &self.twitter_username {
                format!("{:?}", twitter_username)
            } else {
                String::new()
            },
            format!("{:?}", self.public_repos),
            format!("{:?}", self.public_gists),
            format!("{:?}", self.followers),
            format!("{:?}", self.following),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.private_gists),
            format!("{:?}", self.total_private_repos),
            format!("{:?}", self.owned_private_repos),
            format!("{:?}", self.disk_usage),
            format!("{:?}", self.collaborators),
            format!("{:?}", self.two_factor_authentication),
            if let Some(plan) = &self.plan {
                format!("{:?}", plan)
            } else {
                String::new()
            },
            if let Some(suspended_at) = &self.suspended_at {
                format!("{:?}", suspended_at)
            } else {
                String::new()
            },
            if let Some(business_plus) = &self.business_plus {
                format!("{:?}", business_plus)
            } else {
                String::new()
            },
            if let Some(ldap_dn) = &self.ldap_dn {
                format!("{:?}", ldap_dn)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "login".to_string(),
            "id".to_string(),
            "node_id".to_string(),
            "avatar_url".to_string(),
            "gravatar_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "followers_url".to_string(),
            "following_url".to_string(),
            "gists_url".to_string(),
            "starred_url".to_string(),
            "subscriptions_url".to_string(),
            "organizations_url".to_string(),
            "repos_url".to_string(),
            "events_url".to_string(),
            "received_events_url".to_string(),
            "type_".to_string(),
            "site_admin".to_string(),
            "name".to_string(),
            "company".to_string(),
            "blog".to_string(),
            "location".to_string(),
            "email".to_string(),
            "hireable".to_string(),
            "bio".to_string(),
            "twitter_username".to_string(),
            "public_repos".to_string(),
            "public_gists".to_string(),
            "followers".to_string(),
            "following".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "private_gists".to_string(),
            "total_private_repos".to_string(),
            "owned_private_repos".to_string(),
            "disk_usage".to_string(),
            "collaborators".to_string(),
            "two_factor_authentication".to_string(),
            "plan".to_string(),
            "suspended_at".to_string(),
            "business_plus".to_string(),
            "ldap_dn".to_string(),
        ]
    }
}

#[doc = "Secrets for a GitHub Codespace."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodespacesSecret {
    #[doc = "The name of the secret"]
    pub name: String,
    #[doc = "Secret created at"]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Secret last updated at"]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The type of repositories in the organization that the secret is visible to"]
    pub visibility: Visibility,
    #[doc = "API URL at which the list of repositories this secret is vicible can be retrieved"]
    pub selected_repositories_url: url::Url,
}

impl std::fmt::Display for CodespacesSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodespacesSecret {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            self.name.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.visibility),
            format!("{:?}", self.selected_repositories_url),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "visibility".to_string(),
            "selected_repositories_url".to_string(),
        ]
    }
}

#[doc = "The public key used for setting user Codespaces' Secrets."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodespacesUserPublicKey {
    #[doc = "The identifier for the key."]
    pub key_id: String,
    #[doc = "The Base64 encoded public key."]
    pub key: String,
}

impl std::fmt::Display for CodespacesUserPublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodespacesUserPublicKey {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.key_id.clone(), self.key.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["key_id".to_string(), "key".to_string()]
    }
}

#[doc = "Email"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Email {
    pub email: String,
    pub primary: bool,
    pub verified: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub visibility: Option<String>,
}

impl std::fmt::Display for Email {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Email {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            self.email.clone(),
            format!("{:?}", self.primary),
            format!("{:?}", self.verified),
            format!("{:?}", self.visibility),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "email".to_string(),
            "primary".to_string(),
            "verified".to_string(),
            "visibility".to_string(),
        ]
    }
}

#[doc = "A unique encryption key"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GpgKey {
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub primary_key_id: Option<i64>,
    pub key_id: String,
    pub public_key: String,
    pub emails: Vec<Emails>,
    pub subkeys: Vec<Subkeys>,
    pub can_sign: bool,
    pub can_encrypt_comms: bool,
    pub can_encrypt_storage: bool,
    pub can_certify: bool,
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    pub revoked: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub raw_key: Option<String>,
}

impl std::fmt::Display for GpgKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GpgKey {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            if let Some(name) = &self.name {
                format!("{:?}", name)
            } else {
                String::new()
            },
            format!("{:?}", self.primary_key_id),
            self.key_id.clone(),
            self.public_key.clone(),
            format!("{:?}", self.emails),
            format!("{:?}", self.subkeys),
            format!("{:?}", self.can_sign),
            format!("{:?}", self.can_encrypt_comms),
            format!("{:?}", self.can_encrypt_storage),
            format!("{:?}", self.can_certify),
            format!("{:?}", self.created_at),
            format!("{:?}", self.expires_at),
            format!("{:?}", self.revoked),
            format!("{:?}", self.raw_key),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "name".to_string(),
            "primary_key_id".to_string(),
            "key_id".to_string(),
            "public_key".to_string(),
            "emails".to_string(),
            "subkeys".to_string(),
            "can_sign".to_string(),
            "can_encrypt_comms".to_string(),
            "can_encrypt_storage".to_string(),
            "can_certify".to_string(),
            "created_at".to_string(),
            "expires_at".to_string(),
            "revoked".to_string(),
            "raw_key".to_string(),
        ]
    }
}

#[doc = "Key"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Key {
    pub key: String,
    pub id: i64,
    pub url: String,
    pub title: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub verified: bool,
    pub read_only: bool,
}

impl std::fmt::Display for Key {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Key {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            self.key.clone(),
            format!("{:?}", self.id),
            self.url.clone(),
            self.title.clone(),
            format!("{:?}", self.created_at),
            format!("{:?}", self.verified),
            format!("{:?}", self.read_only),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "key".to_string(),
            "id".to_string(),
            "url".to_string(),
            "title".to_string(),
            "created_at".to_string(),
            "verified".to_string(),
            "read_only".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MarketplaceAccount {
    pub url: url::Url,
    pub id: i64,
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_billing_email: Option<String>,
}

impl std::fmt::Display for MarketplaceAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MarketplaceAccount {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.url),
            format!("{:?}", self.id),
            self.type_.clone(),
            if let Some(node_id) = &self.node_id {
                format!("{:?}", node_id)
            } else {
                String::new()
            },
            self.login.clone(),
            if let Some(email) = &self.email {
                format!("{:?}", email)
            } else {
                String::new()
            },
            if let Some(organization_billing_email) = &self.organization_billing_email {
                format!("{:?}", organization_billing_email)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "id".to_string(),
            "type_".to_string(),
            "node_id".to_string(),
            "login".to_string(),
            "email".to_string(),
            "organization_billing_email".to_string(),
        ]
    }
}

#[doc = "User Marketplace Purchase"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UserMarketplacePurchase {
    pub billing_cycle: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_billing_date: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit_count: Option<i64>,
    pub on_free_trial: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub free_trial_ends_on: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub account: MarketplaceAccount,
    #[doc = "Marketplace Listing Plan"]
    pub plan: MarketplaceListingPlan,
}

impl std::fmt::Display for UserMarketplacePurchase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UserMarketplacePurchase {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            self.billing_cycle.clone(),
            format!("{:?}", self.next_billing_date),
            format!("{:?}", self.unit_count),
            format!("{:?}", self.on_free_trial),
            format!("{:?}", self.free_trial_ends_on),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.account),
            format!("{:?}", self.plan),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "billing_cycle".to_string(),
            "next_billing_date".to_string(),
            "unit_count".to_string(),
            "on_free_trial".to_string(),
            "free_trial_ends_on".to_string(),
            "updated_at".to_string(),
            "account".to_string(),
            "plan".to_string(),
        ]
    }
}

#[doc = "Starred Repository"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct StarredRepository {
    pub starred_at: chrono::DateTime<chrono::Utc>,
    #[doc = "A git repository"]
    pub repo: Repository,
}

impl std::fmt::Display for StarredRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for StarredRepository {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.starred_at), format!("{:?}", self.repo)]
    }

    fn headers() -> Vec<String> {
        vec!["starred_at".to_string(), "repo".to_string()]
    }
}

#[doc = "Hovercard"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Hovercard {
    pub contexts: Vec<Contexts>,
}

impl std::fmt::Display for Hovercard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Hovercard {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.contexts)]
    }

    fn headers() -> Vec<String> {
        vec!["contexts".to_string()]
    }
}

#[doc = "Key Simple"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct KeySimple {
    pub id: i64,
    pub key: String,
}

impl std::fmt::Display for KeySimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for KeySimple {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.id), self.key.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["id".to_string(), "key".to_string()]
    }
}

#[doc = "Simple Installation"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SimpleInstallation {
    #[doc = "The ID of the installation."]
    pub id: i64,
    #[doc = "The global node ID of the installation."]
    pub node_id: String,
}

impl std::fmt::Display for SimpleInstallation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SimpleInstallation {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.id), self.node_id.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["id".to_string(), "node_id".to_string()]
    }
}

#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BranchProtectionRuleCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings."]
    pub rule: Rule,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for BranchProtectionRuleCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for BranchProtectionRuleCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.rule),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "rule".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BranchProtectionRuleDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings."]
    pub rule: Rule,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for BranchProtectionRuleDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for BranchProtectionRuleDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.rule),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "rule".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BranchProtectionRuleEdited {
    pub action: Action,
    #[doc = "If the action was `edited`, the changes to the rule."]
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings."]
    pub rule: Rule,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for BranchProtectionRuleEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for BranchProtectionRuleEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.rule),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "rule".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A suite of checks performed on the code of a given code change"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SimpleCheckSuite {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<Status>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conclusion: Option<Conclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub before: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub after: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<Vec<PullRequestMinimal>>,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app: Option<Integration>,
    #[doc = "Minimal Repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<MinimalRepository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for SimpleCheckSuite {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SimpleCheckSuite {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(id) = &self.id {
                format!("{:?}", id)
            } else {
                String::new()
            },
            if let Some(node_id) = &self.node_id {
                format!("{:?}", node_id)
            } else {
                String::new()
            },
            if let Some(head_branch) = &self.head_branch {
                format!("{:?}", head_branch)
            } else {
                String::new()
            },
            if let Some(head_sha) = &self.head_sha {
                format!("{:?}", head_sha)
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{:?}", status)
            } else {
                String::new()
            },
            if let Some(conclusion) = &self.conclusion {
                format!("{:?}", conclusion)
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url)
            } else {
                String::new()
            },
            if let Some(before) = &self.before {
                format!("{:?}", before)
            } else {
                String::new()
            },
            if let Some(after) = &self.after {
                format!("{:?}", after)
            } else {
                String::new()
            },
            if let Some(pull_requests) = &self.pull_requests {
                format!("{:?}", pull_requests)
            } else {
                String::new()
            },
            if let Some(app) = &self.app {
                format!("{:?}", app)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at)
            } else {
                String::new()
            },
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "head_branch".to_string(),
            "head_sha".to_string(),
            "status".to_string(),
            "conclusion".to_string(),
            "url".to_string(),
            "before".to_string(),
            "after".to_string(),
            "pull_requests".to_string(),
            "app".to_string(),
            "repository".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
        ]
    }
}

#[doc = "A check performed on the code of a given code change"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckRunWithSimpleCheckSuite {
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub node_id: String,
    pub external_id: String,
    pub url: String,
    pub html_url: String,
    pub details_url: String,
    #[doc = "The phase of the lifecycle that the check is currently in."]
    pub status: Status,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conclusion: Option<Conclusion>,
    pub started_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    pub output: Output,
    #[doc = "The name of the check."]
    pub name: String,
    #[doc = "A suite of checks performed on the code of a given code change"]
    pub check_suite: SimpleCheckSuite,
    #[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app: Option<NullableIntegration>,
    pub pull_requests: Vec<PullRequestMinimal>,
    #[doc = "A deployment created as the result of an Actions check run from a workflow that references an environment"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<DeploymentSimple>,
}

impl std::fmt::Display for CheckRunWithSimpleCheckSuite {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckRunWithSimpleCheckSuite {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.head_sha.clone(),
            self.node_id.clone(),
            self.external_id.clone(),
            self.url.clone(),
            self.html_url.clone(),
            self.details_url.clone(),
            format!("{:?}", self.status),
            format!("{:?}", self.conclusion),
            format!("{:?}", self.started_at),
            format!("{:?}", self.completed_at),
            format!("{:?}", self.output),
            self.name.clone(),
            format!("{:?}", self.check_suite),
            format!("{:?}", self.app),
            format!("{:?}", self.pull_requests),
            if let Some(deployment) = &self.deployment {
                format!("{:?}", deployment)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "head_sha".to_string(),
            "node_id".to_string(),
            "external_id".to_string(),
            "url".to_string(),
            "html_url".to_string(),
            "details_url".to_string(),
            "status".to_string(),
            "conclusion".to_string(),
            "started_at".to_string(),
            "completed_at".to_string(),
            "output".to_string(),
            "name".to_string(),
            "check_suite".to_string(),
            "app".to_string(),
            "pull_requests".to_string(),
            "deployment".to_string(),
        ]
    }
}

#[doc = "The status of the check run is now `completed`."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckRunCompleted {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<Action>,
    #[doc = "A check performed on the code of a given code change"]
    pub check_run: CheckRunWithSimpleCheckSuite,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CheckRunCompleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckRunCompleted {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(action) = &self.action {
                format!("{:?}", action)
            } else {
                String::new()
            },
            format!("{:?}", self.check_run),
            format!("{:?}", self.repository),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "check_run".to_string(),
            "repository".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "The check_run.completed webhook encoded with URL encoding"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckRunCompletedFormEncoded {
    #[doc = "A URL-encoded string of the check_run.completed JSON payload. The decoded payload is a JSON object."]
    pub payload: String,
}

impl std::fmt::Display for CheckRunCompletedFormEncoded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckRunCompletedFormEncoded {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.payload.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["payload".to_string()]
    }
}

#[doc = "A new check run was created."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckRunCreated {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<Action>,
    #[doc = "A check performed on the code of a given code change"]
    pub check_run: CheckRunWithSimpleCheckSuite,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CheckRunCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckRunCreated {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(action) = &self.action {
                format!("{:?}", action)
            } else {
                String::new()
            },
            format!("{:?}", self.check_run),
            format!("{:?}", self.repository),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "check_run".to_string(),
            "repository".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "The check_run.created webhook encoded with URL encoding"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckRunCreatedFormEncoded {
    #[doc = "A URL-encoded string of the check_run.created JSON payload. The decoded payload is a JSON object."]
    pub payload: String,
}

impl std::fmt::Display for CheckRunCreatedFormEncoded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckRunCreatedFormEncoded {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.payload.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["payload".to_string()]
    }
}

#[doc = "A check run action was requested."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckRunRequestedAction {
    pub action: Action,
    #[doc = "A check performed on the code of a given code change"]
    pub check_run: CheckRunWithSimpleCheckSuite,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_action: Option<RequestedAction>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CheckRunRequestedAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckRunRequestedAction {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.check_run),
            if let Some(requested_action) = &self.requested_action {
                format!("{:?}", requested_action)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "check_run".to_string(),
            "requested_action".to_string(),
            "repository".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "The check_run.requested_action webhook encoded with URL encoding"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckRunRequestedActionFormEncoded {
    #[doc = "A URL-encoded string of the check_run.requested_action JSON payload. The decoded payload is a JSON object."]
    pub payload: String,
}

impl std::fmt::Display for CheckRunRequestedActionFormEncoded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckRunRequestedActionFormEncoded {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.payload.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["payload".to_string()]
    }
}

#[doc = "A check run was re-requested."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckRunRerequested {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<Action>,
    #[doc = "A check performed on the code of a given code change"]
    pub check_run: CheckRunWithSimpleCheckSuite,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CheckRunRerequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckRunRerequested {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(action) = &self.action {
                format!("{:?}", action)
            } else {
                String::new()
            },
            format!("{:?}", self.check_run),
            format!("{:?}", self.repository),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "check_run".to_string(),
            "repository".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "The check_run.rerequested webhook encoded with URL encoding"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckRunRerequestedFormEncoded {
    #[doc = "A URL-encoded string of the check_run.rerequested JSON payload. The decoded payload is a JSON object."]
    pub payload: String,
}

impl std::fmt::Display for CheckRunRerequestedFormEncoded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckRunRerequestedFormEncoded {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.payload.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["payload".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckSuiteCompleted {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions_meta: Option<ActionsMeta>,
    #[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
    pub check_suite: CheckSuite,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CheckSuiteCompleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckSuiteCompleted {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(actions_meta) = &self.actions_meta {
                format!("{:?}", actions_meta)
            } else {
                String::new()
            },
            format!("{:?}", self.check_suite),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "actions_meta".to_string(),
            "check_suite".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckSuiteRequested {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions_meta: Option<ActionsMeta>,
    #[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
    pub check_suite: CheckSuite,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CheckSuiteRequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckSuiteRequested {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(actions_meta) = &self.actions_meta {
                format!("{:?}", actions_meta)
            } else {
                String::new()
            },
            format!("{:?}", self.check_suite),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "actions_meta".to_string(),
            "check_suite".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CheckSuiteRerequested {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions_meta: Option<ActionsMeta>,
    #[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
    pub check_suite: CheckSuite,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CheckSuiteRerequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CheckSuiteRerequested {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(actions_meta) = &self.actions_meta {
                format!("{:?}", actions_meta)
            } else {
                String::new()
            },
            format!("{:?}", self.check_suite),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "actions_meta".to_string(),
            "check_suite".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertAppearedInBranch {
    pub action: Action,
    #[doc = "The code scanning alert involved in the event."]
    pub alert: Alert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CodeScanningAlertAppearedInBranch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertAppearedInBranch {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            self.commit_oid.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            self.ref_.clone(),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "commit_oid".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "ref_".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertClosedByUser {
    pub action: Action,
    #[doc = "The code scanning alert involved in the event."]
    pub alert: Alert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CodeScanningAlertClosedByUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertClosedByUser {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            self.commit_oid.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            self.ref_.clone(),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "commit_oid".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "ref_".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertCreated {
    pub action: Action,
    #[doc = "The code scanning alert involved in the event."]
    pub alert: Alert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CodeScanningAlertCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertCreated {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            self.commit_oid.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            self.ref_.clone(),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "commit_oid".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "ref_".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertFixed {
    pub action: Action,
    #[doc = "The code scanning alert involved in the event."]
    pub alert: Alert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CodeScanningAlertFixed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertFixed {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            self.commit_oid.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            self.ref_.clone(),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "commit_oid".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "ref_".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertReopened {
    pub action: Action,
    #[doc = "The code scanning alert involved in the event."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alert: Option<Alert>,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_oid: Option<String>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref", default, skip_serializing_if = "Option::is_none")]
    pub ref_: Option<String>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CodeScanningAlertReopened {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertReopened {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            format!("{:?}", self.commit_oid),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.ref_),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "commit_oid".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "ref_".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeScanningAlertReopenedByUser {
    pub action: Action,
    #[doc = "The code scanning alert involved in the event."]
    pub alert: Alert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CodeScanningAlertReopenedByUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CodeScanningAlertReopenedByUser {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            self.commit_oid.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            self.ref_.clone(),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "commit_oid".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "ref_".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A commit comment is created. The type of activity is specified in the `action` property. "]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CommitCommentCreated {
    #[doc = "The action performed. Can be `created`."]
    pub action: Action,
    #[doc = "The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource."]
    pub comment: Comment,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for CommitCommentCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CommitCommentCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.comment),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "comment".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A Git branch or tag is created."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Create {
    #[doc = "The repository's current description."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The name of the repository's default branch (usually `main`)."]
    pub master_branch: String,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The pusher type for the event. Can be either `user` or a deploy key."]
    pub pusher_type: String,
    #[doc = "The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "The type of Git ref object created in the repository. Can be either `branch` or `tag`."]
    pub ref_type: RefType,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for Create {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Create {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.description),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            self.master_branch.clone(),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            self.pusher_type.clone(),
            self.ref_.clone(),
            format!("{:?}", self.ref_type),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "description".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "master_branch".to_string(),
            "organization".to_string(),
            "pusher_type".to_string(),
            "ref_".to_string(),
            "ref_type".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A Git branch or tag is deleted."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Delete {
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The pusher type for the event. Can be either `user` or a deploy key."]
    pub pusher_type: String,
    #[doc = "The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "The type of Git ref object deleted in the repository. Can be either `branch` or `tag`."]
    pub ref_type: RefType,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for Delete {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Delete {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            self.pusher_type.clone(),
            self.ref_.clone(),
            format!("{:?}", self.ref_type),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pusher_type".to_string(),
            "ref_".to_string(),
            "ref_type".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeployKeyCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [`deploy key`](https://docs.github.com/en/rest/reference/deployments#get-a-deploy-key) resource."]
    pub key: Key,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DeployKeyCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeployKeyCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.key),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "key".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeployKeyDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [`deploy key`](https://docs.github.com/en/rest/reference/deployments#get-a-deploy-key) resource."]
    pub key: Key,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DeployKeyDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeployKeyDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.key),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "key".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeploymentCreated {
    pub action: Action,
    #[doc = "The [deployment](https://docs.github.com/en/rest/reference/deployments#list-deployments)."]
    pub deployment: Deployment,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow: Option<Workflow>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_run: Option<WorkflowRun>,
}

impl std::fmt::Display for DeploymentCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeploymentCreated {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.deployment),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            format!("{:?}", self.workflow),
            format!("{:?}", self.workflow_run),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "deployment".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "workflow".to_string(),
            "workflow_run".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeploymentReviewApproved {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub approver: Option<Approver>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reviewers: Option<Vec<Reviewers>>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub since: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_job_run: Option<WorkflowJobRun>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_job_runs: Option<Vec<WorkflowJobRuns>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_run: Option<WorkflowRun>,
}

impl std::fmt::Display for DeploymentReviewApproved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeploymentReviewApproved {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(approver) = &self.approver {
                format!("{:?}", approver)
            } else {
                String::new()
            },
            if let Some(comment) = &self.comment {
                format!("{:?}", comment)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            format!("{:?}", self.repository),
            if let Some(reviewers) = &self.reviewers {
                format!("{:?}", reviewers)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            self.since.clone(),
            if let Some(workflow_job_run) = &self.workflow_job_run {
                format!("{:?}", workflow_job_run)
            } else {
                String::new()
            },
            if let Some(workflow_job_runs) = &self.workflow_job_runs {
                format!("{:?}", workflow_job_runs)
            } else {
                String::new()
            },
            format!("{:?}", self.workflow_run),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "approver".to_string(),
            "comment".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "reviewers".to_string(),
            "sender".to_string(),
            "since".to_string(),
            "workflow_job_run".to_string(),
            "workflow_job_runs".to_string(),
            "workflow_run".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeploymentReviewRejected {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub approver: Option<Approver>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reviewers: Option<Vec<Reviewers>>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub since: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_job_run: Option<WorkflowJobRun>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_job_runs: Option<Vec<WorkflowJobRuns>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_run: Option<WorkflowRun>,
}

impl std::fmt::Display for DeploymentReviewRejected {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeploymentReviewRejected {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(approver) = &self.approver {
                format!("{:?}", approver)
            } else {
                String::new()
            },
            if let Some(comment) = &self.comment {
                format!("{:?}", comment)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            format!("{:?}", self.repository),
            if let Some(reviewers) = &self.reviewers {
                format!("{:?}", reviewers)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            self.since.clone(),
            if let Some(workflow_job_run) = &self.workflow_job_run {
                format!("{:?}", workflow_job_run)
            } else {
                String::new()
            },
            if let Some(workflow_job_runs) = &self.workflow_job_runs {
                format!("{:?}", workflow_job_runs)
            } else {
                String::new()
            },
            format!("{:?}", self.workflow_run),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "approver".to_string(),
            "comment".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "reviewers".to_string(),
            "sender".to_string(),
            "since".to_string(),
            "workflow_job_run".to_string(),
            "workflow_job_runs".to_string(),
            "workflow_run".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeploymentReviewRequested {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    pub environment: String,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requestor: Option<Requestor>,
    pub reviewers: Vec<Reviewers>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub since: String,
    pub workflow_job_run: WorkflowJobRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_run: Option<WorkflowRun>,
}

impl std::fmt::Display for DeploymentReviewRequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeploymentReviewRequested {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            self.environment.clone(),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            format!("{:?}", self.repository),
            format!("{:?}", self.requestor),
            format!("{:?}", self.reviewers),
            format!("{:?}", self.sender),
            self.since.clone(),
            format!("{:?}", self.workflow_job_run),
            format!("{:?}", self.workflow_run),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "environment".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "requestor".to_string(),
            "reviewers".to_string(),
            "sender".to_string(),
            "since".to_string(),
            "workflow_job_run".to_string(),
            "workflow_run".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeploymentStatusCreated {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub check_run: Option<CheckRun>,
    #[doc = "The [deployment](https://docs.github.com/en/rest/reference/deployments#list-deployments)."]
    pub deployment: Deployment,
    #[doc = "The [deployment status](https://docs.github.com/en/rest/reference/deployments#list-deployment-statuses)."]
    pub deployment_status: DeploymentStatus,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow: Option<Workflow>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow_run: Option<WorkflowRun>,
}

impl std::fmt::Display for DeploymentStatusCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DeploymentStatusCreated {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(check_run) = &self.check_run {
                format!("{:?}", check_run)
            } else {
                String::new()
            },
            format!("{:?}", self.deployment),
            format!("{:?}", self.deployment_status),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            if let Some(workflow) = &self.workflow {
                format!("{:?}", workflow)
            } else {
                String::new()
            },
            if let Some(workflow_run) = &self.workflow_run {
                format!("{:?}", workflow_run)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "check_run".to_string(),
            "deployment".to_string(),
            "deployment_status".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "workflow".to_string(),
            "workflow_run".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionAnswered {
    pub action: Action,
    pub answer: Answer,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionAnswered {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionAnswered {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.answer),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "answer".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionCategoryChanged {
    pub action: Action,
    pub changes: Changes,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionCategoryChanged {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionCategoryChanged {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionCommentCreated {
    pub action: Action,
    pub comment: Comment,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionCommentCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionCommentCreated {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.comment),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "comment".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionCommentDeleted {
    pub action: Action,
    pub comment: Comment,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionCommentDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionCommentDeleted {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.comment),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "comment".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionCommentEdited {
    pub action: Action,
    pub changes: Changes,
    pub comment: Comment,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionCommentEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionCommentEdited {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            format!("{:?}", self.comment),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "comment".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionCreated {
    pub action: Action,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionDeleted {
    pub action: Action,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionEdited {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<Changes>,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(changes) = &self.changes {
                format!("{:?}", changes)
            } else {
                String::new()
            },
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionLabeled {
    pub action: Action,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub label: Label,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionLabeled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionLabeled {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.label),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "label".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionLocked {
    pub action: Action,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionLocked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionLocked {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionPinned {
    pub action: Action,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionPinned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionPinned {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionTransferred {
    pub action: Action,
    pub changes: Changes,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionTransferred {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionTransferred {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionUnanswered {
    pub action: Action,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub old_answer: OldAnswer,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for DiscussionUnanswered {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionUnanswered {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.old_answer),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "old_answer".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionUnlabeled {
    pub action: Action,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub label: Label,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionUnlabeled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionUnlabeled {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.label),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "label".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionUnlocked {
    pub action: Action,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionUnlocked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionUnlocked {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscussionUnpinned {
    pub action: Action,
    pub discussion: Discussion,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for DiscussionUnpinned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for DiscussionUnpinned {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.discussion),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "discussion".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A user forks a repository."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Fork {
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource."]
    pub forkee: Forkee,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for Fork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Fork {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.forkee),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enterprise".to_string(),
            "forkee".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GithubAppAuthorizationRevoked {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for GithubAppAuthorizationRevoked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for GithubAppAuthorizationRevoked {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A wiki page is created or updated."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Gollum {
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The pages that were updated."]
    pub pages: Vec<Pages>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for Gollum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Gollum {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pages),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pages".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstallationCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Installation"]
    pub installation: Installation,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repositories: Option<Vec<Repositories>>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester: Option<Requester>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for InstallationCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InstallationCreated {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.installation),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repositories) = &self.repositories {
                format!("{:?}", repositories)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(requester) = &self.requester {
                format!("{:?}", requester)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repositories".to_string(),
            "repository".to_string(),
            "requester".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstallationDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Installation"]
    pub installation: Installation,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repositories: Option<Vec<Repositories>>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester: Option<serde_json::Value>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for InstallationDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InstallationDeleted {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.installation),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repositories) = &self.repositories {
                format!("{:?}", repositories)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(requester) = &self.requester {
                format!("{:?}", requester)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repositories".to_string(),
            "repository".to_string(),
            "requester".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstallationNewPermissionsAccepted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Installation"]
    pub installation: Installation,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repositories: Option<Vec<Repositories>>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester: Option<serde_json::Value>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for InstallationNewPermissionsAccepted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InstallationNewPermissionsAccepted {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.installation),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repositories) = &self.repositories {
                format!("{:?}", repositories)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(requester) = &self.requester {
                format!("{:?}", requester)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repositories".to_string(),
            "repository".to_string(),
            "requester".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstallationRepositoriesAdded {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Installation"]
    pub installation: Installation,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "An array of repository objects, which were added to the installation."]
    pub repositories_added: Vec<RepositoriesAdded>,
    #[doc = "An array of repository objects, which were removed from the installation."]
    pub repositories_removed: Vec<RepositoriesRemoved>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: RepositorySelection,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester: Option<Requester>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for InstallationRepositoriesAdded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InstallationRepositoriesAdded {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.installation),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repositories_added),
            format!("{:?}", self.repositories_removed),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.repository_selection),
            format!("{:?}", self.requester),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repositories_added".to_string(),
            "repositories_removed".to_string(),
            "repository".to_string(),
            "repository_selection".to_string(),
            "requester".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstallationRepositoriesRemoved {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Installation"]
    pub installation: Installation,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "An array of repository objects, which were added to the installation."]
    pub repositories_added: Vec<RepositoriesAdded>,
    #[doc = "An array of repository objects, which were removed from the installation."]
    pub repositories_removed: Vec<RepositoriesRemoved>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: RepositorySelection,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester: Option<Requester>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for InstallationRepositoriesRemoved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InstallationRepositoriesRemoved {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.installation),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repositories_added),
            format!("{:?}", self.repositories_removed),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.repository_selection),
            format!("{:?}", self.requester),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repositories_added".to_string(),
            "repositories_removed".to_string(),
            "repository".to_string(),
            "repository_selection".to_string(),
            "requester".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstallationSuspend {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Installation"]
    pub installation: Installation,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repositories: Option<Vec<Repositories>>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester: Option<serde_json::Value>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for InstallationSuspend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InstallationSuspend {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.installation),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repositories) = &self.repositories {
                format!("{:?}", repositories)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(requester) = &self.requester {
                format!("{:?}", requester)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repositories".to_string(),
            "repository".to_string(),
            "requester".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstallationTargetRenamed {
    pub account: Account,
    pub action: String,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    pub installation: SimpleInstallation,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
    pub target_type: String,
}

impl std::fmt::Display for InstallationTargetRenamed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InstallationTargetRenamed {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.account),
            self.action.clone(),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.installation),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
            self.target_type.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account".to_string(),
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "target_type".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstallationUnsuspend {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Installation"]
    pub installation: Installation,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repositories: Option<Vec<Repositories>>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester: Option<serde_json::Value>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for InstallationUnsuspend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for InstallationUnsuspend {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.installation),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repositories) = &self.repositories {
                format!("{:?}", repositories)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(requester) = &self.requester {
                format!("{:?}", requester)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repositories".to_string(),
            "repository".to_string(),
            "requester".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueCommentCreated {
    pub action: Action,
    #[doc = "The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself."]
    pub comment: Comment,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssueCommentCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueCommentCreated {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.comment),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "comment".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueCommentDeleted {
    pub action: Action,
    #[doc = "The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself."]
    pub comment: Comment,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssueCommentDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueCommentDeleted {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.comment),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "comment".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssueCommentEdited {
    pub action: Action,
    #[doc = "The changes to the comment."]
    pub changes: Changes,
    #[doc = "The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself."]
    pub comment: Comment,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssueCommentEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssueCommentEdited {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            format!("{:?}", self.comment),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "comment".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "Activity related to an issue. The type of activity is specified in the action property."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesAssigned {
    #[doc = "The action that was performed."]
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<Assignee>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesAssigned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesAssigned {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(assignee) = &self.assignee {
                format!("{:?}", assignee)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "assignee".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesClosed {
    #[doc = "The action that was performed."]
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesClosed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesClosed {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesDemilestoned {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub issue: Issue,
    #[doc = "A collection of related issues and pull requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub milestone: Option<Milestone>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesDemilestoned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesDemilestoned {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(milestone) = &self.milestone {
                format!("{:?}", milestone)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "milestone".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesEdited {
    pub action: Action,
    #[doc = "The changes to the issue."]
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesEdited {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(label) = &self.label {
                format!("{:?}", label)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "label".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesLabeled {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesLabeled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesLabeled {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(label) = &self.label {
                format!("{:?}", label)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "label".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesLocked {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesLocked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesLocked {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesMilestoned {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub issue: Issue,
    #[doc = "A collection of related issues and pull requests."]
    pub milestone: Milestone,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesMilestoned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesMilestoned {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            format!("{:?}", self.milestone),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "milestone".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesOpened {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<Changes>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesOpened {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesOpened {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(changes) = &self.changes {
                format!("{:?}", changes)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesPinned {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesPinned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesPinned {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesReopened {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesReopened {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesReopened {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesTransferred {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesTransferred {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesTransferred {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesUnassigned {
    #[doc = "The action that was performed."]
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<Assignee>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesUnassigned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesUnassigned {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(assignee) = &self.assignee {
                format!("{:?}", assignee)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "assignee".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesUnlabeled {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesUnlabeled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesUnlabeled {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(label) = &self.label {
                format!("{:?}", label)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "label".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesUnlocked {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesUnlocked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesUnlocked {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IssuesUnpinned {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for IssuesUnpinned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IssuesUnpinned {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.issue),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "issue".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct LabelCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub label: Label,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for LabelCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for LabelCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.label),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "label".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct LabelDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub label: Label,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for LabelDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for LabelDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.label),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "label".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct LabelEdited {
    pub action: Action,
    #[doc = "The changes to the label if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<Changes>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub label: Label,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for LabelEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for LabelEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(changes) = &self.changes {
                format!("{:?}", changes)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.label),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "label".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MarketplacePurchaseCancelled {
    pub action: Action,
    pub effective_date: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub marketplace_purchase: MarketplacePurchase,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<PreviousMarketplacePurchase>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MarketplacePurchaseCancelled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MarketplacePurchaseCancelled {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            self.effective_date.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.marketplace_purchase),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(previous_marketplace_purchase) = &self.previous_marketplace_purchase {
                format!("{:?}", previous_marketplace_purchase)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "effective_date".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "marketplace_purchase".to_string(),
            "organization".to_string(),
            "previous_marketplace_purchase".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MarketplacePurchaseChanged {
    pub action: Action,
    pub effective_date: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub marketplace_purchase: MarketplacePurchase,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<PreviousMarketplacePurchase>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MarketplacePurchaseChanged {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MarketplacePurchaseChanged {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            self.effective_date.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.marketplace_purchase),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(previous_marketplace_purchase) = &self.previous_marketplace_purchase {
                format!("{:?}", previous_marketplace_purchase)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "effective_date".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "marketplace_purchase".to_string(),
            "organization".to_string(),
            "previous_marketplace_purchase".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MarketplacePurchasePendingChange {
    pub action: Action,
    pub effective_date: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub marketplace_purchase: MarketplacePurchase,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<PreviousMarketplacePurchase>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MarketplacePurchasePendingChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MarketplacePurchasePendingChange {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            self.effective_date.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.marketplace_purchase),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(previous_marketplace_purchase) = &self.previous_marketplace_purchase {
                format!("{:?}", previous_marketplace_purchase)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "effective_date".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "marketplace_purchase".to_string(),
            "organization".to_string(),
            "previous_marketplace_purchase".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MarketplacePurchasePendingChangeCancelled {
    pub action: Action,
    pub effective_date: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub marketplace_purchase: MarketplacePurchase,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<PreviousMarketplacePurchase>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MarketplacePurchasePendingChangeCancelled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MarketplacePurchasePendingChangeCancelled {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            self.effective_date.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.marketplace_purchase),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(previous_marketplace_purchase) = &self.previous_marketplace_purchase {
                format!("{:?}", previous_marketplace_purchase)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "effective_date".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "marketplace_purchase".to_string(),
            "organization".to_string(),
            "previous_marketplace_purchase".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MarketplacePurchasePurchased {
    pub action: Action,
    pub effective_date: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub marketplace_purchase: MarketplacePurchase,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<PreviousMarketplacePurchase>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MarketplacePurchasePurchased {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MarketplacePurchasePurchased {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            self.effective_date.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.marketplace_purchase),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(previous_marketplace_purchase) = &self.previous_marketplace_purchase {
                format!("{:?}", previous_marketplace_purchase)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "effective_date".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "marketplace_purchase".to_string(),
            "organization".to_string(),
            "previous_marketplace_purchase".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "Activity related to repository collaborators. The type of activity is specified in the action property."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MemberAdded {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<Changes>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub member: Option<Member>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MemberAdded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MemberAdded {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(changes) = &self.changes {
                format!("{:?}", changes)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.member),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "member".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MemberEdited {
    pub action: Action,
    #[doc = "The changes to the collaborator permissions"]
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub member: Option<Member>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MemberEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MemberEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.member),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "member".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MemberRemoved {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub member: Option<Member>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MemberRemoved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MemberRemoved {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.member),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "member".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MembershipAdded {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub member: Option<Member>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "The scope of the membership. Currently, can only be `team`."]
    pub scope: Scope,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<Sender>,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    pub team: Team,
}

impl std::fmt::Display for MembershipAdded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MembershipAdded {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.member),
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.scope),
            format!("{:?}", self.sender),
            format!("{:?}", self.team),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "member".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "scope".to_string(),
            "sender".to_string(),
            "team".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MembershipRemoved {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub member: Option<Member>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "The scope of the membership. Currently, can only be `team`."]
    pub scope: Scope,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<Sender>,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    pub team: Team,
}

impl std::fmt::Display for MembershipRemoved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MembershipRemoved {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.member),
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.scope),
            format!("{:?}", self.sender),
            format!("{:?}", self.team),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "member".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "scope".to_string(),
            "sender".to_string(),
            "team".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MergeGroupChecksRequested {
    pub action: String,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
    pub merge_group: MergeGroup,
}

impl std::fmt::Display for MergeGroupChecksRequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MergeGroupChecksRequested {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            self.action.clone(),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
            format!("{:?}", self.merge_group),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "merge_group".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MergeQueueEntryCreated {
    pub action: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub merge_queue: MergeQueue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub merge_queue_entry: Option<MergeQueueEntry>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for MergeQueueEntryCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MergeQueueEntryCreated {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            self.action.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.merge_queue),
            format!("{:?}", self.merge_queue_entry),
            format!("{:?}", self.message),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "merge_queue".to_string(),
            "merge_queue_entry".to_string(),
            "message".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MergeQueueEntryDeleted {
    pub action: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub merge_queue: MergeQueue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub merge_queue_entry: Option<MergeQueueEntry>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for MergeQueueEntryDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MergeQueueEntryDeleted {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            self.action.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.merge_queue),
            format!("{:?}", self.merge_queue_entry),
            format!("{:?}", self.message),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "merge_queue".to_string(),
            "merge_queue_entry".to_string(),
            "message".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MetaDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace."]
    pub hook: Hook,
    #[doc = "The id of the modified webhook."]
    pub hook_id: i64,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for MetaDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MetaDeleted {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.hook),
            format!("{:?}", self.hook_id),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "hook".to_string(),
            "hook_id".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MilestoneClosed {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "A collection of related issues and pull requests."]
    pub milestone: Milestone,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MilestoneClosed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MilestoneClosed {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.milestone),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "milestone".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MilestoneCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "A collection of related issues and pull requests."]
    pub milestone: Milestone,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MilestoneCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MilestoneCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.milestone),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "milestone".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MilestoneDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "A collection of related issues and pull requests."]
    pub milestone: Milestone,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MilestoneDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MilestoneDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.milestone),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "milestone".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MilestoneEdited {
    pub action: Action,
    #[doc = "The changes to the milestone if the action was `edited`."]
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "A collection of related issues and pull requests."]
    pub milestone: Milestone,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MilestoneEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MilestoneEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.milestone),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "milestone".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MilestoneOpened {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "A collection of related issues and pull requests."]
    pub milestone: Milestone,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for MilestoneOpened {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for MilestoneOpened {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.milestone),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "milestone".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgBlockBlocked {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blocked_user: Option<BlockedUser>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for OrgBlockBlocked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrgBlockBlocked {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.blocked_user),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "blocked_user".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgBlockUnblocked {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blocked_user: Option<BlockedUser>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for OrgBlockUnblocked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrgBlockUnblocked {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.blocked_user),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "blocked_user".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The membership between the user and the organization. Not present when the action is `member_invited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub membership: Option<Membership>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for OrganizationDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(membership) = &self.membership {
                format!("{:?}", membership)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "membership".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationMemberAdded {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The membership between the user and the organization. Not present when the action is `member_invited`."]
    pub membership: Membership,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for OrganizationMemberAdded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationMemberAdded {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.membership),
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "membership".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationMemberInvited {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The invitation for the user or email if the action is `member_invited`."]
    pub invitation: Invitation,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<User>,
}

impl std::fmt::Display for OrganizationMemberInvited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationMemberInvited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.invitation),
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            if let Some(user) = &self.user {
                format!("{:?}", user)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "invitation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "user".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationMemberRemoved {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The membership between the user and the organization. Not present when the action is `member_invited`."]
    pub membership: Membership,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for OrganizationMemberRemoved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationMemberRemoved {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.membership),
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "membership".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationRenamed {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<Changes>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The membership between the user and the organization. Not present when the action is `member_invited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub membership: Option<Membership>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for OrganizationRenamed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for OrganizationRenamed {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(changes) = &self.changes {
                format!("{:?}", changes)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(membership) = &self.membership {
                format!("{:?}", membership)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "membership".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PackagePublished {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "Information about the package."]
    pub package: Package,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PackagePublished {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PackagePublished {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.package),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "package".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PackageUpdated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "Information about the package."]
    pub package: Package,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PackageUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PackageUpdated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.package),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "package".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PackageV2Create {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    pub package: Package,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PackageV2Create {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PackageV2Create {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            format!("{:?}", self.package),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "package".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "Page Build"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PageBuildEvent {
    #[doc = "The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself."]
    pub build: Build,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    pub id: i64,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PageBuildEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PageBuildEvent {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.build),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.id),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "build".to_string(),
            "enterprise".to_string(),
            "id".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "The webhooks ping payload"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Ping {
    #[doc = "Random string of GitHub zen."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zen: Option<String>,
    #[doc = "The ID of the webhook that triggered the ping."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hook_id: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hook: Option<Hook>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for Ping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Ping {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(zen) = &self.zen {
                format!("{:?}", zen)
            } else {
                String::new()
            },
            if let Some(hook_id) = &self.hook_id {
                format!("{:?}", hook_id)
            } else {
                String::new()
            },
            if let Some(hook) = &self.hook {
                format!("{:?}", hook)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "zen".to_string(),
            "hook_id".to_string(),
            "hook".to_string(),
            "repository".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "The webhooks ping payload encoded with URL encoding."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PingFormEncoded {
    #[doc = "A URL-encoded string of the ping JSON payload. The decoded payload is a JSON object."]
    pub payload: String,
}

impl std::fmt::Display for PingFormEncoded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PingFormEncoded {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.payload.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["payload".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectCardConverted {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project_card: ProjectCard,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectCardConverted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectCardConverted {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project_card),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project_card".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectCardCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project_card: ProjectCard,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectCardCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectCardCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project_card),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project_card".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectCardDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project_card: ProjectCard,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectCardDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectCardDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project_card),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project_card".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectCardEdited {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project_card: ProjectCard,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectCardEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectCardEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project_card),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project_card".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectCardMoved {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<Changes>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project_card: ProjectCard,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectCardMoved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectCardMoved {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(changes) = &self.changes {
                format!("{:?}", changes)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project_card),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project_card".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectClosed {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project: Project,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectClosed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectClosed {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectColumnCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project_column: ProjectColumn,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ProjectColumnCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectColumnCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project_column),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project_column".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectColumnDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project_column: ProjectColumn,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ProjectColumnDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectColumnDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project_column),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project_column".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectColumnEdited {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project_column: ProjectColumn,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ProjectColumnEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectColumnEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project_column),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project_column".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectColumnMoved {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project_column: ProjectColumn,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectColumnMoved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectColumnMoved {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project_column),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project_column".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project: Project,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project: Project,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ProjectDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectEdited {
    pub action: Action,
    #[doc = "The changes to the project if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<Changes>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project: Project,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ProjectEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(changes) = &self.changes {
                format!("{:?}", changes)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectReopened {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub project: Project,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectReopened {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectReopened {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.project),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "project".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A projects v2 project"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2 {
    pub id: f64,
    pub node_id: String,
    #[doc = "Simple User"]
    pub owner: SimpleUser,
    #[doc = "Simple User"]
    pub creator: SimpleUser,
    pub title: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub public: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub short_description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deleted_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deleted_by: Option<NullableSimpleUser>,
}

impl std::fmt::Display for ProjectsV2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2 {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            self.node_id.clone(),
            format!("{:?}", self.owner),
            format!("{:?}", self.creator),
            self.title.clone(),
            format!("{:?}", self.description),
            format!("{:?}", self.public),
            format!("{:?}", self.closed_at),
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.number),
            format!("{:?}", self.short_description),
            format!("{:?}", self.deleted_at),
            format!("{:?}", self.deleted_by),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "owner".to_string(),
            "creator".to_string(),
            "title".to_string(),
            "description".to_string(),
            "public".to_string(),
            "closed_at".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "number".to_string(),
            "short_description".to_string(),
            "deleted_at".to_string(),
            "deleted_by".to_string(),
        ]
    }
}

#[doc = "A project was closed"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ProjectClosed {
    pub action: Action,
    #[doc = "A projects v2 project"]
    #[serde(rename = "projects_v2")]
    pub projects_v_2: ProjectsV2,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectsV2ProjectClosed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ProjectClosed {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.projects_v_2),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "projects_v_2".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A project was created"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ProjectCreated {
    pub action: Action,
    #[doc = "A projects v2 project"]
    #[serde(rename = "projects_v2")]
    pub projects_v_2: ProjectsV2,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectsV2ProjectCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ProjectCreated {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.projects_v_2),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "projects_v_2".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A project was edited"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ProjectEdited {
    pub action: Action,
    #[doc = "A projects v2 project"]
    #[serde(rename = "projects_v2")]
    pub projects_v_2: ProjectsV2,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub changes: Changes,
}

impl std::fmt::Display for ProjectsV2ProjectEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ProjectEdited {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.projects_v_2),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
            format!("{:?}", self.changes),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "projects_v_2".to_string(),
            "organization".to_string(),
            "sender".to_string(),
            "changes".to_string(),
        ]
    }
}

#[doc = "The type of content tracked in a project item"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ProjectsV2ItemContentType {
    Issue,
    PullRequest,
    DraftIssue,
}

#[doc = "An item belonging to a project"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2Item {
    pub id: f64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_node_id: Option<String>,
    pub content_node_id: String,
    #[doc = "The type of content tracked in a project item"]
    pub content_type: ProjectsV2ItemContentType,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub creator: Option<SimpleUser>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for ProjectsV2Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2Item {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.id),
            if let Some(node_id) = &self.node_id {
                format!("{:?}", node_id)
            } else {
                String::new()
            },
            if let Some(project_node_id) = &self.project_node_id {
                format!("{:?}", project_node_id)
            } else {
                String::new()
            },
            self.content_node_id.clone(),
            format!("{:?}", self.content_type),
            if let Some(creator) = &self.creator {
                format!("{:?}", creator)
            } else {
                String::new()
            },
            format!("{:?}", self.created_at),
            format!("{:?}", self.updated_at),
            format!("{:?}", self.archived_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "id".to_string(),
            "node_id".to_string(),
            "project_node_id".to_string(),
            "content_node_id".to_string(),
            "content_type".to_string(),
            "creator".to_string(),
            "created_at".to_string(),
            "updated_at".to_string(),
            "archived_at".to_string(),
        ]
    }
}

#[doc = "A project item was archived"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ItemArchived {
    pub action: Action,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "An item belonging to a project"]
    #[serde(rename = "projects_v2_item")]
    pub projects_v_2_item: ProjectsV2Item,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub changes: Changes,
}

impl std::fmt::Display for ProjectsV2ItemArchived {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ItemArchived {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.projects_v_2_item),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
            format!("{:?}", self.changes),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "installation".to_string(),
            "projects_v_2_item".to_string(),
            "organization".to_string(),
            "sender".to_string(),
            "changes".to_string(),
        ]
    }
}

#[doc = "A project item was converted from a draft to a different type"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ItemConverted {
    pub action: Action,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "An item belonging to a project"]
    #[serde(rename = "projects_v2_item")]
    pub projects_v_2_item: ProjectsV2Item,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub changes: Changes,
}

impl std::fmt::Display for ProjectsV2ItemConverted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ItemConverted {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.projects_v_2_item),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
            format!("{:?}", self.changes),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "installation".to_string(),
            "projects_v_2_item".to_string(),
            "organization".to_string(),
            "sender".to_string(),
            "changes".to_string(),
        ]
    }
}

#[doc = "A project item was created"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ItemCreated {
    pub action: Action,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "An item belonging to a project"]
    #[serde(rename = "projects_v2_item")]
    pub projects_v_2_item: ProjectsV2Item,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectsV2ItemCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ItemCreated {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.projects_v_2_item),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "installation".to_string(),
            "projects_v_2_item".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A project item was deleted"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ItemDeleted {
    pub action: Action,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "An item belonging to a project"]
    #[serde(rename = "projects_v2_item")]
    pub projects_v_2_item: ProjectsV2Item,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectsV2ItemDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ItemDeleted {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.projects_v_2_item),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "installation".to_string(),
            "projects_v_2_item".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "A project item was edited"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ItemEdited {
    pub action: Action,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "An item belonging to a project"]
    #[serde(rename = "projects_v2_item")]
    pub projects_v_2_item: ProjectsV2Item,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<Changes>,
}

impl std::fmt::Display for ProjectsV2ItemEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ItemEdited {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.projects_v_2_item),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
            if let Some(changes) = &self.changes {
                format!("{:?}", changes)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "installation".to_string(),
            "projects_v_2_item".to_string(),
            "organization".to_string(),
            "sender".to_string(),
            "changes".to_string(),
        ]
    }
}

#[doc = "A project item was reordered"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ItemReordered {
    pub action: Action,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "An item belonging to a project"]
    #[serde(rename = "projects_v2_item")]
    pub projects_v_2_item: ProjectsV2Item,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub changes: Changes,
}

impl std::fmt::Display for ProjectsV2ItemReordered {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ItemReordered {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.projects_v_2_item),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
            format!("{:?}", self.changes),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "installation".to_string(),
            "projects_v_2_item".to_string(),
            "organization".to_string(),
            "sender".to_string(),
            "changes".to_string(),
        ]
    }
}

#[doc = "A project item was restored from the archive"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ItemRestored {
    pub action: Action,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "An item belonging to a project"]
    #[serde(rename = "projects_v2_item")]
    pub projects_v_2_item: ProjectsV2Item,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub changes: Changes,
}

impl std::fmt::Display for ProjectsV2ItemRestored {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ItemRestored {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.projects_v_2_item),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
            format!("{:?}", self.changes),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "installation".to_string(),
            "projects_v_2_item".to_string(),
            "organization".to_string(),
            "sender".to_string(),
            "changes".to_string(),
        ]
    }
}

#[doc = "A project was reopened"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectsV2ProjectReopened {
    pub action: Action,
    #[doc = "A projects v2 project"]
    #[serde(rename = "projects_v2")]
    pub projects_v_2: ProjectsV2,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ProjectsV2ProjectReopened {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ProjectsV2ProjectReopened {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.projects_v_2),
            format!("{:?}", self.organization),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "projects_v_2".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "When a private repository is made public."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Public {
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for Public {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Public {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestAssigned {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<Assignee>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestAssigned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestAssigned {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.assignee),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "assignee".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestAutoMergeDisabled {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    pub reason: String,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestAutoMergeDisabled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestAutoMergeDisabled {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            self.reason.clone(),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "reason".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestAutoMergeEnabled {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestAutoMergeEnabled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestAutoMergeEnabled {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            if let Some(reason) = &self.reason {
                format!("{:?}", reason)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "reason".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestClosed {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestClosed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestClosed {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestConvertedToDraft {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestConvertedToDraft {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestConvertedToDraft {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestEdited {
    pub action: Action,
    #[doc = "The changes to the comment if the action was `edited`."]
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestEdited {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestLabeled {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub label: Label,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestLabeled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestLabeled {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.label),
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "label".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestLocked {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestLocked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestLocked {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestOpened {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestOpened {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestOpened {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReadyForReview {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestReadyForReview {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReadyForReview {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReopened {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestReopened {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReopened {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReviewCommentCreated {
    pub action: Action,
    #[doc = "The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself."]
    pub comment: Comment,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestReviewCommentCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReviewCommentCreated {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.comment),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "comment".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReviewCommentDeleted {
    pub action: Action,
    #[doc = "The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself."]
    pub comment: Comment,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestReviewCommentDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReviewCommentDeleted {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.comment),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "comment".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReviewCommentEdited {
    pub action: Action,
    #[doc = "The changes to the comment."]
    pub changes: Changes,
    #[doc = "The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself."]
    pub comment: Comment,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestReviewCommentEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReviewCommentEdited {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            format!("{:?}", self.comment),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "comment".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReviewDismissed {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "The review that was affected."]
    pub review: Review,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestReviewDismissed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReviewDismissed {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.review),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "review".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReviewEdited {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "The review that was affected."]
    pub review: Review,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestReviewEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReviewEdited {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.review),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "review".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
)]
#[serde(tag = "action")]
pub enum PullRequestReviewRequestRemoved {
    #[serde(rename = "review_request_removed")]
    ReviewRequestRemoved {
        enterprise: Option<Enterprise>,
        installation: Option<SimpleInstallation>,
        number: i64,
        organization: Option<OrganizationSimple>,
        pull_request: PullRequest,
        repository: Repository,
        requested_reviewer: Option<RequestedReviewer>,
        sender: SimpleUser,
    },
    #[serde(rename = "review_request_removed")]
    ReviewRequestRemoved {
        enterprise: Option<Enterprise>,
        installation: Option<SimpleInstallation>,
        number: i64,
        organization: Option<OrganizationSimple>,
        pull_request: PullRequest,
        repository: Repository,
        requested_team: RequestedTeam,
        sender: SimpleUser,
    },
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
)]
#[serde(tag = "action")]
pub enum PullRequestReviewRequested {
    #[serde(rename = "review_requested")]
    ReviewRequested {
        enterprise: Option<Enterprise>,
        installation: Option<SimpleInstallation>,
        number: i64,
        organization: Option<OrganizationSimple>,
        pull_request: PullRequest,
        repository: Repository,
        requested_reviewer: Option<RequestedReviewer>,
        sender: SimpleUser,
    },
    #[serde(rename = "review_requested")]
    ReviewRequested {
        enterprise: Option<Enterprise>,
        installation: Option<SimpleInstallation>,
        number: i64,
        organization: Option<OrganizationSimple>,
        pull_request: PullRequest,
        repository: Repository,
        requested_team: RequestedTeam,
        sender: SimpleUser,
    },
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReviewSubmitted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "The review that was affected."]
    pub review: Review,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestReviewSubmitted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReviewSubmitted {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.review),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "review".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReviewThreadResolved {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub thread: Thread,
}

impl std::fmt::Display for PullRequestReviewThreadResolved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReviewThreadResolved {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            format!("{:?}", self.thread),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "thread".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestReviewThreadUnresolved {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
    pub thread: Thread,
}

impl std::fmt::Display for PullRequestReviewThreadUnresolved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestReviewThreadUnresolved {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
            format!("{:?}", self.thread),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "thread".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestSynchronize {
    pub action: Action,
    pub after: String,
    pub before: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestSynchronize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestSynchronize {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            self.after.clone(),
            self.before.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "after".to_string(),
            "before".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestUnassigned {
    pub action: Action,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<Assignee>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestUnassigned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestUnassigned {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.assignee),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "assignee".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestUnlabeled {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub label: Label,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestUnlabeled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestUnlabeled {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.label),
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "label".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PullRequestUnlocked {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub pull_request: PullRequest,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for PullRequestUnlocked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for PullRequestUnlocked {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.number),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pull_request),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "number".to_string(),
            "organization".to_string(),
            "pull_request".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Push {
    #[doc = "The SHA of the most recent commit on `ref` after the push."]
    pub after: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub base_ref: Option<String>,
    #[doc = "The SHA of the most recent commit on `ref` before the push."]
    pub before: String,
    #[doc = "An array of commit objects describing the pushed commits. (Pushed commits are all commits that are included in the `compare` between the `before` commit and the `after` commit.) The array includes a maximum of 20 commits. If necessary, you can use the [Commits API](https://docs.github.com/en/rest/reference/repos#commits) to fetch additional commits. This limit is applied to timeline events only and isn't applied to webhook deliveries."]
    pub commits: Vec<Commits>,
    #[doc = "URL that shows the changes in this `ref` update, from the `before` commit to the `after` commit. For a newly created `ref` that is directly based on the default branch, this is the comparison between the head of the default branch and the `after` commit. Otherwise, this shows all commits until the `after` commit."]
    pub compare: String,
    #[doc = "Whether this push created the `ref`."]
    pub created: bool,
    #[doc = "Whether this push deleted the `ref`."]
    pub deleted: bool,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Whether this push was a force push of the `ref`."]
    pub forced: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub head_commit: Option<HeadCommit>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "Metaproperties for Git author/committer information."]
    pub pusher: Pusher,
    #[doc = "The full git ref that was pushed. Example: `refs/heads/main` or `refs/tags/v3.14.1`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for Push {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Push {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            self.after.clone(),
            format!("{:?}", self.base_ref),
            self.before.clone(),
            format!("{:?}", self.commits),
            self.compare.clone(),
            format!("{:?}", self.created),
            format!("{:?}", self.deleted),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.forced),
            format!("{:?}", self.head_commit),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.pusher),
            self.ref_.clone(),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "after".to_string(),
            "base_ref".to_string(),
            "before".to_string(),
            "commits".to_string(),
            "compare".to_string(),
            "created".to_string(),
            "deleted".to_string(),
            "enterprise".to_string(),
            "forced".to_string(),
            "head_commit".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "pusher".to_string(),
            "ref_".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RegistryPackagePublished {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub registry_package: RegistryPackage,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RegistryPackagePublished {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RegistryPackagePublished {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.registry_package),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "registry_package".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RegistryPackageUpdated {
    pub action: String,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub registry_package: RegistryPackage,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RegistryPackageUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RegistryPackageUpdated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            self.action.clone(),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.registry_package),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "registry_package".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReleaseCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object."]
    pub release: Release,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ReleaseCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReleaseCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.release),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "release".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReleaseDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object."]
    pub release: Release,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for ReleaseDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReleaseDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.release),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "release".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReleaseEdited {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object."]
    pub release: Release,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ReleaseEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReleaseEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.release),
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "release".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReleasePrereleased {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub release: Release,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ReleasePrereleased {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReleasePrereleased {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.release),
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "release".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReleasePublished {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub release: Release,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ReleasePublished {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReleasePublished {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.release),
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "release".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReleaseReleased {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object."]
    pub release: Release,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ReleaseReleased {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReleaseReleased {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.release),
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "release".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReleaseUnpublished {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    pub release: Release,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ReleaseUnpublished {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReleaseUnpublished {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.release),
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "release".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReminderRealtime {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ReminderRealtime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReminderRealtime {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReminderScheduled {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for ReminderScheduled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ReminderScheduled {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryArchived {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryArchived {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryArchived {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryCreated {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryDeleted {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryDispatchSample {
    pub action: String,
    pub branch: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_payload: Option<ClientPayload>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    pub installation: SimpleInstallation,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryDispatchSample {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryDispatchSample {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            self.action.clone(),
            self.branch.clone(),
            format!("{:?}", self.client_payload),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.installation),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "branch".to_string(),
            "client_payload".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryEdited {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryEdited {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryImport {
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub status: Status,
}

impl std::fmt::Display for RepositoryImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryImport {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            format!("{:?}", self.status),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "status".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryPrivatized {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryPrivatized {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryPrivatized {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryPublicized {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryPublicized {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryPublicized {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryRenamed {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryRenamed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryRenamed {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryTransferred {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryTransferred {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryTransferred {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryUnarchived {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryUnarchived {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryUnarchived {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryVulnerabilityAlertCreate {
    pub action: Action,
    pub alert: Alert,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryVulnerabilityAlertCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryVulnerabilityAlertCreate {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryVulnerabilityAlertDismiss {
    pub action: Action,
    pub alert: Alert,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryVulnerabilityAlertDismiss {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryVulnerabilityAlertDismiss {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryVulnerabilityAlertReopen {
    pub action: Action,
    pub alert: Alert,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryVulnerabilityAlertReopen {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryVulnerabilityAlertReopen {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RepositoryVulnerabilityAlertResolve {
    pub action: Action,
    pub alert: Alert,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for RepositoryVulnerabilityAlertResolve {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for RepositoryVulnerabilityAlertResolve {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecretScanningAlertCreated {
    pub action: Action,
    pub alert: SecretScanningAlert,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for SecretScanningAlertCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecretScanningAlertCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "This event occurs when secret scanning detects and creates a new location for an alert.\nFor example, when a new instance of an existing secret is detected, an additional location is added to the existing alert.\nThe new location can be accessed via the the alert view in the secret scanning UI or via the [secret scanning API](https://docs.github.com/rest/reference/secret-scanning#list-locations-for-a-secret-scanning-alert).\nThis event is available for repositories, organizations, and GitHub Apps with the `secret_scanning_alerts:read permission`."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecretScanningAlertLocationCreated {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<Action>,
    pub location: SecretScanningLocation,
    pub alert: SecretScanningAlert,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for SecretScanningAlertLocationCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecretScanningAlertLocationCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(action) = &self.action {
                format!("{:?}", action)
            } else {
                String::new()
            },
            format!("{:?}", self.location),
            format!("{:?}", self.alert),
            format!("{:?}", self.repository),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "location".to_string(),
            "alert".to_string(),
            "repository".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "sender".to_string(),
        ]
    }
}

#[doc = "The secret_scanning_alert_location.created webhook encoded with URL encoding"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecretScanningAlertLocationCreatedFormEncoded {
    #[doc = "A URL-encoded string of the secret_scanning_alert_location.created JSON payload. The decoded payload is a JSON object."]
    pub payload: String,
}

impl std::fmt::Display for SecretScanningAlertLocationCreatedFormEncoded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecretScanningAlertLocationCreatedFormEncoded {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.payload.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["payload".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecretScanningAlertReopened {
    pub action: Action,
    pub alert: SecretScanningAlert,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for SecretScanningAlertReopened {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecretScanningAlertReopened {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecretScanningAlertResolved {
    pub action: Action,
    pub alert: SecretScanningAlert,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for SecretScanningAlertResolved {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecretScanningAlertResolved {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecretScanningAlertRevoked {
    pub action: Action,
    pub alert: SecretScanningAlert,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for SecretScanningAlertRevoked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecretScanningAlertRevoked {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.alert),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "alert".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecurityAdvisoryPerformed {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "The details of the security advisory, including summary, description, and severity."]
    pub security_advisory: SecurityAdvisory,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for SecurityAdvisoryPerformed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecurityAdvisoryPerformed {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.security_advisory),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "security_advisory".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecurityAdvisoryPublished {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "The details of the security advisory, including summary, description, and severity."]
    pub security_advisory: SecurityAdvisory,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for SecurityAdvisoryPublished {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecurityAdvisoryPublished {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.security_advisory),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "security_advisory".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecurityAdvisoryUpdated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "The details of the security advisory, including summary, description, and severity."]
    pub security_advisory: SecurityAdvisory,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for SecurityAdvisoryUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecurityAdvisoryUpdated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.security_advisory),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "security_advisory".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SecurityAdvisoryWithdrawn {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "The details of the security advisory, including summary, description, and severity."]
    pub security_advisory: SecurityAdvisory,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for SecurityAdvisoryWithdrawn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SecurityAdvisoryWithdrawn {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.security_advisory),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "security_advisory".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WebhookSecurityAndAnalysis {
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "Full Repository"]
    pub repository: FullRepository,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
}

impl std::fmt::Display for WebhookSecurityAndAnalysis {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WebhookSecurityAndAnalysis {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SponsorshipCancelled {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub sponsorship: Sponsorship,
}

impl std::fmt::Display for SponsorshipCancelled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SponsorshipCancelled {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            format!("{:?}", self.sponsorship),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "sponsorship".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SponsorshipCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub sponsorship: Sponsorship,
}

impl std::fmt::Display for SponsorshipCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SponsorshipCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            format!("{:?}", self.sponsorship),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "sponsorship".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SponsorshipEdited {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub sponsorship: Sponsorship,
}

impl std::fmt::Display for SponsorshipEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SponsorshipEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            format!("{:?}", self.sponsorship),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "sponsorship".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SponsorshipPendingCancellation {
    pub action: Action,
    #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effective_date: Option<String>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub sponsorship: Sponsorship,
}

impl std::fmt::Display for SponsorshipPendingCancellation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SponsorshipPendingCancellation {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(effective_date) = &self.effective_date {
                format!("{:?}", effective_date)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            format!("{:?}", self.sponsorship),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "effective_date".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "sponsorship".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SponsorshipPendingTierChange {
    pub action: Action,
    pub changes: Changes,
    #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effective_date: Option<String>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub sponsorship: Sponsorship,
}

impl std::fmt::Display for SponsorshipPendingTierChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SponsorshipPendingTierChange {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(effective_date) = &self.effective_date {
                format!("{:?}", effective_date)
            } else {
                String::new()
            },
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            format!("{:?}", self.sponsorship),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "effective_date".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "sponsorship".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SponsorshipTierChanged {
    pub action: Action,
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub sponsorship: Sponsorship,
}

impl std::fmt::Display for SponsorshipTierChanged {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SponsorshipTierChanged {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            format!("{:?}", self.sponsorship),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "sponsorship".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct StarCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
    pub starred_at: String,
}

impl std::fmt::Display for StarCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for StarCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            self.starred_at.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "starred_at".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct StarDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub starred_at: Option<serde_json::Value>,
}

impl std::fmt::Display for StarDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for StarDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            format!("{:?}", self.starred_at),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "starred_at".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct StatusEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<url::Url>,
    #[doc = "An array of branch objects containing the status' SHA. Each branch contains the given SHA, but the SHA may or may not be the head of the branch. The array includes a maximum of 10 branches."]
    pub branches: Vec<Branches>,
    pub commit: Commit,
    pub context: String,
    pub created_at: String,
    #[doc = "The optional human-readable description added to the status."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "The unique identifier of the status."]
    pub id: i64,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    pub name: String,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[doc = "The Commit SHA."]
    pub sha: String,
    #[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
    pub state: State,
    #[doc = "The optional link added to the status."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target_url: Option<String>,
    pub updated_at: String,
}

impl std::fmt::Display for StatusEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for StatusEvent {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(avatar_url) = &self.avatar_url {
                format!("{:?}", avatar_url)
            } else {
                String::new()
            },
            format!("{:?}", self.branches),
            format!("{:?}", self.commit),
            self.context.clone(),
            self.created_at.clone(),
            format!("{:?}", self.description),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.id),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            self.name.clone(),
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            self.sha.clone(),
            format!("{:?}", self.state),
            format!("{:?}", self.target_url),
            self.updated_at.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "avatar_url".to_string(),
            "branches".to_string(),
            "commit".to_string(),
            "context".to_string(),
            "created_at".to_string(),
            "description".to_string(),
            "enterprise".to_string(),
            "id".to_string(),
            "installation".to_string(),
            "name".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "sha".to_string(),
            "state".to_string(),
            "target_url".to_string(),
            "updated_at".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamAdd {
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    pub team: Team,
}

impl std::fmt::Display for TeamAdd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamAdd {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            format!("{:?}", self.team),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "team".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamAddedToRepository {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    pub team: Team,
}

impl std::fmt::Display for TeamAddedToRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamAddedToRepository {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            format!("{:?}", self.team),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "team".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamCreated {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    pub team: Team,
}

impl std::fmt::Display for TeamCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamCreated {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            format!("{:?}", self.team),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "team".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamDeleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    pub team: Team,
}

impl std::fmt::Display for TeamDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamDeleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            if let Some(sender) = &self.sender {
                format!("{:?}", sender)
            } else {
                String::new()
            },
            format!("{:?}", self.team),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "team".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamEdited {
    pub action: Action,
    #[doc = "The changes to the team if the action was `edited`."]
    pub changes: Changes,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    pub team: Team,
}

impl std::fmt::Display for TeamEdited {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamEdited {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            format!("{:?}", self.changes),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            format!("{:?}", self.team),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "changes".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "team".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TeamRemovedFromRepository {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    pub organization: OrganizationSimple,
    #[doc = "A git repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[doc = "Groups of organization members that gives permissions on specified repositories."]
    pub team: Team,
}

impl std::fmt::Display for TeamRemovedFromRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for TeamRemovedFromRepository {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            format!("{:?}", self.organization),
            if let Some(repository) = &self.repository {
                format!("{:?}", repository)
            } else {
                String::new()
            },
            format!("{:?}", self.sender),
            format!("{:?}", self.team),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "team".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WatchStarted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
}

impl std::fmt::Display for WatchStarted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WatchStarted {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WorkflowDispatch {
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inputs: Option<Inputs>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub workflow: String,
}

impl std::fmt::Display for WorkflowDispatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WorkflowDispatch {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            format!("{:?}", self.inputs),
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            self.ref_.clone(),
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            self.workflow.clone(),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "enterprise".to_string(),
            "inputs".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "ref_".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "workflow".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WorkflowJobCompleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub workflow_job: WorkflowJob,
}

impl std::fmt::Display for WorkflowJobCompleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WorkflowJobCompleted {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            format!("{:?}", self.workflow_job),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "workflow_job".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WorkflowJobInProgress {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub workflow_job: WorkflowJob,
}

impl std::fmt::Display for WorkflowJobInProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WorkflowJobInProgress {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            format!("{:?}", self.workflow_job),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "workflow_job".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WorkflowJobQueued {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    pub workflow_job: WorkflowJob,
}

impl std::fmt::Display for WorkflowJobQueued {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WorkflowJobQueued {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            format!("{:?}", self.workflow_job),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "workflow_job".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WorkflowRunCompleted {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow: Option<Workflow>,
    pub workflow_run: WorkflowRun,
}

impl std::fmt::Display for WorkflowRunCompleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WorkflowRunCompleted {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            format!("{:?}", self.workflow),
            format!("{:?}", self.workflow_run),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "workflow".to_string(),
            "workflow_run".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WorkflowRunRequested {
    pub action: Action,
    #[doc = "An enterprise account"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enterprise: Option<Enterprise>,
    #[doc = "Simple Installation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[doc = "Organization Simple"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[doc = "A git repository"]
    pub repository: Repository,
    #[doc = "Simple User"]
    pub sender: SimpleUser,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflow: Option<Workflow>,
    pub workflow_run: WorkflowRun,
}

impl std::fmt::Display for WorkflowRunRequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for WorkflowRunRequested {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.action),
            if let Some(enterprise) = &self.enterprise {
                format!("{:?}", enterprise)
            } else {
                String::new()
            },
            if let Some(installation) = &self.installation {
                format!("{:?}", installation)
            } else {
                String::new()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization)
            } else {
                String::new()
            },
            format!("{:?}", self.repository),
            format!("{:?}", self.sender),
            format!("{:?}", self.workflow),
            format!("{:?}", self.workflow_run),
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "action".to_string(),
            "enterprise".to_string(),
            "installation".to_string(),
            "organization".to_string(),
            "repository".to_string(),
            "sender".to_string(),
            "workflow".to_string(),
            "workflow_run".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum AuditLogInclude {
    #[serde(rename = "web")]
    #[display("web")]
    Web,
    #[serde(rename = "git")]
    #[display("git")]
    Git,
    #[serde(rename = "all")]
    #[display("all")]
    All,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum AuditLogOrder {
    #[serde(rename = "desc")]
    #[display("desc")]
    Desc,
    #[serde(rename = "asc")]
    #[display("asc")]
    Asc,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum Direction {
    #[serde(rename = "asc")]
    #[display("asc")]
    Asc,
    #[serde(rename = "desc")]
    #[display("desc")]
    Desc,
}

impl std::default::Default for Direction {
    fn default() -> Self {
        Desc
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum SecretScanningAlertState {
    #[serde(rename = "open")]
    #[display("open")]
    Open,
    #[serde(rename = "resolved")]
    #[display("resolved")]
    Resolved,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum SecretScanningAlertSort {
    #[serde(rename = "created")]
    #[display("created")]
    Created,
    #[serde(rename = "updated")]
    #[display("updated")]
    Updated,
}

impl std::default::Default for SecretScanningAlertSort {
    fn default() -> Self {
        Created
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum Sort {
    #[serde(rename = "created")]
    #[display("created")]
    Created,
    #[serde(rename = "updated")]
    #[display("updated")]
    Updated,
}

impl std::default::Default for Sort {
    fn default() -> Self {
        Created
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum PackageVisibility {
    #[serde(rename = "public")]
    #[display("public")]
    Public,
    #[serde(rename = "private")]
    #[display("private")]
    Private,
    #[serde(rename = "internal")]
    #[display("internal")]
    Internal,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum PackageType {
    #[serde(rename = "npm")]
    #[display("npm")]
    Npm,
    #[serde(rename = "maven")]
    #[display("maven")]
    Maven,
    #[serde(rename = "rubygems")]
    #[display("rubygems")]
    Rubygems,
    #[serde(rename = "docker")]
    #[display("docker")]
    Docker,
    #[serde(rename = "nuget")]
    #[display("nuget")]
    Nuget,
    #[serde(rename = "container")]
    #[display("container")]
    Container,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ActionsCacheListSort {
    #[serde(rename = "created_at")]
    #[display("created_at")]
    CreatedAt,
    #[serde(rename = "last_accessed_at")]
    #[display("last_accessed_at")]
    LastAccessedAt,
    #[serde(rename = "size_in_bytes")]
    #[display("size_in_bytes")]
    SizeInBytes,
}

impl std::default::Default for ActionsCacheListSort {
    fn default() -> Self {
        LastAccessedAt
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum WorkflowRunStatus {
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[serde(rename = "action_required")]
    #[display("action_required")]
    ActionRequired,
    #[serde(rename = "cancelled")]
    #[display("cancelled")]
    Cancelled,
    #[serde(rename = "failure")]
    #[display("failure")]
    Failure,
    #[serde(rename = "neutral")]
    #[display("neutral")]
    Neutral,
    #[serde(rename = "skipped")]
    #[display("skipped")]
    Skipped,
    #[serde(rename = "stale")]
    #[display("stale")]
    Stale,
    #[serde(rename = "success")]
    #[display("success")]
    Success,
    #[serde(rename = "timed_out")]
    #[display("timed_out")]
    TimedOut,
    #[serde(rename = "in_progress")]
    #[display("in_progress")]
    InProgress,
    #[serde(rename = "queued")]
    #[display("queued")]
    Queued,
    #[serde(rename = "requested")]
    #[display("requested")]
    Requested,
    #[serde(rename = "waiting")]
    #[display("waiting")]
    Waiting,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
)]
pub enum WorkflowId {
    i64(i64),
    String(String),
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum Status {
    #[serde(rename = "queued")]
    #[display("queued")]
    Queued,
    #[serde(rename = "in_progress")]
    #[display("in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum Per {
    #[serde(rename = "")]
    #[display("")]
    Empty,
    #[serde(rename = "day")]
    #[display("day")]
    Day,
    #[serde(rename = "week")]
    #[display("week")]
    Week,
}

impl std::default::Default for Per {
    fn default() -> Self {
        Day
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum Order {
    #[serde(rename = "desc")]
    #[display("desc")]
    Desc,
    #[serde(rename = "asc")]
    #[display("asc")]
    Asc,
}

impl std::default::Default for Order {
    fn default() -> Self {
        Desc
    }
}
