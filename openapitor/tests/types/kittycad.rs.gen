#![doc = r" This module contains the generated types for the library."]
#[cfg(feature = "tabled")]
use tabled::Tabled;
pub mod base64 {
    #![doc = " Base64 data that encodes to url safe base64, but can decode from multiple"]
    #![doc = " base64 implementations to account for various clients and libraries. Compatible"]
    #![doc = " with serde and JsonSchema."]
    use serde::{
        de::{Error, Unexpected, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    };
    use std::{convert::TryFrom, fmt};
    static ALLOWED_DECODING_FORMATS: &[data_encoding::Encoding] = &[
        data_encoding::BASE64,
        data_encoding::BASE64URL,
        data_encoding::BASE64URL_NOPAD,
        data_encoding::BASE64_MIME,
        data_encoding::BASE64_NOPAD,
    ];
    #[derive(Debug, Clone, PartialEq, Eq)]
    #[doc = " A container for binary that should be base64 encoded in serialisation. In reverse"]
    #[doc = " when deserializing, will decode from many different types of base64 possible."]
    pub struct Base64Data(pub Vec<u8>);
    impl Base64Data {
        #[doc = " Return is the data is empty."]
        pub fn is_empty(&self) -> bool {
            self.0.is_empty()
        }
    }

    impl fmt::Display for Base64Data {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", data_encoding::BASE64URL_NOPAD.encode(&self.0))
        }
    }

    impl From<Base64Data> for Vec<u8> {
        fn from(data: Base64Data) -> Vec<u8> {
            data.0
        }
    }

    impl From<Vec<u8>> for Base64Data {
        fn from(data: Vec<u8>) -> Base64Data {
            Base64Data(data)
        }
    }

    impl AsRef<[u8]> for Base64Data {
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    }

    impl TryFrom<&str> for Base64Data {
        type Error = anyhow::Error;
        fn try_from(v: &str) -> Result<Self, Self::Error> {
            for config in ALLOWED_DECODING_FORMATS {
                if let Ok(data) = config.decode(v.as_bytes()) {
                    return Ok(Base64Data(data));
                }
            }
            anyhow::bail!("Could not decode base64 data: {}", v);
        }
    }

    struct Base64DataVisitor;
    impl<'de> Visitor<'de> for Base64DataVisitor {
        type Value = Base64Data;
        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            write!(formatter, "a base64 encoded string")
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: Error,
        {
            for config in ALLOWED_DECODING_FORMATS {
                if let Ok(data) = config.decode(v.as_bytes()) {
                    return Ok(Base64Data(data));
                }
            }
            Err(serde::de::Error::invalid_value(Unexpected::Str(v), &self))
        }
    }

    impl<'de> Deserialize<'de> for Base64Data {
        fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
        where
            D: Deserializer<'de>,
        {
            deserializer.deserialize_str(Base64DataVisitor)
        }
    }

    impl Serialize for Base64Data {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            let encoded = data_encoding::BASE64URL_NOPAD.encode(&self.0);
            serializer.serialize_str(&encoded)
        }
    }

    impl schemars::JsonSchema for Base64Data {
        fn schema_name() -> String {
            "Base64Data".to_string()
        }

        fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
            let mut obj = gen.root_schema_for::<String>().schema;
            obj.format = Some("byte".to_string());
            schemars::schema::Schema::Object(obj)
        }

        fn is_referenceable() -> bool {
            false
        }
    }

    #[cfg(test)]
    mod tests {
        use super::Base64Data;
        use std::convert::TryFrom;
        #[test]
        fn test_base64_try_from() {
            assert!(Base64Data::try_from("aGVsbG8=").is_ok());
            assert!(Base64Data::try_from("abcdefghij").is_err());
        }
    }
}

#[cfg(feature = "requests")]
pub mod multipart {
    #![doc = " Multipart form data types."]
    #[doc = " An attachement to a multipart form."]
    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    pub struct Attachment {
        #[doc = " The name of the field."]
        pub name: String,
        #[doc = " The filename of the attachment."]
        pub filename: Option<String>,
        #[doc = " The content type of the attachment."]
        pub content_type: Option<String>,
        #[doc = " The data of the attachment."]
        pub data: Vec<u8>,
    }

    impl std::convert::TryFrom<Attachment> for reqwest::multipart::Part {
        type Error = reqwest::Error;
        fn try_from(attachment: Attachment) -> Result<Self, Self::Error> {
            let mut part = reqwest::multipart::Part::bytes(attachment.data);
            if let Some(filename) = attachment.filename {
                part = part.file_name(filename);
            }
            if let Some(content_type) = attachment.content_type {
                part = part.mime_str(&content_type)?;
            }
            Ok(part)
        }
    }

    impl std::convert::TryFrom<std::path::PathBuf> for Attachment {
        type Error = std::io::Error;
        fn try_from(path: std::path::PathBuf) -> Result<Self, Self::Error> {
            let filename = path
                .file_name()
                .ok_or_else(|| {
                    std::io::Error::new(std::io::ErrorKind::InvalidData, "invalid filename")
                })?
                .to_str()
                .ok_or_else(|| {
                    std::io::Error::new(std::io::ErrorKind::InvalidData, "invalid filename")
                })?
                .to_string();
            let content_type = mime_guess::from_path(&path).first_raw();
            let data = std::fs::read(path)?;
            Ok(Attachment {
                name: "file".to_string(),
                filename: Some(filename),
                content_type: content_type.map(|s| s.to_string()),
                data,
            })
        }
    }
}

#[cfg(feature = "requests")]
pub mod paginate {
    #![doc = " Utility functions used for pagination."]
    use anyhow::Result;
    #[doc = " A trait for types that allow pagination."]
    pub trait Pagination {
        #[doc = " The item that is paginated."]
        type Item: serde::de::DeserializeOwned;
        #[doc = " Returns true if the response has more pages."]
        fn has_more_pages(&self) -> bool;
        #[doc = " Returns the next page token."]
        fn next_page_token(&self) -> Option<String>;
        #[doc = " Modify a request to get the next page."]
        fn next_page(
            &self,
            req: reqwest::Request,
        ) -> Result<reqwest::Request, crate::types::error::Error>;
        #[doc = " Get the items from a page."]
        fn items(&self) -> Vec<Self::Item>;
    }
}

pub mod phone_number {
    #![doc = " A library to implement phone numbers for our database and JSON serialization and deserialization."]
    use schemars::JsonSchema;
    use std::str::FromStr;
    #[doc = " A phone number."]
    #[derive(Debug, Default, Clone, PartialEq, Hash, Eq)]
    pub struct PhoneNumber(pub Option<phonenumber::PhoneNumber>);
    impl From<phonenumber::PhoneNumber> for PhoneNumber {
        fn from(id: phonenumber::PhoneNumber) -> PhoneNumber {
            PhoneNumber(Some(id))
        }
    }

    impl AsRef<Option<phonenumber::PhoneNumber>> for PhoneNumber {
        fn as_ref(&self) -> &Option<phonenumber::PhoneNumber> {
            &self.0
        }
    }

    impl std::ops::Deref for PhoneNumber {
        type Target = Option<phonenumber::PhoneNumber>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl serde::ser::Serialize for PhoneNumber {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            serializer.serialize_str(&self.to_string())
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PhoneNumber {
        fn deserialize<D>(deserializer: D) -> Result<PhoneNumber, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let s = String::deserialize(deserializer).unwrap_or_default();
            PhoneNumber::from_str(&s).map_err(serde::de::Error::custom)
        }
    }

    impl std::str::FromStr for PhoneNumber {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            if s.trim().is_empty() {
                return Ok(PhoneNumber(None));
            }
            let s = if !s.trim().starts_with('+') {
                format!("+1{s}")
            } else {
                s.to_string()
            }
            .replace(['-', '(', ')', ' '], "");
            Ok(PhoneNumber(Some(phonenumber::parse(None, &s).map_err(
                |e| anyhow::anyhow!("invalid phone number `{}`: {}", s, e),
            )?)))
        }
    }

    impl std::fmt::Display for PhoneNumber {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let s = if let Some(phone) = &self.0 {
                phone
                    .format()
                    .mode(phonenumber::Mode::International)
                    .to_string()
            } else {
                String::new()
            };
            write!(f, "{}", s)
        }
    }

    impl JsonSchema for PhoneNumber {
        fn schema_name() -> String {
            "PhoneNumber".to_string()
        }

        fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
            let mut obj = gen.root_schema_for::<String>().schema;
            obj.format = Some("phone".to_string());
            schemars::schema::Schema::Object(obj)
        }

        fn is_referenceable() -> bool {
            false
        }
    }

    #[cfg(test)]
    mod test {
        use super::PhoneNumber;
        use pretty_assertions::assert_eq;
        #[test]
        fn test_parse_phone_number() {
            let mut phone = "+1-555-555-5555";
            let mut phone_parsed: PhoneNumber =
                serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            let mut expected = PhoneNumber(Some(phonenumber::parse(None, phone).unwrap()));
            assert_eq!(phone_parsed, expected);
            let mut expected_str = "+1 555-555-5555";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "555-555-5555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "+1 555-555-5555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "5555555555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "(510) 864-1234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            expected = PhoneNumber(Some(phonenumber::parse(None, "+15108641234").unwrap()));
            assert_eq!(phone_parsed, expected);
            expected_str = "+1 510-864-1234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "(510)8641234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            expected_str = "+1 510-864-1234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, PhoneNumber(None));
            assert_eq!("", serde_json::json!(phone_parsed));
            phone = "+49 30  1234 1234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            expected = PhoneNumber(Some(phonenumber::parse(None, phone).unwrap()));
            assert_eq!(phone_parsed, expected);
            expected_str = "+49 30 12341234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
        }
    }
}

#[cfg(feature = "requests")]
pub mod error {
    #![doc = " Error methods."]
    #[doc = " Error produced by generated client methods."]
    pub enum Error {
        #[doc = " The request did not conform to API requirements."]
        InvalidRequest(String),
        #[cfg(feature = "retry")]
        #[doc = " A server error either due to the data, or with the connection."]
        CommunicationError(reqwest_middleware::Error),
        #[doc = " A request error, caused when building the request."]
        RequestError(reqwest::Error),
        #[doc = " An expected response whose deserialization failed."]
        SerdeError {
            #[doc = " The error."]
            error: format_serde_error::SerdeError,
            #[doc = " The response status."]
            status: reqwest::StatusCode,
        },
        #[doc = " An expected error response."]
        InvalidResponsePayload {
            #[cfg(feature = "retry")]
            #[doc = " The error."]
            error: reqwest_middleware::Error,
            #[cfg(not(feature = "retry"))]
            #[doc = " The error."]
            error: reqwest::Error,
            #[doc = " The full response."]
            response: reqwest::Response,
        },
        #[doc = " An error from the server."]
        Server {
            #[doc = " The text from the body."]
            body: String,
            #[doc = " The response status."]
            status: reqwest::StatusCode,
        },
        #[doc = " A response not listed in the API description. This may represent a"]
        #[doc = " success or failure response; check `status().is_success()`."]
        UnexpectedResponse(reqwest::Response),
    }

    impl Error {
        #[doc = " Returns the status code, if the error was generated from a response."]
        pub fn status(&self) -> Option<reqwest::StatusCode> {
            match self {
                Error::InvalidRequest(_) => None,
                Error::RequestError(e) => e.status(),
                #[cfg(feature = "retry")]
                Error::CommunicationError(reqwest_middleware::Error::Reqwest(e)) => e.status(),
                #[cfg(feature = "retry")]
                Error::CommunicationError(reqwest_middleware::Error::Middleware(_)) => None,
                Error::SerdeError { error: _, status } => Some(*status),
                Error::InvalidResponsePayload { error: _, response } => Some(response.status()),
                Error::Server { body: _, status } => Some(*status),
                Error::UnexpectedResponse(r) => Some(r.status()),
            }
        }

        #[doc = " Creates a new error from a response status and a serde error."]
        pub fn from_serde_error(
            e: format_serde_error::SerdeError,
            status: reqwest::StatusCode,
        ) -> Self {
            Self::SerdeError { error: e, status }
        }
    }

    #[cfg(feature = "retry")]
    impl From<reqwest_middleware::Error> for Error {
        fn from(e: reqwest_middleware::Error) -> Self {
            Self::CommunicationError(e)
        }
    }

    impl From<reqwest::Error> for Error {
        fn from(e: reqwest::Error) -> Self {
            Self::RequestError(e)
        }
    }

    impl From<serde_json::Error> for Error {
        fn from(e: serde_json::Error) -> Self {
            Self::SerdeError {
                error: format_serde_error::SerdeError::new(String::new(), e),
                status: reqwest::StatusCode::INTERNAL_SERVER_ERROR,
            }
        }
    }

    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Error::InvalidRequest(s) => {
                    write!(f, "Invalid Request: {}", s)
                }
                #[cfg(feature = "retry")]
                Error::CommunicationError(e) => {
                    write!(f, "Communication Error: {}", e)
                }
                Error::RequestError(e) => {
                    write!(f, "Request Error: {}", e)
                }
                Error::SerdeError { error, status: _ } => {
                    write!(f, "Serde Error: {}", error)
                }
                Error::InvalidResponsePayload { error, response: _ } => {
                    write!(f, "Invalid Response Payload: {}", error)
                }
                Error::Server { body, status } => {
                    write!(f, "Server Error: {} {}", status, body)
                }
                Error::UnexpectedResponse(r) => {
                    write!(f, "Unexpected Response: {:?}", r)
                }
            }
        }
    }

    trait ErrorFormat {
        fn fmt_info(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
    }

    impl std::fmt::Debug for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            std::fmt::Display::fmt(self, f)
        }
    }

    impl std::error::Error for Error {
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            match self {
                #[cfg(feature = "retry")]
                Error::CommunicationError(e) => Some(e),
                Error::SerdeError { error, status: _ } => Some(error),
                Error::InvalidResponsePayload { error, response: _ } => Some(error),
                _ => None,
            }
        }
    }
}

#[doc = "An account provider."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AccountProvider {
    #[doc = "The Apple account provider."]
    #[serde(rename = "apple")]
    #[display("apple")]
    Apple,
    #[doc = "The Discord account provider."]
    #[serde(rename = "discord")]
    #[display("discord")]
    Discord,
    #[doc = "The Google account provider."]
    #[serde(rename = "google")]
    #[display("google")]
    Google,
    #[doc = "The GitHub account provider."]
    #[serde(rename = "github")]
    #[display("github")]
    Github,
    #[doc = "The Microsoft account provider."]
    #[serde(rename = "microsoft")]
    #[display("microsoft")]
    Microsoft,
    #[doc = "The SAML account provider."]
    #[serde(rename = "saml")]
    #[display("saml")]
    Saml,
    #[doc = "The Tencent QQ account provider."]
    #[serde(rename = "tencent")]
    #[display("tencent")]
    Tencent,
}

#[doc = "Data for adding a member to an org."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AddOrgMember {
    #[doc = "The email address of the user to add to the org."]
    pub email: String,
    #[doc = "The organization role to give the user."]
    pub role: UserOrgRole,
}

impl std::fmt::Display for AddOrgMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AddOrgMember {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.email.clone().into(), format!("{:?}", self.role).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["email".into(), "role".into()]
    }
}

#[doc = "Address details."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AddressDetails {
    #[doc = "The city component."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub city: Option<String>,
    #[doc = "The country component. This is a two-letter ISO country code."]
    pub country: String,
    #[doc = "The state component."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    #[doc = "The first street component."]
    #[serde(rename = "street1", default, skip_serializing_if = "Option::is_none")]
    pub street_1: Option<String>,
    #[doc = "The second street component."]
    #[serde(rename = "street2", default, skip_serializing_if = "Option::is_none")]
    pub street_2: Option<String>,
    #[doc = "The zip component."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zip: Option<String>,
}

impl std::fmt::Display for AddressDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AddressDetails {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(city) = &self.city {
                format!("{:?}", city).into()
            } else {
                String::new().into()
            },
            self.country.clone().into(),
            if let Some(state) = &self.state {
                format!("{:?}", state).into()
            } else {
                String::new().into()
            },
            if let Some(street_1) = &self.street_1 {
                format!("{:?}", street_1).into()
            } else {
                String::new().into()
            },
            if let Some(street_2) = &self.street_2 {
                format!("{:?}", street_2).into()
            } else {
                String::new().into()
            },
            if let Some(zip) = &self.zip {
                format!("{:?}", zip).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "city".into(),
            "country".into(),
            "state".into(),
            "street_1".into(),
            "street_2".into(),
            "zip".into(),
        ]
    }
}

#[doc = "Human feedback on an AI response."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AiFeedback {
    #[doc = "Thumbs up."]
    #[serde(rename = "thumbs_up")]
    #[display("thumbs_up")]
    ThumbsUp,
    #[doc = "Thumbs down."]
    #[serde(rename = "thumbs_down")]
    #[display("thumbs_down")]
    ThumbsDown,
}

#[doc = "An AI prompt."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AiPrompt {
    #[doc = "When the prompt was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time the AI prompt was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error message if the prompt failed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "Feedback from the user, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub feedback: Option<AiFeedback>,
    #[doc = "The unique identifier for the AI Prompt."]
    pub id: uuid::Uuid,
    #[doc = "The metadata for the prompt."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    #[doc = "The version of the model."]
    pub model_version: String,
    #[doc = "The output file. In the case of TextToCad this is a link to a file in a GCP bucket."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output_file: Option<String>,
    #[doc = "The prompt."]
    pub prompt: String,
    #[doc = "When the prompt was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the prompt."]
    pub status: ApiCallStatus,
    #[doc = "The type of prompt."]
    #[serde(rename = "type")]
    pub type_: AiPromptType,
    #[doc = "The date and time the AI prompt was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the AI Prompt."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for AiPrompt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AiPrompt {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            if let Some(feedback) = &self.feedback {
                format!("{:?}", feedback).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
            self.model_version.clone().into(),
            if let Some(output_file) = &self.output_file {
                format!("{:?}", output_file).into()
            } else {
                String::new().into()
            },
            self.prompt.clone().into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.type_).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "feedback".into(),
            "id".into(),
            "metadata".into(),
            "model_version".into(),
            "output_file".into(),
            "prompt".into(),
            "started_at".into(),
            "status".into(),
            "type_".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AiPromptResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<AiPrompt>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for AiPromptResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for AiPromptResultsPage {
    type Item = AiPrompt;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AiPromptResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "A type of AI prompt."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AiPromptType {
    #[doc = "Text to CAD."]
    #[serde(rename = "text_to_cad")]
    #[display("text_to_cad")]
    TextToCad,
}

impl std::default::Default for AiPromptType {
    fn default() -> Self {
        AiPromptType::TextToCad
    }
}

#[doc = "An angle, with a specific unit."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Angle {
    #[doc = "What unit is the measurement?"]
    pub unit: UnitAngle,
    #[doc = "The size of the angle, measured in the chosen unit."]
    pub value: f64,
}

impl std::fmt::Display for Angle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Angle {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.unit).into(),
            format!("{:?}", self.value).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["unit".into(), "value".into()]
    }
}

#[doc = "Annotation line end type"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AnnotationLineEnd {
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[serde(rename = "arrow")]
    #[display("arrow")]
    Arrow,
}

#[doc = "Options for annotation text"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AnnotationLineEndOptions {
    #[doc = "How to style the end of the annotation line."]
    pub end: AnnotationLineEnd,
    #[doc = "How to style the start of the annotation line."]
    pub start: AnnotationLineEnd,
}

impl std::fmt::Display for AnnotationLineEndOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AnnotationLineEndOptions {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.end).into(),
            format!("{:?}", self.start).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["end".into(), "start".into()]
    }
}

#[doc = "Options for annotations"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AnnotationOptions {
    #[doc = "Color to render the annotation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<Color>,
    #[doc = "How to style the start and end of the line"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub line_ends: Option<AnnotationLineEndOptions>,
    #[doc = "Width of the annotation's line"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub line_width: Option<f64>,
    #[doc = "Position to put the annotation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<Point3D>,
    #[doc = "Text displayed on the annotation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<AnnotationTextOptions>,
}

impl std::fmt::Display for AnnotationOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AnnotationOptions {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(color) = &self.color {
                format!("{:?}", color).into()
            } else {
                String::new().into()
            },
            if let Some(line_ends) = &self.line_ends {
                format!("{:?}", line_ends).into()
            } else {
                String::new().into()
            },
            if let Some(line_width) = &self.line_width {
                format!("{:?}", line_width).into()
            } else {
                String::new().into()
            },
            if let Some(position) = &self.position {
                format!("{:?}", position).into()
            } else {
                String::new().into()
            },
            if let Some(text) = &self.text {
                format!("{:?}", text).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "color".into(),
            "line_ends".into(),
            "line_width".into(),
            "position".into(),
            "text".into(),
        ]
    }
}

#[doc = "Horizontal Text alignment"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AnnotationTextAlignmentX {
    #[serde(rename = "left")]
    #[display("left")]
    Left,
    #[serde(rename = "center")]
    #[display("center")]
    Center,
    #[serde(rename = "right")]
    #[display("right")]
    Right,
}

#[doc = "Vertical Text alignment"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AnnotationTextAlignmentY {
    #[serde(rename = "bottom")]
    #[display("bottom")]
    Bottom,
    #[serde(rename = "center")]
    #[display("center")]
    Center,
    #[serde(rename = "top")]
    #[display("top")]
    Top,
}

#[doc = "Options for annotation text"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AnnotationTextOptions {
    #[doc = "Text font's point size"]
    pub point_size: u32,
    #[doc = "Text displayed on the annotation"]
    pub text: String,
    #[doc = "Alignment along the X axis"]
    pub x: AnnotationTextAlignmentX,
    #[doc = "Alignment along the Y axis"]
    pub y: AnnotationTextAlignmentY,
}

impl std::fmt::Display for AnnotationTextOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AnnotationTextOptions {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.point_size).into(),
            self.text.clone().into(),
            format!("{:?}", self.x).into(),
            format!("{:?}", self.y).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["point_size".into(), "text".into(), "x".into(), "y".into()]
    }
}

#[doc = "The type of annotation"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AnnotationType {
    #[doc = "2D annotation type (screen or planar space)"]
    #[serde(rename = "t2d")]
    #[display("t2d")]
    T2D,
    #[doc = "3D annotation type"]
    #[serde(rename = "t3d")]
    #[display("t3d")]
    T3D,
}

#[doc = "A response for a query on the API call table that is grouped by something."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiCallQueryGroup {
    pub count: i64,
    pub query: String,
}

impl std::fmt::Display for ApiCallQueryGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiCallQueryGroup {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.count).into(),
            self.query.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["count".into(), "query".into()]
    }
}

#[doc = "The field of an API call to group by."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ApiCallQueryGroupBy {
    #[doc = "The email of the user that requested the API call."]
    #[serde(rename = "email")]
    #[display("email")]
    Email,
    #[doc = "The HTTP method of the API call."]
    #[serde(rename = "method")]
    #[display("method")]
    Method,
    #[doc = "The endpoint of the API call."]
    #[serde(rename = "endpoint")]
    #[display("endpoint")]
    Endpoint,
    #[doc = "The user ID of the user that requested the API call."]
    #[serde(rename = "user_id")]
    #[display("user_id")]
    UserId,
    #[doc = "The origin of the API call. This is parsed from the `Origin` header."]
    #[serde(rename = "origin")]
    #[display("origin")]
    Origin,
    #[doc = "The IP address of the user making the API call."]
    #[serde(rename = "ip_address")]
    #[display("ip_address")]
    IpAddress,
}

#[doc = "The status of an async API call."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ApiCallStatus {
    #[doc = "The async API call is queued."]
    #[serde(rename = "queued")]
    #[display("queued")]
    Queued,
    #[doc = "The async API call was uploaded to be converted."]
    #[serde(rename = "uploaded")]
    #[display("uploaded")]
    Uploaded,
    #[doc = "The async API call is in progress."]
    #[serde(rename = "in_progress")]
    #[display("in_progress")]
    InProgress,
    #[doc = "The async API call has completed."]
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[doc = "The async API call has failed."]
    #[serde(rename = "failed")]
    #[display("failed")]
    Failed,
}

#[doc = "An API call with the price.\n\nThis is a join of the `ApiCall` and `ApiCallPrice` tables."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiCallWithPrice {
    #[doc = "The date and time the API call completed billing."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The duration of the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<i64>,
    #[doc = "The user's email address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = "The endpoint requested by the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    #[doc = "The unique identifier for the API call."]
    pub id: uuid::Uuid,
    #[doc = "The ip address of the origin."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<std::net::IpAddr>,
    #[doc = "If the API call was spawned from the litterbox or not."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub litterbox: Option<bool>,
    #[doc = "The HTTP method requested by the API call."]
    pub method: Method,
    #[doc = "The number of minutes the API call was billed for."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<i32>,
    #[doc = "The organization ID of the API call if it is billable through an organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub org_id: Option<uuid::Uuid>,
    #[doc = "The origin of the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[doc = "The price of the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The request body sent by the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_body: Option<String>,
    #[doc = "The request query params sent by the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_query_params: Option<String>,
    #[doc = "The response body returned by the API call. We do not store this information if it is above a certain size."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response_body: Option<String>,
    #[doc = "The date and time the API call started billing."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status code returned by the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_code: Option<i32>,
    #[doc = "The Stripe invoice item ID of the API call if it is billable."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stripe_invoice_item_id: Option<String>,
    #[doc = "The API token that made the API call."]
    pub token: uuid::Uuid,
    #[doc = "The date and time the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user agent of the request."]
    pub user_agent: String,
    #[doc = "The ID of the user that made the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for ApiCallWithPrice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiCallWithPrice {
    const LENGTH: usize = 23;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(duration) = &self.duration {
                format!("{:?}", duration).into()
            } else {
                String::new().into()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email).into()
            } else {
                String::new().into()
            },
            if let Some(endpoint) = &self.endpoint {
                format!("{:?}", endpoint).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(ip_address) = &self.ip_address {
                format!("{:?}", ip_address).into()
            } else {
                String::new().into()
            },
            if let Some(litterbox) = &self.litterbox {
                format!("{:?}", litterbox).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.method).into(),
            if let Some(minutes) = &self.minutes {
                format!("{:?}", minutes).into()
            } else {
                String::new().into()
            },
            if let Some(org_id) = &self.org_id {
                format!("{:?}", org_id).into()
            } else {
                String::new().into()
            },
            if let Some(origin) = &self.origin {
                format!("{:?}", origin).into()
            } else {
                String::new().into()
            },
            if let Some(price) = &self.price {
                format!("{:?}", price).into()
            } else {
                String::new().into()
            },
            if let Some(request_body) = &self.request_body {
                format!("{:?}", request_body).into()
            } else {
                String::new().into()
            },
            if let Some(request_query_params) = &self.request_query_params {
                format!("{:?}", request_query_params).into()
            } else {
                String::new().into()
            },
            if let Some(response_body) = &self.response_body {
                format!("{:?}", response_body).into()
            } else {
                String::new().into()
            },
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            if let Some(status_code) = &self.status_code {
                format!("{:?}", status_code).into()
            } else {
                String::new().into()
            },
            if let Some(stripe_invoice_item_id) = &self.stripe_invoice_item_id {
                format!("{:?}", stripe_invoice_item_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.token).into(),
            format!("{:?}", self.updated_at).into(),
            self.user_agent.clone().into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "duration".into(),
            "email".into(),
            "endpoint".into(),
            "id".into(),
            "ip_address".into(),
            "litterbox".into(),
            "method".into(),
            "minutes".into(),
            "org_id".into(),
            "origin".into(),
            "price".into(),
            "request_body".into(),
            "request_query_params".into(),
            "response_body".into(),
            "started_at".into(),
            "status_code".into(),
            "stripe_invoice_item_id".into(),
            "token".into(),
            "updated_at".into(),
            "user_agent".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiCallWithPriceResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<ApiCallWithPrice>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ApiCallWithPriceResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ApiCallWithPriceResultsPage {
    type Item = ApiCallWithPrice;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiCallWithPriceResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "An error."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiError {
    #[doc = "The error code."]
    pub error_code: ErrorCode,
    #[doc = "The error message."]
    pub message: String,
}

impl std::fmt::Display for ApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiError {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.error_code).into(),
            self.message.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["error_code".into(), "message".into()]
    }
}

#[doc = "An API token.\n\nThese are used to authenticate users with Bearer authentication."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiToken {
    #[doc = "The date and time the API token was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The unique identifier for the API token."]
    pub id: uuid::Uuid,
    #[doc = "If the token is valid. We never delete API tokens, but we can mark them as invalid. We save them for ever to preserve the history of the API token."]
    pub is_valid: bool,
    #[doc = "An optional label for the API token."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[doc = "The API token itself."]
    pub token: uuid::Uuid,
    #[doc = "The date and time the API token was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The ID of the user that owns the API token."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for ApiToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiToken {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.is_valid).into(),
            if let Some(label) = &self.label {
                format!("{:?}", label).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.token).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "id".into(),
            "is_valid".into(),
            "label".into(),
            "token".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiTokenResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<ApiToken>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ApiTokenResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ApiTokenResultsPage {
    type Item = ApiToken;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiTokenResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Information about a third party app client."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AppClientInfo {
    #[doc = "The URL for consent."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

impl std::fmt::Display for AppClientInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AppClientInfo {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(url) = &self.url {
            format!("{:?}", url).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["url".into()]
    }
}

#[doc = "An async API call."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AsyncApiCall {
    #[doc = "The time and date the async API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the async API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the async API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The JSON input for the API call. These are determined by the endpoint that is run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<serde_json::Value>,
    #[doc = "The JSON output for the API call. These are determined by the endpoint that is run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<serde_json::Value>,
    #[doc = "The time and date the async API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the async API call."]
    pub status: ApiCallStatus,
    #[doc = "The type of async API call."]
    #[serde(rename = "type")]
    pub type_: AsyncApiCallType,
    #[doc = "The time and date the async API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the async API call."]
    pub user_id: uuid::Uuid,
    #[doc = "The worker node that is performing or performed the async API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub worker: Option<String>,
}

impl std::fmt::Display for AsyncApiCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AsyncApiCall {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.type_).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
            if let Some(worker) = &self.worker {
                format!("{:?}", worker).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "output".into(),
            "started_at".into(),
            "status".into(),
            "type_".into(),
            "updated_at".into(),
            "user_id".into(),
            "worker".into(),
        ]
    }
}

#[doc = "The output from the async API call."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum AsyncApiCallOutput {
    #[doc = "A file conversion."]
    #[serde(rename = "file_conversion")]
    FileConversion {
        #[doc = "The time and date the API call was completed."]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The output format of the file conversion."]
        output_format: FileExportFormat,
        #[doc = "The output format options of the file conversion."]
        output_format_options: Option<OutputFormat>,
        #[doc = "The converted files (if multiple file conversion), if completed, base64 encoded. The key of the map is the path of the output file."]
        outputs: Option<std::collections::HashMap<String, base64::Base64Data>>,
        #[doc = "The source format of the file conversion."]
        src_format: FileImportFormat,
        #[doc = "The source format options of the file conversion."]
        src_format_options: Option<InputFormat>,
        #[doc = "The time and date the API call was started."]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "File center of mass."]
    #[serde(rename = "file_center_of_mass")]
    FileCenterOfMass {
        #[doc = "The resulting center of mass."]
        center_of_mass: Option<Point3D>,
        #[doc = "The time and date the API call was completed."]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The output unit for the center of mass."]
        output_unit: UnitLength,
        #[doc = "The source format of the file."]
        src_format: FileImportFormat,
        #[doc = "The time and date the API call was started."]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "A file mass."]
    #[serde(rename = "file_mass")]
    FileMass {
        #[doc = "The time and date the API call was completed."]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The resulting mass."]
        mass: Option<f64>,
        #[doc = "The material density as denoted by the user."]
        material_density: Option<f64>,
        #[doc = "The material density unit."]
        material_density_unit: UnitDensity,
        #[doc = "The output unit for the mass."]
        output_unit: UnitMass,
        #[doc = "The source format of the file."]
        src_format: FileImportFormat,
        #[doc = "The time and date the API call was started."]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "A file volume."]
    #[serde(rename = "file_volume")]
    FileVolume {
        #[doc = "The time and date the API call was completed."]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The output unit for the volume."]
        output_unit: UnitVolume,
        #[doc = "The source format of the file."]
        src_format: FileImportFormat,
        #[doc = "The time and date the API call was started."]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
        #[doc = "The resulting volume."]
        volume: Option<f64>,
    },
    #[doc = "A file density."]
    #[serde(rename = "file_density")]
    FileDensity {
        #[doc = "The time and date the API call was completed."]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The resulting density."]
        density: Option<f64>,
        #[doc = "The error the function returned, if any."]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The material mass as denoted by the user."]
        material_mass: Option<f64>,
        #[doc = "The material mass unit."]
        material_mass_unit: UnitMass,
        #[doc = "The output unit for the density."]
        output_unit: UnitDensity,
        #[doc = "The source format of the file."]
        src_format: FileImportFormat,
        #[doc = "The time and date the API call was started."]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "A file surface area."]
    #[serde(rename = "file_surface_area")]
    FileSurfaceArea {
        #[doc = "The time and date the API call was completed."]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The output unit for the surface area."]
        output_unit: UnitArea,
        #[doc = "The source format of the file."]
        src_format: FileImportFormat,
        #[doc = "The time and date the API call was started."]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The resulting surface area."]
        surface_area: Option<f64>,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "Text to CAD."]
    #[serde(rename = "text_to_cad")]
    TextToCad {
        #[doc = "The time and date the API call was completed."]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        error: Option<String>,
        #[doc = "Feedback from the user, if any."]
        feedback: Option<AiFeedback>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The version of the model."]
        model_version: String,
        #[doc = "The output format of the model."]
        output_format: FileExportFormat,
        #[doc = "The output of the model in the given file format the user requested, base64 encoded. The key of the map is the path of the output file."]
        outputs: Option<std::collections::HashMap<String, base64::Base64Data>>,
        #[doc = "The prompt."]
        prompt: String,
        #[doc = "The time and date the API call was started."]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AsyncApiCallResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<AsyncApiCall>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for AsyncApiCallResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for AsyncApiCallResultsPage {
    type Item = AsyncApiCall;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AsyncApiCallResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "The type of async API call."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AsyncApiCallType {
    #[doc = "File conversion."]
    #[serde(rename = "file_conversion")]
    #[display("file_conversion")]
    FileConversion,
    #[doc = "File volume."]
    #[serde(rename = "file_volume")]
    #[display("file_volume")]
    FileVolume,
    #[doc = "File center of mass."]
    #[serde(rename = "file_center_of_mass")]
    #[display("file_center_of_mass")]
    FileCenterOfMass,
    #[doc = "File mass."]
    #[serde(rename = "file_mass")]
    #[display("file_mass")]
    FileMass,
    #[doc = "File density."]
    #[serde(rename = "file_density")]
    #[display("file_density")]
    FileDensity,
    #[doc = "File surface area."]
    #[serde(rename = "file_surface_area")]
    #[display("file_surface_area")]
    FileSurfaceArea,
    #[doc = "Text to CAD."]
    #[serde(rename = "text_to_cad")]
    #[display("text_to_cad")]
    TextToCad,
}

#[doc = "The authentication callback from the OAuth 2.0 client. This is typically posted to the redirect URL as query params after authenticating."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AuthCallback {
    #[doc = "The authorization code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[doc = "For Apple only, a JSON web token containing the user’s identity information."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id_token: Option<String>,
    #[doc = "The state that we had passed in through the user consent URL."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    #[doc = "For Apple only, a JSON string containing the data requested in the scope property. The returned data is in the following format: `{ \"name\": { \"firstName\": string, \"lastName\": string }, \"email\": string }`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

impl std::fmt::Display for AuthCallback {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AuthCallback {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(code) = &self.code {
                format!("{:?}", code).into()
            } else {
                String::new().into()
            },
            if let Some(id_token) = &self.id_token {
                format!("{:?}", id_token).into()
            } else {
                String::new().into()
            },
            if let Some(state) = &self.state {
                format!("{:?}", state).into()
            } else {
                String::new().into()
            },
            if let Some(user) = &self.user {
                format!("{:?}", user).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "code".into(),
            "id_token".into(),
            "state".into(),
            "user".into(),
        ]
    }
}

#[doc = "Co-ordinate axis specifier.\n\nSee [cglearn.eu] for background reading.\n\n[cglearn.eu]: https://cglearn.eu/pub/computer-graphics/introduction-to-geometry#material-coordinate-systems-1"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Axis {
    #[doc = "'Y' axis."]
    #[serde(rename = "y")]
    #[display("y")]
    Y,
    #[doc = "'Z' axis."]
    #[serde(rename = "z")]
    #[display("z")]
    Z,
}

#[doc = "An [`Axis`] paired with a [`Direction`]."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AxisDirectionPair {
    #[doc = "Axis specifier."]
    pub axis: Axis,
    #[doc = "Specifies which direction the axis is pointing."]
    pub direction: Direction,
}

impl std::fmt::Display for AxisDirectionPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AxisDirectionPair {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.axis).into(),
            format!("{:?}", self.direction).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["axis".into(), "direction".into()]
    }
}

#[doc = "The billing information for payments."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BillingInfo {
    #[doc = "The address of the customer."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<AddressDetails>,
    #[doc = "The name of the customer."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The phone for the customer."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
}

impl std::fmt::Display for BillingInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for BillingInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(address) = &self.address {
                format!("{:?}", address).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["address".into(), "name".into(), "phone".into()]
    }
}

#[doc = "The reason for blocking a user."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum BlockReason {
    #[doc = "The user is missing a payment method and has exceeded their free API call credits for the month."]
    #[serde(rename = "missing_payment_method")]
    #[display("missing_payment_method")]
    MissingPaymentMethod,
    #[doc = "The users payment method has failed."]
    #[serde(rename = "payment_method_failed")]
    #[display("payment_method_failed")]
    PaymentMethodFailed,
}

#[doc = "Metadata about our cache.\n\nThis is mostly used for internal purposes and debugging."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CacheMetadata {
    #[doc = "If the cache returned an ok response from ping."]
    pub ok: bool,
}

impl std::fmt::Display for CacheMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CacheMetadata {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.ok).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["ok".into()]
    }
}

#[doc = "The response from the `CameraDragEnd` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CameraDragEnd {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for CameraDragEnd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CameraDragEnd {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}

#[doc = "The type of camera drag interaction."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CameraDragInteractionType {
    #[doc = "Camera pan"]
    #[serde(rename = "pan")]
    #[display("pan")]
    Pan,
    #[doc = "Camera rotate (revolve/orbit)"]
    #[serde(rename = "rotate")]
    #[display("rotate")]
    Rotate,
    #[doc = "Camera zoom (increase or decrease distance to reference point center)"]
    #[serde(rename = "zoom")]
    #[display("zoom")]
    Zoom,
}

#[doc = "The response from the `CameraDragMove` command. Note this is an \"unreliable\" channel message, so this data may need more data like a \"sequence\""]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CameraDragMove {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for CameraDragMove {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CameraDragMove {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}

#[doc = "Camera settings including position, center, fov etc"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CameraSettings {
    #[doc = "Camera's look-at center (center-pos gives viewing vector)"]
    pub center: Point3D,
    #[doc = "Camera's field-of-view angle (if ortho is false)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fov_y: Option<f64>,
    #[doc = "Whether or not the camera is in ortho mode"]
    pub ortho: bool,
    #[doc = "The camera's ortho scale (derived from viewing distance if ortho is true)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ortho_scale: Option<f64>,
    #[doc = "Camera position (vantage)"]
    pub pos: Point3D,
    #[doc = "Camera's world-space up vector"]
    pub up: Point3D,
}

impl std::fmt::Display for CameraSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CameraSettings {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.center).into(),
            if let Some(fov_y) = &self.fov_y {
                format!("{:?}", fov_y).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.ortho).into(),
            if let Some(ortho_scale) = &self.ortho_scale {
                format!("{:?}", ortho_scale).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.pos).into(),
            format!("{:?}", self.up).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "center".into(),
            "fov_y".into(),
            "ortho".into(),
            "ortho_scale".into(),
            "pos".into(),
            "up".into(),
        ]
    }
}

#[doc = "The card details of a payment method."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CardDetails {
    #[doc = "Card brand.\n\nCan be `amex`, `diners`, `discover`, `jcb`, `mastercard`, `unionpay`, `visa`, or `unknown`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub brand: Option<String>,
    #[doc = "Checks on Card address and CVC if provided."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<PaymentMethodCardChecks>,
    #[doc = "Two-letter ISO code representing the country of the card."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
    #[doc = "Two-digit number representing the card's expiration month."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exp_month: Option<i64>,
    #[doc = "Four-digit number representing the card's expiration year."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exp_year: Option<i64>,
    #[doc = "Uniquely identifies this particular card number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fingerprint: Option<String>,
    #[doc = "Card funding type.\n\nCan be `credit`, `debit`, `prepaid`, or `unknown`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub funding: Option<String>,
    #[doc = "The last four digits of the card."]
    #[serde(rename = "last4", default, skip_serializing_if = "Option::is_none")]
    pub last_4: Option<String>,
}

impl std::fmt::Display for CardDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CardDetails {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(brand) = &self.brand {
                format!("{:?}", brand).into()
            } else {
                String::new().into()
            },
            if let Some(checks) = &self.checks {
                format!("{:?}", checks).into()
            } else {
                String::new().into()
            },
            if let Some(country) = &self.country {
                format!("{:?}", country).into()
            } else {
                String::new().into()
            },
            if let Some(exp_month) = &self.exp_month {
                format!("{:?}", exp_month).into()
            } else {
                String::new().into()
            },
            if let Some(exp_year) = &self.exp_year {
                format!("{:?}", exp_year).into()
            } else {
                String::new().into()
            },
            if let Some(fingerprint) = &self.fingerprint {
                format!("{:?}", fingerprint).into()
            } else {
                String::new().into()
            },
            if let Some(funding) = &self.funding {
                format!("{:?}", funding).into()
            } else {
                String::new().into()
            },
            if let Some(last_4) = &self.last_4 {
                format!("{:?}", last_4).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "brand".into(),
            "checks".into(),
            "country".into(),
            "exp_month".into(),
            "exp_year".into(),
            "fingerprint".into(),
            "funding".into(),
            "last_4".into(),
        ]
    }
}

#[doc = "The center of mass response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CenterOfMass {
    #[doc = "The center of mass."]
    pub center_of_mass: Point3D,
    #[doc = "The output unit for the center of mass."]
    pub output_unit: UnitLength,
}

impl std::fmt::Display for CenterOfMass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CenterOfMass {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.center_of_mass).into(),
            format!("{:?}", self.output_unit).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["center_of_mass".into(), "output_unit".into()]
    }
}

#[doc = "ClientMetrics contains information regarding the state of the peer."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ClientMetrics {
    #[doc = "Counter of the number of WebRTC frames that the client has decoded during this session."]
    pub rtc_frames_decoded: u64,
    #[doc = "Counter of the number of WebRTC frames the client has dropped during this session."]
    pub rtc_frames_dropped: u32,
    #[doc = "Current number of frames being rendered per second. A good target is 60 frames per second, but it can fluctuate depending on network conditions."]
    pub rtc_frames_per_second: u8,
    #[doc = "Counter of the number of WebRTC frames that the client has received during this session."]
    pub rtc_frames_received: u64,
    #[doc = "Number of times the WebRTC playback has frozen. This is usually due to network conditions."]
    pub rtc_freeze_count: u32,
    #[doc = "Amount of \"jitter\" in the WebRTC session. Network latency is the time it takes a packet to traverse the network. The amount that the latency varies is the jitter. Video latency is the time it takes to render a frame sent by the server (including network latency). A low jitter means the video latency can be reduced without impacting smooth playback. High jitter means clients will increase video latency to ensure smooth playback."]
    pub rtc_jitter_sec: f64,
    #[doc = "Number of \"key frames\" decoded in the underlying h.264 stream. A key frame is an expensive (bandwidth-wise) \"full image\" of the video frame. Data after the keyframe become -- effectively -- \"diff\" operations on that key frame. The Engine will only send a keyframe if required, which is an indication that some of the \"diffs\" have been lost, usually an indication of poor network conditions. We like this metric to understand times when the connection has had to recover."]
    pub rtc_keyframes_decoded: u32,
    #[doc = "Number of seconds of frozen video the user has been subjected to."]
    pub rtc_total_freezes_duration_sec: f64,
}

impl std::fmt::Display for ClientMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ClientMetrics {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.rtc_frames_decoded).into(),
            format!("{:?}", self.rtc_frames_dropped).into(),
            format!("{:?}", self.rtc_frames_per_second).into(),
            format!("{:?}", self.rtc_frames_received).into(),
            format!("{:?}", self.rtc_freeze_count).into(),
            format!("{:?}", self.rtc_jitter_sec).into(),
            format!("{:?}", self.rtc_keyframes_decoded).into(),
            format!("{:?}", self.rtc_total_freezes_duration_sec).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "rtc_frames_decoded".into(),
            "rtc_frames_dropped".into(),
            "rtc_frames_per_second".into(),
            "rtc_frames_received".into(),
            "rtc_freeze_count".into(),
            "rtc_jitter_sec".into(),
            "rtc_keyframes_decoded".into(),
            "rtc_total_freezes_duration_sec".into(),
        ]
    }
}

#[doc = "Cluster information."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Cluster {
    #[doc = "The IP address of the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    #[doc = "The auth timeout of the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_timeout: Option<i64>,
    #[doc = "The port of the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster_port: Option<i64>,
    #[doc = "The name of the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The TLS timeout for the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_timeout: Option<i64>,
    #[doc = "The urls of the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub urls: Option<Vec<String>>,
}

impl std::fmt::Display for Cluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Cluster {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(addr) = &self.addr {
                format!("{:?}", addr).into()
            } else {
                String::new().into()
            },
            if let Some(auth_timeout) = &self.auth_timeout {
                format!("{:?}", auth_timeout).into()
            } else {
                String::new().into()
            },
            if let Some(cluster_port) = &self.cluster_port {
                format!("{:?}", cluster_port).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            if let Some(tls_timeout) = &self.tls_timeout {
                format!("{:?}", tls_timeout).into()
            } else {
                String::new().into()
            },
            if let Some(urls) = &self.urls {
                format!("{:?}", urls).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "addr".into(),
            "auth_timeout".into(),
            "cluster_port".into(),
            "name".into(),
            "tls_timeout".into(),
            "urls".into(),
        ]
    }
}

#[doc = "The language code is written in.\n\n<details><summary>JSON schema</summary>\n\n```json { \"description\": \"The language code is written in.\", \"oneOf\": [ { \"description\": \"The `go` programming language.\", \"type\": \"string\", \"enum\": [ \"go\" ] }, { \"description\": \"The `python` programming language.\", \"type\": \"string\", \"enum\": [ \"python\" ] }, { \"description\": \"The `node` programming language.\", \"type\": \"string\", \"enum\": [ \"node\" ] } ] } ``` </details>"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CodeLanguage {
    #[doc = "The `go` programming language."]
    #[serde(rename = "go")]
    #[display("go")]
    Go,
    #[doc = "The `python` programming language."]
    #[serde(rename = "python")]
    #[display("python")]
    Python,
    #[doc = "The `node` programming language."]
    #[serde(rename = "node")]
    #[display("node")]
    Node,
}

#[doc = "Output of the code being executed.\n\n<details><summary>JSON schema</summary>\n\n```json { \"description\": \"Output of the code being executed.\", \"type\": \"object\", \"properties\": { \"output_files\": { \"description\": \"The contents of the files requested if they were passed.\", \"type\": \"array\", \"items\": { \"$ref\": \"#/components/schemas/OutputFile\" } }, \"stderr\": { \"description\": \"The stderr of the code.\", \"default\": \"\", \"type\": \"string\" }, \"stdout\": { \"description\": \"The stdout of the code.\", \"default\": \"\", \"type\": \"string\" } } } ``` </details>"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeOutput {
    #[doc = "The contents of the files requested if they were passed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output_files: Option<Vec<OutputFile>>,
    #[doc = "The stderr of the code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<String>,
    #[doc = "The stdout of the code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<String>,
}

impl std::fmt::Display for CodeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CodeOutput {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(output_files) = &self.output_files {
                format!("{:?}", output_files).into()
            } else {
                String::new().into()
            },
            if let Some(stderr) = &self.stderr {
                format!("{:?}", stderr).into()
            } else {
                String::new().into()
            },
            if let Some(stdout) = &self.stdout {
                format!("{:?}", stdout).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["output_files".into(), "stderr".into(), "stdout".into()]
    }
}

#[doc = "An RGBA color"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Color {
    #[doc = "Alpha"]
    pub a: f64,
    #[doc = "Blue"]
    pub b: f64,
    #[doc = "Green"]
    pub g: f64,
    #[doc = "Red"]
    pub r: f64,
}

impl std::fmt::Display for Color {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Color {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.a).into(),
            format!("{:?}", self.b).into(),
            format!("{:?}", self.g).into(),
            format!("{:?}", self.r).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["a".into(), "b".into(), "g".into(), "r".into()]
    }
}

#[doc = "Metadata about a pub-sub connection.\n\nThis is mostly used for internal purposes and debugging."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Connection {
    #[doc = "The auth timeout of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_timeout: Option<i64>,
    #[doc = "Information about the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<Cluster>,
    #[doc = "The time the configuration was loaded."]
    pub config_load_time: chrono::DateTime<chrono::Utc>,
    #[doc = "The number of connections to the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connections: Option<i64>,
    #[doc = "The CPU core usage of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cores: Option<i64>,
    #[doc = "The CPU usage of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<f64>,
    #[doc = "Information about the gateway."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<Gateway>,
    #[doc = "The git commit."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git_commit: Option<String>,
    #[doc = "The go version."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub go: Option<String>,
    #[doc = "`GOMAXPROCS` of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gomaxprocs: Option<i64>,
    #[doc = "The host of the server."]
    pub host: std::net::IpAddr,
    #[doc = "The http base path of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_base_path: Option<String>,
    #[doc = "The http host of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_host: Option<String>,
    #[doc = "The http port of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_port: Option<i64>,
    #[doc = "HTTP request statistics."]
    pub http_req_stats: std::collections::HashMap<String, i64>,
    #[doc = "The https port of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub https_port: Option<i64>,
    #[doc = "The count of inbound bytes for the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub in_bytes: Option<i64>,
    #[doc = "The number of inbound messages for the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub in_msgs: Option<i64>,
    #[doc = "Jetstream information."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jetstream: Option<Jetstream>,
    #[doc = "Information about leaf nodes."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub leaf: Option<LeafNode>,
    #[doc = "The number of leaf nodes for the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub leafnodes: Option<i64>,
    #[doc = "The max connections of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_connections: Option<i64>,
    #[doc = "The max control line of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_control_line: Option<i64>,
    #[doc = "The max payload of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_payload: Option<i64>,
    #[doc = "The max pending of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_pending: Option<i64>,
    #[doc = "The memory usage of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mem: Option<i64>,
    #[doc = "The time now."]
    pub now: chrono::DateTime<chrono::Utc>,
    #[doc = "The count of outbound bytes for the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub out_bytes: Option<i64>,
    #[doc = "The number of outbound messages for the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub out_msgs: Option<i64>,
    #[doc = "The ping interval of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ping_interval: Option<i64>,
    #[doc = "The ping max of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ping_max: Option<i64>,
    #[doc = "The port of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    #[doc = "The protocol version."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proto: Option<i64>,
    #[doc = "The number of remotes for the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remotes: Option<i64>,
    #[doc = "The number of routes for the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub routes: Option<i64>,
    #[doc = "The server ID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server_id: Option<String>,
    #[doc = "The server name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server_name: Option<String>,
    #[doc = "The number of slow consumers for the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slow_consumers: Option<i64>,
    #[doc = "When the server was started."]
    pub start: chrono::DateTime<chrono::Utc>,
    #[doc = "The number of subscriptions for the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscriptions: Option<i64>,
    #[doc = "The system account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub system_account: Option<String>,
    #[doc = "The TLS timeout of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_timeout: Option<i64>,
    #[doc = "The total number of connections to the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total_connections: Option<i64>,
    #[doc = "The uptime of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uptime: Option<String>,
    #[doc = "The version of the service."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    #[doc = "The write deadline of the server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub write_deadline: Option<i64>,
}

impl std::fmt::Display for Connection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Connection {
    const LENGTH: usize = 46;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(auth_timeout) = &self.auth_timeout {
                format!("{:?}", auth_timeout).into()
            } else {
                String::new().into()
            },
            if let Some(cluster) = &self.cluster {
                format!("{:?}", cluster).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.config_load_time).into(),
            if let Some(connections) = &self.connections {
                format!("{:?}", connections).into()
            } else {
                String::new().into()
            },
            if let Some(cores) = &self.cores {
                format!("{:?}", cores).into()
            } else {
                String::new().into()
            },
            if let Some(cpu) = &self.cpu {
                format!("{:?}", cpu).into()
            } else {
                String::new().into()
            },
            if let Some(gateway) = &self.gateway {
                format!("{:?}", gateway).into()
            } else {
                String::new().into()
            },
            if let Some(git_commit) = &self.git_commit {
                format!("{:?}", git_commit).into()
            } else {
                String::new().into()
            },
            if let Some(go) = &self.go {
                format!("{:?}", go).into()
            } else {
                String::new().into()
            },
            if let Some(gomaxprocs) = &self.gomaxprocs {
                format!("{:?}", gomaxprocs).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.host).into(),
            if let Some(http_base_path) = &self.http_base_path {
                format!("{:?}", http_base_path).into()
            } else {
                String::new().into()
            },
            if let Some(http_host) = &self.http_host {
                format!("{:?}", http_host).into()
            } else {
                String::new().into()
            },
            if let Some(http_port) = &self.http_port {
                format!("{:?}", http_port).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.http_req_stats).into(),
            if let Some(https_port) = &self.https_port {
                format!("{:?}", https_port).into()
            } else {
                String::new().into()
            },
            if let Some(in_bytes) = &self.in_bytes {
                format!("{:?}", in_bytes).into()
            } else {
                String::new().into()
            },
            if let Some(in_msgs) = &self.in_msgs {
                format!("{:?}", in_msgs).into()
            } else {
                String::new().into()
            },
            if let Some(jetstream) = &self.jetstream {
                format!("{:?}", jetstream).into()
            } else {
                String::new().into()
            },
            if let Some(leaf) = &self.leaf {
                format!("{:?}", leaf).into()
            } else {
                String::new().into()
            },
            if let Some(leafnodes) = &self.leafnodes {
                format!("{:?}", leafnodes).into()
            } else {
                String::new().into()
            },
            if let Some(max_connections) = &self.max_connections {
                format!("{:?}", max_connections).into()
            } else {
                String::new().into()
            },
            if let Some(max_control_line) = &self.max_control_line {
                format!("{:?}", max_control_line).into()
            } else {
                String::new().into()
            },
            if let Some(max_payload) = &self.max_payload {
                format!("{:?}", max_payload).into()
            } else {
                String::new().into()
            },
            if let Some(max_pending) = &self.max_pending {
                format!("{:?}", max_pending).into()
            } else {
                String::new().into()
            },
            if let Some(mem) = &self.mem {
                format!("{:?}", mem).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.now).into(),
            if let Some(out_bytes) = &self.out_bytes {
                format!("{:?}", out_bytes).into()
            } else {
                String::new().into()
            },
            if let Some(out_msgs) = &self.out_msgs {
                format!("{:?}", out_msgs).into()
            } else {
                String::new().into()
            },
            if let Some(ping_interval) = &self.ping_interval {
                format!("{:?}", ping_interval).into()
            } else {
                String::new().into()
            },
            if let Some(ping_max) = &self.ping_max {
                format!("{:?}", ping_max).into()
            } else {
                String::new().into()
            },
            if let Some(port) = &self.port {
                format!("{:?}", port).into()
            } else {
                String::new().into()
            },
            if let Some(proto) = &self.proto {
                format!("{:?}", proto).into()
            } else {
                String::new().into()
            },
            if let Some(remotes) = &self.remotes {
                format!("{:?}", remotes).into()
            } else {
                String::new().into()
            },
            if let Some(routes) = &self.routes {
                format!("{:?}", routes).into()
            } else {
                String::new().into()
            },
            if let Some(server_id) = &self.server_id {
                format!("{:?}", server_id).into()
            } else {
                String::new().into()
            },
            if let Some(server_name) = &self.server_name {
                format!("{:?}", server_name).into()
            } else {
                String::new().into()
            },
            if let Some(slow_consumers) = &self.slow_consumers {
                format!("{:?}", slow_consumers).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.start).into(),
            if let Some(subscriptions) = &self.subscriptions {
                format!("{:?}", subscriptions).into()
            } else {
                String::new().into()
            },
            if let Some(system_account) = &self.system_account {
                format!("{:?}", system_account).into()
            } else {
                String::new().into()
            },
            if let Some(tls_timeout) = &self.tls_timeout {
                format!("{:?}", tls_timeout).into()
            } else {
                String::new().into()
            },
            if let Some(total_connections) = &self.total_connections {
                format!("{:?}", total_connections).into()
            } else {
                String::new().into()
            },
            if let Some(uptime) = &self.uptime {
                format!("{:?}", uptime).into()
            } else {
                String::new().into()
            },
            if let Some(version) = &self.version {
                format!("{:?}", version).into()
            } else {
                String::new().into()
            },
            if let Some(write_deadline) = &self.write_deadline {
                format!("{:?}", write_deadline).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "auth_timeout".into(),
            "cluster".into(),
            "config_load_time".into(),
            "connections".into(),
            "cores".into(),
            "cpu".into(),
            "gateway".into(),
            "git_commit".into(),
            "go".into(),
            "gomaxprocs".into(),
            "host".into(),
            "http_base_path".into(),
            "http_host".into(),
            "http_port".into(),
            "http_req_stats".into(),
            "https_port".into(),
            "in_bytes".into(),
            "in_msgs".into(),
            "jetstream".into(),
            "leaf".into(),
            "leafnodes".into(),
            "max_connections".into(),
            "max_control_line".into(),
            "max_payload".into(),
            "max_pending".into(),
            "mem".into(),
            "now".into(),
            "out_bytes".into(),
            "out_msgs".into(),
            "ping_interval".into(),
            "ping_max".into(),
            "port".into(),
            "proto".into(),
            "remotes".into(),
            "routes".into(),
            "server_id".into(),
            "server_name".into(),
            "slow_consumers".into(),
            "start".into(),
            "subscriptions".into(),
            "system_account".into(),
            "tls_timeout".into(),
            "total_connections".into(),
            "uptime".into(),
            "version".into(),
            "write_deadline".into(),
        ]
    }
}

#[doc = "The resource representing a Coupon."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Coupon {
    #[doc = "Amount (in the `currency` specified) that will be taken off the subtotal of any invoices for this customer."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount_off: Option<f64>,
    #[doc = "Always true for a deleted object."]
    #[serde(default)]
    pub deleted: bool,
    #[doc = "Unique identifier for the object."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Set of key-value pairs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
    #[doc = "Name of the coupon displayed to customers on, for instance invoices, or receipts.\n\nBy default the `id` is shown if `name` is not set."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Percent that will be taken off the subtotal of any invoices for this customer for the duration of the coupon.\n\nFor example, a coupon with percent_off of 50 will make a %s100 invoice %s50 instead."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent_off: Option<f64>,
}

impl std::fmt::Display for Coupon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Coupon {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(amount_off) = &self.amount_off {
                format!("{:?}", amount_off).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.deleted).into(),
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            if let Some(percent_off) = &self.percent_off {
                format!("{:?}", percent_off).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "amount_off".into(),
            "deleted".into(),
            "id".into(),
            "metadata".into(),
            "name".into(),
            "percent_off".into(),
        ]
    }
}

#[doc = "Supported set of sort modes for scanning by created_at only.\n\nCurrently, we only support scanning in ascending order."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CreatedAtSortMode {
    #[doc = "Sort in increasing order of \"created_at\"."]
    #[serde(rename = "created_at_ascending")]
    #[display("created_at_ascending")]
    CreatedAtAscending,
    #[doc = "Sort in decreasing order of \"created_at\"."]
    #[serde(rename = "created_at_descending")]
    #[display("created_at_descending")]
    CreatedAtDescending,
}

#[doc = "The response from the `CurveGetControlPoints` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CurveGetControlPoints {
    #[doc = "Control points in the curve."]
    pub control_points: Vec<Point3D>,
}

impl std::fmt::Display for CurveGetControlPoints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CurveGetControlPoints {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.control_points).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["control_points".into()]
    }
}

#[doc = "Endpoints of a curve"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CurveGetEndPoints {
    #[doc = "End"]
    pub end: Point3D,
    #[doc = "Start"]
    pub start: Point3D,
}

impl std::fmt::Display for CurveGetEndPoints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CurveGetEndPoints {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.end).into(),
            format!("{:?}", self.start).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["end".into(), "start".into()]
    }
}

#[doc = "The response from the `CurveGetType` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CurveGetType {
    #[doc = "Curve type"]
    pub curve_type: CurveType,
}

impl std::fmt::Display for CurveGetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CurveGetType {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.curve_type).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["curve_type".into()]
    }
}

#[doc = "The type of Curve (embedded within path)"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CurveType {
    #[serde(rename = "line")]
    #[display("line")]
    Line,
    #[serde(rename = "arc")]
    #[display("arc")]
    Arc,
    #[serde(rename = "nurbs")]
    #[display("nurbs")]
    Nurbs,
}

#[doc = "The resource representing a payment \"Customer\"."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Customer {
    #[doc = "The customer's address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<AddressDetails>,
    #[doc = "Current balance, if any, being stored on the customer in the payments service.\n\nIf negative, the customer has credit to apply to their next invoice. If positive, the customer has an amount owed that will be added to their next invoice. The balance does not refer to any unpaid invoices; it solely takes into account amounts that have yet to be successfully applied to any invoice. This balance is only taken into account as invoices are finalized."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub balance: Option<f64>,
    #[doc = "Time at which the object was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Three-letter ISO code for the currency the customer can be charged in for recurring billing purposes."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
    #[doc = "When the customer's latest invoice is billed by charging automatically, `delinquent` is `true` if the invoice's latest charge failed.\n\nWhen the customer's latest invoice is billed by sending an invoice, `delinquent` is `true` if the invoice isn't paid by its due date.  If an invoice is marked uncollectible by dunning, `delinquent` doesn't get reset to `false`."]
    #[serde(default)]
    pub delinquent: bool,
    #[doc = "The customer's email address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = "Unique identifier for the object."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Set of key-value pairs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
    #[doc = "The customer's full name or business name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The customer's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
}

impl std::fmt::Display for Customer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Customer {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(address) = &self.address {
                format!("{:?}", address).into()
            } else {
                String::new().into()
            },
            if let Some(balance) = &self.balance {
                format!("{:?}", balance).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(currency) = &self.currency {
                format!("{:?}", currency).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.delinquent).into(),
            if let Some(email) = &self.email {
                format!("{:?}", email).into()
            } else {
                String::new().into()
            },
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "address".into(),
            "balance".into(),
            "created_at".into(),
            "currency".into(),
            "delinquent".into(),
            "email".into(),
            "id".into(),
            "metadata".into(),
            "name".into(),
            "phone".into(),
        ]
    }
}

#[doc = "A balance for a customer.\n\nThis holds information about the financial balance for the customer."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CustomerBalance {
    #[doc = "The date and time the balance was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The unique identifier for the balance."]
    pub id: uuid::Uuid,
    #[doc = "The mapping id of the user or org."]
    pub map_id: uuid::Uuid,
    #[doc = "The enterprise price for the Modeling App subscription, if they are on the enterprise plan."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modeling_app_enterprise_price: Option<SubscriptionTierPrice>,
    #[doc = "The monthy credits remaining in the balance. This gets re-upped every month, but if the credits are not used for a month they do not carry over to the next month. It is a stable amount granted to the customer per month."]
    pub monthly_credits_remaining: f64,
    #[doc = "The amount of pre-pay cash remaining in the balance. This number goes down as the customer uses their pre-paid credits. The reason we track this amount is if a customer ever wants to withdraw their pre-pay cash, we can use this amount to determine how much to give them. Say a customer has $100 in pre-paid cash, their bill is worth, $50 after subtracting any other credits (like monthly etc.) Their bill is $50, their pre-pay cash remaining will be subtracted by 50 to pay the bill and their `pre_pay_credits_remaining` will be subtracted by 50 to pay the bill. This way if they want to withdraw money after, they can only withdraw $50 since that is the amount of cash they have remaining."]
    pub pre_pay_cash_remaining: f64,
    #[doc = "The amount of credits remaining in the balance. This is typically the amount of cash * some multiplier they get for pre-paying their account. This number lowers every time a bill is paid with the balance. This number increases every time a customer adds funds to their balance. This may be through a subscription or a one off payment."]
    pub pre_pay_credits_remaining: f64,
    #[doc = "Details about the subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscription_details: Option<ZooProductSubscriptions>,
    #[doc = "The subscription ID for the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscription_id: Option<String>,
    #[doc = "This includes any outstanding, draft, or open invoices and any pending invoice items. This does not include any credits the customer has on their account."]
    pub total_due: f64,
    #[doc = "The date and time the balance was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for CustomerBalance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CustomerBalance {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.map_id).into(),
            if let Some(modeling_app_enterprise_price) = &self.modeling_app_enterprise_price {
                format!("{:?}", modeling_app_enterprise_price).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.monthly_credits_remaining).into(),
            format!("{:?}", self.pre_pay_cash_remaining).into(),
            format!("{:?}", self.pre_pay_credits_remaining).into(),
            if let Some(subscription_details) = &self.subscription_details {
                format!("{:?}", subscription_details).into()
            } else {
                String::new().into()
            },
            if let Some(subscription_id) = &self.subscription_id {
                format!("{:?}", subscription_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.total_due).into(),
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "id".into(),
            "map_id".into(),
            "modeling_app_enterprise_price".into(),
            "monthly_credits_remaining".into(),
            "pre_pay_cash_remaining".into(),
            "pre_pay_credits_remaining".into(),
            "subscription_details".into(),
            "subscription_id".into(),
            "total_due".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "The response from the `DefaultCameraFocusOn` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraFocusOn {}

impl std::fmt::Display for DefaultCameraFocusOn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraFocusOn {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `DefaultCameraGetSettings` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraGetSettings {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for DefaultCameraGetSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraGetSettings {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}

#[doc = "The response from the `DefaultCameraZoom` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraZoom {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for DefaultCameraZoom {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraZoom {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}

#[doc = "The density response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Density {
    #[doc = "The density."]
    pub density: f64,
    #[doc = "The output unit for the density."]
    pub output_unit: UnitDensity,
}

impl std::fmt::Display for Density {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Density {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.density).into(),
            format!("{:?}", self.output_unit).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["density".into(), "output_unit".into()]
    }
}

#[doc = "The DER encoded key pair."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DerEncodedKeyPair {
    #[doc = "The request signing private key (pem file)."]
    pub private_key: base64::Base64Data,
    #[doc = "The request signing public certificate (pem file)."]
    pub public_cert: base64::Base64Data,
}

impl std::fmt::Display for DerEncodedKeyPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DerEncodedKeyPair {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.private_key).into(),
            format!("{:?}", self.public_cert).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["private_key".into(), "public_cert".into()]
    }
}

#[doc = "The form for a device access token request."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeviceAccessTokenRequestForm {
    #[doc = "The client ID."]
    pub client_id: uuid::Uuid,
    #[doc = "The device code."]
    pub device_code: uuid::Uuid,
    #[doc = "The grant type."]
    pub grant_type: Oauth2GrantType,
}

impl std::fmt::Display for DeviceAccessTokenRequestForm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DeviceAccessTokenRequestForm {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.client_id).into(),
            format!("{:?}", self.device_code).into(),
            format!("{:?}", self.grant_type).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "client_id".into(),
            "device_code".into(),
            "grant_type".into(),
        ]
    }
}

#[doc = "The request parameters for the OAuth 2.0 Device Authorization Grant flow."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeviceAuthRequestForm {
    #[doc = "The client ID."]
    pub client_id: uuid::Uuid,
}

impl std::fmt::Display for DeviceAuthRequestForm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DeviceAuthRequestForm {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.client_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["client_id".into()]
    }
}

#[doc = "The request parameters to verify the `user_code` for the OAuth 2.0 Device Authorization Grant."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeviceAuthVerifyParams {
    #[doc = "The user code."]
    pub user_code: String,
}

impl std::fmt::Display for DeviceAuthVerifyParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DeviceAuthVerifyParams {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.user_code.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["user_code".into()]
    }
}

#[doc = "Specifies the sign of a co-ordinate axis."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Direction {
    #[doc = "Increasing numbers."]
    #[serde(rename = "positive")]
    #[display("positive")]
    Positive,
    #[doc = "Decreasing numbers."]
    #[serde(rename = "negative")]
    #[display("negative")]
    Negative,
}

#[doc = "The resource representing a Discount."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Discount {
    #[doc = "The coupon that applied to create this discount."]
    pub coupon: Coupon,
}

impl std::fmt::Display for Discount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Discount {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.coupon).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["coupon".into()]
    }
}

#[doc = "A discount code for a store."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscountCode {
    #[doc = "The code for the discount."]
    pub code: String,
    #[doc = "The date the discount code expires."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The percent off for the discount."]
    pub percent_off: u32,
}

impl std::fmt::Display for DiscountCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DiscountCode {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.code.clone().into(),
            if let Some(expires_at) = &self.expires_at {
                format!("{:?}", expires_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.percent_off).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["code".into(), "expires_at".into(), "percent_off".into()]
    }
}

#[doc = "The type of distance Distances can vary depending on the objects used as input."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum DistanceType {
    #[doc = "Euclidean Distance."]
    #[serde(rename = "euclidean")]
    Euclidean {},
    #[doc = "The distance between objects along the specified axis"]
    #[serde(rename = "on_axis")]
    OnAxis {
        #[doc = "Global axis"]
        axis: GlobalAxis,
    },
}

#[doc = "The body of the form for email authentication."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EmailAuthenticationForm {
    #[doc = "The URL to redirect back to after we have authenticated."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callback_url: Option<String>,
    #[doc = "The user's email."]
    pub email: String,
}

impl std::fmt::Display for EmailAuthenticationForm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EmailAuthenticationForm {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(callback_url) = &self.callback_url {
                format!("{:?}", callback_url).into()
            } else {
                String::new().into()
            },
            self.email.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["callback_url".into(), "email".into()]
    }
}

#[doc = "The response from the `EntityCircularPattern` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityCircularPattern {
    #[doc = "The UUIDs of the entities that were created."]
    pub entity_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for EntityCircularPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityCircularPattern {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_ids".into()]
    }
}

#[doc = "The response from the `EntityGetAllChildUuids` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetAllChildUuids {
    #[doc = "The UUIDs of the child entities."]
    pub entity_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for EntityGetAllChildUuids {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetAllChildUuids {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_ids".into()]
    }
}

#[doc = "The response from the `EntityGetChildUuid` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetChildUuid {
    #[doc = "The UUID of the child entity."]
    pub entity_id: uuid::Uuid,
}

impl std::fmt::Display for EntityGetChildUuid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetChildUuid {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_id".into()]
    }
}

#[doc = "The response from the `EntitiesGetDistance` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetDistance {
    #[doc = "The maximum distance between the input entities."]
    pub max_distance: f64,
    #[doc = "The minimum distance between the input entities."]
    pub min_distance: f64,
}

impl std::fmt::Display for EntityGetDistance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetDistance {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.max_distance).into(),
            format!("{:?}", self.min_distance).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["max_distance".into(), "min_distance".into()]
    }
}

#[doc = "The response from the `EntityGetNumChildren` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetNumChildren {
    #[doc = "The number of children the entity has."]
    pub num: u32,
}

impl std::fmt::Display for EntityGetNumChildren {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetNumChildren {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.num).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["num".into()]
    }
}

#[doc = "The response from the `EntityGetParentId` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetParentId {
    #[doc = "The UUID of the parent entity."]
    pub entity_id: uuid::Uuid,
}

impl std::fmt::Display for EntityGetParentId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetParentId {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_id".into()]
    }
}

#[doc = "The response from the `EntityLinearPattern` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityLinearPattern {
    #[doc = "The UUIDs of the entities that were created."]
    pub entity_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for EntityLinearPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityLinearPattern {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_ids".into()]
    }
}

#[doc = "The type of entity"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum EntityType {
    #[serde(rename = "entity")]
    #[display("entity")]
    Entity,
    #[serde(rename = "object")]
    #[display("object")]
    Object,
    #[serde(rename = "path")]
    #[display("path")]
    Path,
    #[serde(rename = "curve")]
    #[display("curve")]
    Curve,
    #[serde(rename = "solid2d")]
    #[display("solid2d")]
    Solid2D,
    #[serde(rename = "solid3d")]
    #[display("solid3d")]
    Solid3D,
    #[serde(rename = "edge")]
    #[display("edge")]
    Edge,
    #[serde(rename = "face")]
    #[display("face")]
    Face,
    #[serde(rename = "plane")]
    #[display("plane")]
    Plane,
    #[serde(rename = "vertex")]
    #[display("vertex")]
    Vertex,
}

#[doc = "The environment the server is running in."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Environment {
    #[doc = "The development environment. This is for running locally."]
    #[serde(rename = "DEVELOPMENT")]
    #[display("DEVELOPMENT")]
    Development,
    #[doc = "The preview environment. This is when PRs are created and a service is deployed for testing."]
    #[serde(rename = "PREVIEW")]
    #[display("PREVIEW")]
    Preview,
    #[doc = "The production environment."]
    #[serde(rename = "PRODUCTION")]
    #[display("PRODUCTION")]
    Production,
}

#[doc = "Error information from a response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Error {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    pub message: String,
    pub request_id: String,
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Error {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(error_code) = &self.error_code {
                format!("{:?}", error_code).into()
            } else {
                String::new().into()
            },
            self.message.clone().into(),
            self.request_id.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["error_code".into(), "message".into(), "request_id".into()]
    }
}

#[doc = "The type of error sent by the KittyCAD API."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ErrorCode {
    #[doc = "Graphics engine failed to complete request, consider retrying"]
    #[serde(rename = "internal_engine")]
    #[display("internal_engine")]
    InternalEngine,
    #[doc = "API failed to complete request, consider retrying"]
    #[serde(rename = "internal_api")]
    #[display("internal_api")]
    InternalApi,
    #[doc = "User requested something geometrically or graphically impossible. Don't retry this request, as it's inherently impossible. Instead, read the error message and change your request."]
    #[serde(rename = "bad_request")]
    #[display("bad_request")]
    BadRequest,
    #[doc = "Client sent invalid JSON."]
    #[serde(rename = "invalid_json")]
    #[display("invalid_json")]
    InvalidJson,
    #[doc = "Client sent invalid BSON."]
    #[serde(rename = "invalid_bson")]
    #[display("invalid_bson")]
    InvalidBson,
    #[doc = "Client sent a message which is not accepted over this protocol."]
    #[serde(rename = "wrong_protocol")]
    #[display("wrong_protocol")]
    WrongProtocol,
    #[doc = "Problem sending data between client and KittyCAD API."]
    #[serde(rename = "connection_problem")]
    #[display("connection_problem")]
    ConnectionProblem,
    #[doc = "Client sent a Websocket message type which the KittyCAD API does not handle."]
    #[serde(rename = "message_type_not_accepted")]
    #[display("message_type_not_accepted")]
    MessageTypeNotAccepted,
    #[doc = "Client sent a Websocket message intended for WebRTC but it was configured as a WebRTC connection."]
    #[serde(rename = "message_type_not_accepted_for_web_r_t_c")]
    #[display("message_type_not_accepted_for_web_r_t_c")]
    MessageTypeNotAcceptedForWebRTC,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Type {
    #[serde(rename = "modeling_app_event")]
    #[display("modeling_app_event")]
    ModelingAppEvent,
}

impl std::default::Default for Type {
    fn default() -> Self {
        Type::ModelingAppEvent
    }
}

#[doc = "An event related to modeling app files"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Event {
    #[doc = "Attachment URI for where the attachment is stored."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attachment_uri: Option<String>,
    #[doc = "Time this event was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The specific event type from the modeling app."]
    pub event_type: ModelingAppEventType,
    #[doc = "Time the associated attachment was last compiled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_compiled_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Project descriptino as given by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_description: Option<String>,
    #[doc = "Project name as given by the user."]
    pub project_name: String,
    #[doc = "The source app for this event, uuid that is unique to the app."]
    pub source_id: uuid::Uuid,
    #[serde(rename = "type")]
    pub type_: Type,
    #[doc = "An anonymous user id generated client-side."]
    pub user_id: String,
}

impl std::fmt::Display for Event {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Event {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(attachment_uri) = &self.attachment_uri {
                format!("{:?}", attachment_uri).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.event_type).into(),
            if let Some(last_compiled_at) = &self.last_compiled_at {
                format!("{:?}", last_compiled_at).into()
            } else {
                String::new().into()
            },
            if let Some(project_description) = &self.project_description {
                format!("{:?}", project_description).into()
            } else {
                String::new().into()
            },
            self.project_name.clone().into(),
            format!("{:?}", self.source_id).into(),
            format!("{:?}", self.type_).into(),
            self.user_id.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "attachment_uri".into(),
            "created_at".into(),
            "event_type".into(),
            "last_compiled_at".into(),
            "project_description".into(),
            "project_name".into(),
            "source_id".into(),
            "type_".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The response from the `Export` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Export {
    #[doc = "The files that were exported."]
    pub files: Vec<ExportFile>,
}

impl std::fmt::Display for Export {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Export {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.files).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["files".into()]
    }
}

#[doc = "A file to be exported to the client."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExportFile {
    #[doc = "The contents of the file, base64 encoded."]
    pub contents: base64::Base64Data,
    #[doc = "The name of the file."]
    pub name: String,
}

impl std::fmt::Display for ExportFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ExportFile {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.contents).into(),
            self.name.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["contents".into(), "name".into()]
    }
}

#[doc = "Extended user information.\n\nThis is mostly used for internal purposes. It returns a mapping of the user's information, including that of our third party services we use for users: MailChimp | Stripe"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExtendedUser {
    #[doc = "If the user should be blocked and the reason why."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block: Option<BlockReason>,
    #[doc = "If we can train on the user's data. If the user is a member of an organization, the organization's setting will override this."]
    #[serde(default)]
    pub can_train_on_data: bool,
    #[doc = "The user's company."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[doc = "The date and time the user was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user's Discord handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord: Option<String>,
    #[doc = "The email address of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = "The date and time the email address was verified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email_verified: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The user's first name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[doc = "The user's Front ID. This is mostly used for internal mapping."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub front_id: Option<String>,
    #[doc = "The user's GitHub handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub github: Option<String>,
    #[doc = "The unique identifier for the user."]
    pub id: uuid::Uuid,
    #[doc = "The image avatar for the user. This is a URL."]
    pub image: String,
    #[doc = "If the user is tied to a service account."]
    #[serde(default)]
    pub is_service_account: bool,
    #[doc = "The user's last name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    #[doc = "The user's MailChimp ID. This is mostly used for internal mapping."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mailchimp_id: Option<String>,
    #[doc = "The name of the user. This is auto populated at first from the authentication provider (if there was a name). It can be updated by the user by updating their `first_name` and `last_name` fields."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The user's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
    #[doc = "The user's Stripe ID. This is mostly used for internal mapping."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stripe_id: Option<String>,
    #[doc = "The date and time the user was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for ExtendedUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ExtendedUser {
    const LENGTH: usize = 19;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(block) = &self.block {
                format!("{:?}", block).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.can_train_on_data).into(),
            if let Some(company) = &self.company {
                format!("{:?}", company).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(discord) = &self.discord {
                format!("{:?}", discord).into()
            } else {
                String::new().into()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email).into()
            } else {
                String::new().into()
            },
            if let Some(email_verified) = &self.email_verified {
                format!("{:?}", email_verified).into()
            } else {
                String::new().into()
            },
            if let Some(first_name) = &self.first_name {
                format!("{:?}", first_name).into()
            } else {
                String::new().into()
            },
            if let Some(front_id) = &self.front_id {
                format!("{:?}", front_id).into()
            } else {
                String::new().into()
            },
            if let Some(github) = &self.github {
                format!("{:?}", github).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            self.image.clone().into(),
            format!("{:?}", self.is_service_account).into(),
            if let Some(last_name) = &self.last_name {
                format!("{:?}", last_name).into()
            } else {
                String::new().into()
            },
            if let Some(mailchimp_id) = &self.mailchimp_id {
                format!("{:?}", mailchimp_id).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
            if let Some(stripe_id) = &self.stripe_id {
                format!("{:?}", stripe_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "block".into(),
            "can_train_on_data".into(),
            "company".into(),
            "created_at".into(),
            "discord".into(),
            "email".into(),
            "email_verified".into(),
            "first_name".into(),
            "front_id".into(),
            "github".into(),
            "id".into(),
            "image".into(),
            "is_service_account".into(),
            "last_name".into(),
            "mailchimp_id".into(),
            "name".into(),
            "phone".into(),
            "stripe_id".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExtendedUserResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<ExtendedUser>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ExtendedUserResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ExtendedUserResultsPage {
    type Item = ExtendedUser;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ExtendedUserResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Possible types of faces which can be extruded from a 3D solid."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ExtrusionFaceCapType {
    #[doc = "Uncapped."]
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[doc = "Capped on top."]
    #[serde(rename = "top")]
    #[display("top")]
    Top,
    #[doc = "Capped below."]
    #[serde(rename = "bottom")]
    #[display("bottom")]
    Bottom,
}

#[doc = "Extrusion face info struct (useful for maintaining mappings between source path segment ids and extrusion faces)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExtrusionFaceInfo {
    #[doc = "Whether or not this extrusion face is a top/bottom cap face or not. Note that top/bottom cap faces will not have associated curve IDs."]
    pub cap: ExtrusionFaceCapType,
    #[doc = "Path component (curve) UUID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub curve_id: Option<uuid::Uuid>,
    #[doc = "Face uuid."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub face_id: Option<uuid::Uuid>,
}

impl std::fmt::Display for ExtrusionFaceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ExtrusionFaceInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.cap).into(),
            if let Some(curve_id) = &self.curve_id {
                format!("{:?}", curve_id).into()
            } else {
                String::new().into()
            },
            if let Some(face_id) = &self.face_id {
                format!("{:?}", face_id).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["cap".into(), "curve_id".into(), "face_id".into()]
    }
}

#[doc = "The gradient (dFdu, dFdv) + normal vector on a brep face"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FaceGetGradient {
    #[doc = "dFdu"]
    pub df_du: Point3D,
    #[doc = "dFdv"]
    pub df_dv: Point3D,
    #[doc = "Normal (||dFdu x dFdv||)"]
    pub normal: Point3D,
}

impl std::fmt::Display for FaceGetGradient {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FaceGetGradient {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.df_du).into(),
            format!("{:?}", self.df_dv).into(),
            format!("{:?}", self.normal).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["df_du".into(), "df_dv".into(), "normal".into()]
    }
}

#[doc = "The 3D position on the surface that was evaluated"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FaceGetPosition {
    #[doc = "The 3D position on the surface that was evaluated"]
    pub pos: Point3D,
}

impl std::fmt::Display for FaceGetPosition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FaceGetPosition {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.pos).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["pos".into()]
    }
}

#[doc = "Surface-local planar axes (if available)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FaceIsPlanar {
    #[doc = "plane's origin"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<Point3D>,
    #[doc = "plane's local x-axis"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x_axis: Option<Point3D>,
    #[doc = "plane's local y-axis"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y_axis: Option<Point3D>,
    #[doc = "plane's local z-axis (normal)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub z_axis: Option<Point3D>,
}

impl std::fmt::Display for FaceIsPlanar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FaceIsPlanar {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(origin) = &self.origin {
                format!("{:?}", origin).into()
            } else {
                String::new().into()
            },
            if let Some(x_axis) = &self.x_axis {
                format!("{:?}", x_axis).into()
            } else {
                String::new().into()
            },
            if let Some(y_axis) = &self.y_axis {
                format!("{:?}", y_axis).into()
            } else {
                String::new().into()
            },
            if let Some(z_axis) = &self.z_axis {
                format!("{:?}", z_axis).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "origin".into(),
            "x_axis".into(),
            "y_axis".into(),
            "z_axis".into(),
        ]
    }
}

#[doc = "Unsuccessful Websocket response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FailureWebSocketResponse {
    #[doc = "The errors that occurred."]
    pub errors: Vec<ApiError>,
    #[doc = "Which request this is a response to. If the request was a modeling command, this is the modeling command ID. If no request ID was sent, this will be null."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<uuid::Uuid>,
    #[doc = "Always false"]
    pub success: bool,
}

impl std::fmt::Display for FailureWebSocketResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FailureWebSocketResponse {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.errors).into(),
            if let Some(request_id) = &self.request_id {
                format!("{:?}", request_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.success).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["errors".into(), "request_id".into(), "success".into()]
    }
}

#[doc = "Describes the storage format of an FBX file."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum FbxStorage {
    #[doc = "ASCII FBX encoding."]
    #[serde(rename = "ascii")]
    #[display("ascii")]
    Ascii,
    #[doc = "Binary FBX encoding."]
    #[serde(rename = "binary")]
    #[display("binary")]
    Binary,
}

#[doc = "A file center of mass result."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileCenterOfMass {
    #[doc = "The resulting center of mass."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub center_of_mass: Option<Point3D>,
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The output unit for the center of mass."]
    pub output_unit: UnitLength,
    #[doc = "The source format of the file."]
    pub src_format: FileImportFormat,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for FileCenterOfMass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileCenterOfMass {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(center_of_mass) = &self.center_of_mass {
                format!("{:?}", center_of_mass).into()
            } else {
                String::new().into()
            },
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.src_format).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "center_of_mass".into(),
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "output_unit".into(),
            "src_format".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A file conversion."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The output format of the file conversion."]
    pub output_format: FileExportFormat,
    #[doc = "The output format options of the file conversion."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output_format_options: Option<OutputFormat>,
    #[doc = "The converted files (if multiple file conversion), if completed, base64 encoded. The key of the map is the path of the output file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub outputs: Option<std::collections::HashMap<String, base64::Base64Data>>,
    #[doc = "The source format of the file conversion."]
    pub src_format: FileImportFormat,
    #[doc = "The source format options of the file conversion."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub src_format_options: Option<InputFormat>,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for FileConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileConversion {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            format!("{:?}", self.output_format).into(),
            if let Some(output_format_options) = &self.output_format_options {
                format!("{:?}", output_format_options).into()
            } else {
                String::new().into()
            },
            if let Some(outputs) = &self.outputs {
                format!("{:?}", outputs).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.src_format).into(),
            if let Some(src_format_options) = &self.src_format_options {
                format!("{:?}", src_format_options).into()
            } else {
                String::new().into()
            },
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "output_format".into(),
            "output_format_options".into(),
            "outputs".into(),
            "src_format".into(),
            "src_format_options".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A file density result."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileDensity {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The resulting density."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub density: Option<f64>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The material mass as denoted by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub material_mass: Option<f64>,
    #[doc = "The material mass unit."]
    pub material_mass_unit: UnitMass,
    #[doc = "The output unit for the density."]
    pub output_unit: UnitDensity,
    #[doc = "The source format of the file."]
    pub src_format: FileImportFormat,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for FileDensity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileDensity {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(density) = &self.density {
                format!("{:?}", density).into()
            } else {
                String::new().into()
            },
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(material_mass) = &self.material_mass {
                format!("{:?}", material_mass).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.material_mass_unit).into(),
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.src_format).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "density".into(),
            "error".into(),
            "id".into(),
            "material_mass".into(),
            "material_mass_unit".into(),
            "output_unit".into(),
            "src_format".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of output file formats."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum FileExportFormat {
    #[doc = "Autodesk Filmbox (FBX) format. <https://en.wikipedia.org/wiki/FBX>"]
    #[serde(rename = "fbx")]
    #[display("fbx")]
    Fbx,
    #[doc = "Binary glTF 2.0.\n\nThis is a single binary with .glb extension.\n\nThis is better if you want a compressed format as opposed to the human readable glTF that lacks compression."]
    #[serde(rename = "glb")]
    #[display("glb")]
    Glb,
    #[doc = "glTF 2.0. Embedded glTF 2.0 (pretty printed).\n\nSingle JSON file with .gltf extension binary data encoded as base64 data URIs.\n\nThe JSON contents are pretty printed.\n\nIt is human readable, single file, and you can view the diff easily in a git commit."]
    #[serde(rename = "gltf")]
    #[display("gltf")]
    Gltf,
    #[doc = "The OBJ file format. <https://en.wikipedia.org/wiki/Wavefront_.obj_file> It may or may not have an an attached material (mtl // mtllib) within the file, but we interact with it as if it does not."]
    #[serde(rename = "obj")]
    #[display("obj")]
    Obj,
    #[doc = "The PLY file format. <https://en.wikipedia.org/wiki/PLY_(file_format)>"]
    #[serde(rename = "ply")]
    #[display("ply")]
    Ply,
    #[doc = "The STEP file format. <https://en.wikipedia.org/wiki/ISO_10303-21>"]
    #[serde(rename = "step")]
    #[display("step")]
    Step,
    #[doc = "The STL file format. <https://en.wikipedia.org/wiki/STL_(file_format)>"]
    #[serde(rename = "stl")]
    #[display("stl")]
    Stl,
}

#[doc = "The valid types of source file formats."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum FileImportFormat {
    #[doc = "Autodesk Filmbox (FBX) format. <https://en.wikipedia.org/wiki/FBX>"]
    #[serde(rename = "fbx")]
    #[display("fbx")]
    Fbx,
    #[doc = "glTF 2.0."]
    #[serde(rename = "gltf")]
    #[display("gltf")]
    Gltf,
    #[doc = "The OBJ file format. <https://en.wikipedia.org/wiki/Wavefront_.obj_file> It may or may not have an an attached material (mtl // mtllib) within the file, but we interact with it as if it does not."]
    #[serde(rename = "obj")]
    #[display("obj")]
    Obj,
    #[doc = "The PLY file format. <https://en.wikipedia.org/wiki/PLY_(file_format)>"]
    #[serde(rename = "ply")]
    #[display("ply")]
    Ply,
    #[doc = "SolidWorks part (SLDPRT) format."]
    #[serde(rename = "sldprt")]
    #[display("sldprt")]
    Sldprt,
    #[doc = "The STEP file format. <https://en.wikipedia.org/wiki/ISO_10303-21>"]
    #[serde(rename = "step")]
    #[display("step")]
    Step,
    #[doc = "The STL file format. <https://en.wikipedia.org/wiki/STL_(file_format)>"]
    #[serde(rename = "stl")]
    #[display("stl")]
    Stl,
}

#[doc = "A file mass result."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileMass {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The resulting mass."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mass: Option<f64>,
    #[doc = "The material density as denoted by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub material_density: Option<f64>,
    #[doc = "The material density unit."]
    pub material_density_unit: UnitDensity,
    #[doc = "The output unit for the mass."]
    pub output_unit: UnitMass,
    #[doc = "The source format of the file."]
    pub src_format: FileImportFormat,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for FileMass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileMass {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(mass) = &self.mass {
                format!("{:?}", mass).into()
            } else {
                String::new().into()
            },
            if let Some(material_density) = &self.material_density {
                format!("{:?}", material_density).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.material_density_unit).into(),
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.src_format).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "mass".into(),
            "material_density".into(),
            "material_density_unit".into(),
            "output_unit".into(),
            "src_format".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A file surface area result."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileSurfaceArea {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The output unit for the surface area."]
    pub output_unit: UnitArea,
    #[doc = "The source format of the file."]
    pub src_format: FileImportFormat,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The resulting surface area."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub surface_area: Option<f64>,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for FileSurfaceArea {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileSurfaceArea {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.src_format).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            if let Some(surface_area) = &self.surface_area {
                format!("{:?}", surface_area).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "output_unit".into(),
            "src_format".into(),
            "started_at".into(),
            "status".into(),
            "surface_area".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "Metadata about our file system.\n\nThis is mostly used for internal purposes and debugging."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileSystemMetadata {
    #[doc = "If the file system passed a sanity check."]
    pub ok: bool,
}

impl std::fmt::Display for FileSystemMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileSystemMetadata {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.ok).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["ok".into()]
    }
}

#[doc = "A file volume result."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileVolume {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The output unit for the volume."]
    pub output_unit: UnitVolume,
    #[doc = "The source format of the file."]
    pub src_format: FileImportFormat,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
    #[doc = "The resulting volume."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volume: Option<f64>,
}

impl std::fmt::Display for FileVolume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileVolume {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.src_format).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
            if let Some(volume) = &self.volume {
                format!("{:?}", volume).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "output_unit".into(),
            "src_format".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
            "volume".into(),
        ]
    }
}

#[doc = "Gateway information."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Gateway {
    #[doc = "The auth timeout of the gateway."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_timeout: Option<i64>,
    #[doc = "The host of the gateway."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[doc = "The name of the gateway."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The port of the gateway."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    #[doc = "The TLS timeout for the gateway."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_timeout: Option<i64>,
}

impl std::fmt::Display for Gateway {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Gateway {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(auth_timeout) = &self.auth_timeout {
                format!("{:?}", auth_timeout).into()
            } else {
                String::new().into()
            },
            if let Some(host) = &self.host {
                format!("{:?}", host).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            if let Some(port) = &self.port {
                format!("{:?}", port).into()
            } else {
                String::new().into()
            },
            if let Some(tls_timeout) = &self.tls_timeout {
                format!("{:?}", tls_timeout).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "auth_timeout".into(),
            "host".into(),
            "name".into(),
            "port".into(),
            "tls_timeout".into(),
        ]
    }
}

#[doc = "The response from the `GetEntityType` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GetEntityType {
    #[doc = "The type of the entity."]
    pub entity_type: EntityType,
}

impl std::fmt::Display for GetEntityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for GetEntityType {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_type).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_type".into()]
    }
}

#[doc = "The response from the `GetNumObjects` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GetNumObjects {
    #[doc = "The number of objects in the scene."]
    pub num_objects: u32,
}

impl std::fmt::Display for GetNumObjects {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for GetNumObjects {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.num_objects).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["num_objects".into()]
    }
}

#[doc = "The plane for sketch mode."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GetSketchModePlane {
    #[doc = "The x axis."]
    pub x_axis: Point3D,
    #[doc = "The y axis."]
    pub y_axis: Point3D,
    #[doc = "The z axis (normal)."]
    pub z_axis: Point3D,
}

impl std::fmt::Display for GetSketchModePlane {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for GetSketchModePlane {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.x_axis).into(),
            format!("{:?}", self.y_axis).into(),
            format!("{:?}", self.z_axis).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["x_axis".into(), "y_axis".into(), "z_axis".into()]
    }
}

#[doc = "The global axes."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum GlobalAxis {
    #[doc = "The X axis"]
    #[serde(rename = "x")]
    #[display("x")]
    X,
    #[doc = "The Y axis"]
    #[serde(rename = "y")]
    #[display("y")]
    Y,
    #[doc = "The Z axis"]
    #[serde(rename = "z")]
    #[display("z")]
    Z,
}

#[doc = "Describes the presentation style of the glTF JSON."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum GltfPresentation {
    #[doc = "Condense the JSON into the smallest possible size."]
    #[serde(rename = "compact")]
    #[display("compact")]
    Compact,
    #[doc = "Expand the JSON into a more human readable format.\n\nThis is the default setting."]
    #[serde(rename = "pretty")]
    #[display("pretty")]
    Pretty,
}

#[doc = "Describes the storage format of a glTF 2.0 scene."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum GltfStorage {
    #[doc = "Binary glTF 2.0.\n\nThis is a single binary with .glb extension."]
    #[serde(rename = "binary")]
    #[display("binary")]
    Binary,
    #[doc = "Standard glTF 2.0.\n\nThis is a JSON file with .gltf extension paired with a separate binary blob file with .bin extension."]
    #[serde(rename = "standard")]
    #[display("standard")]
    Standard,
    #[doc = "Embedded glTF 2.0.\n\nSingle JSON file with .gltf extension binary data encoded as base64 data URIs.\n\nThis is the default setting."]
    #[serde(rename = "embedded")]
    #[display("embedded")]
    Embedded,
}

#[doc = "The response from the `HighlightSetEntity` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct HighlightSetEntity {
    #[doc = "The UUID of the entity that was highlighted."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity_id: Option<uuid::Uuid>,
    #[doc = "If the client sent a sequence ID with its request, the backend sends it back."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sequence: Option<u32>,
}

impl std::fmt::Display for HighlightSetEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for HighlightSetEntity {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(entity_id) = &self.entity_id {
                format!("{:?}", entity_id).into()
            } else {
                String::new().into()
            },
            if let Some(sequence) = &self.sequence {
                format!("{:?}", sequence).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_id".into(), "sequence".into()]
    }
}

#[doc = "Representation of an ICE server used for STUN/TURN Used to initiate WebRTC connections based on <https://developer.mozilla.org/en-US/docs/Web/API/RTCIceServer>"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IceServer {
    #[doc = "Credentials for a given TURN server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credential: Option<String>,
    #[doc = "URLs for a given STUN/TURN server. IceServer urls can either be a string or an array of strings But, we choose to always convert to an array of strings for consistency"]
    pub urls: Vec<String>,
    #[doc = "Username for a given TURN server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

impl std::fmt::Display for IceServer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IceServer {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(credential) = &self.credential {
                format!("{:?}", credential).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.urls).into(),
            if let Some(username) = &self.username {
                format!("{:?}", username).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["credential".into(), "urls".into(), "username".into()]
    }
}

#[doc = "The source of an identity provider metadata descriptor."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum IdpMetadataSource {
    #[doc = "A URL to the identity provider metadata descriptor."]
    #[serde(rename = "url")]
    Url {
        #[doc = "The URL of the identity provider metadata descriptor."]
        url: String,
    },
    #[doc = "A base64 encoded XML document containing the identity provider metadata descriptor."]
    #[serde(rename = "base64_encoded_xml")]
    Base64EncodedXml {
        #[doc = "The base64 encoded XML document containing the identity provider metadata descriptor."]
        data: base64::Base64Data,
    },
}

#[doc = "Enum containing the variety of image formats snapshots may be exported to."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ImageFormat {
    #[doc = ".png format"]
    #[serde(rename = "png")]
    #[display("png")]
    Png,
    #[doc = ".jpeg format"]
    #[serde(rename = "jpeg")]
    #[display("jpeg")]
    Jpeg,
}

#[doc = "File to import into the current model. If you are sending binary data for a file, be sure to send the WebSocketRequest as binary/bson, not text/json."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ImportFile {
    #[doc = "The raw bytes of the file"]
    #[serde(
        serialize_with = "serde_bytes::serialize",
        deserialize_with = "serde_bytes::deserialize"
    )]
    pub data: Vec<u8>,
    #[doc = "The file's full path, including file extension."]
    pub path: String,
}

impl std::fmt::Display for ImportFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ImportFile {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.data).into(), self.path.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["data".into(), "path".into()]
    }
}

#[doc = "Data from importing the files"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ImportFiles {
    #[doc = "ID of the imported 3D models within the scene."]
    pub object_id: uuid::Uuid,
}

impl std::fmt::Display for ImportFiles {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ImportFiles {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.object_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["object_id".into()]
    }
}

#[doc = "Data from importing the files"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ImportedGeometry {
    #[doc = "ID of the imported 3D models within the scene."]
    pub id: uuid::Uuid,
    #[doc = "The original file paths that held the geometry."]
    pub value: Vec<String>,
}

impl std::fmt::Display for ImportedGeometry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ImportedGeometry {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.id).into(),
            format!("{:?}", self.value).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["id".into(), "value".into()]
    }
}

#[doc = "Input format specifier."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum InputFormat {
    #[doc = "Autodesk Filmbox (FBX) format."]
    #[serde(rename = "fbx")]
    Fbx {},
    #[doc = "Binary glTF 2.0. We refer to this as glTF since that is how our customers refer to it, but this can also import binary glTF (glb)."]
    #[serde(rename = "gltf")]
    Gltf {},
    #[doc = "Wavefront OBJ format."]
    #[serde(rename = "obj")]
    Obj {
        #[doc = "Co-ordinate system of input data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "The units of the input data. This is very important for correct scaling and when calculating physics properties like mass, etc.\n\nDefaults to meters."]
        units: UnitLength,
    },
    #[doc = "The PLY Polygon File Format."]
    #[serde(rename = "ply")]
    Ply {
        #[doc = "Co-ordinate system of input data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "The units of the input data. This is very important for correct scaling and when calculating physics properties like mass, etc."]
        units: UnitLength,
    },
    #[doc = "SolidWorks part (SLDPRT) format."]
    #[serde(rename = "sldprt")]
    Sldprt {},
    #[doc = "ISO 10303-21 (STEP) format."]
    #[serde(rename = "step")]
    Step {},
    #[doc = "*ST**ereo**L**ithography format."]
    #[serde(rename = "stl")]
    Stl {
        #[doc = "Co-ordinate system of input data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "The units of the input data. This is very important for correct scaling and when calculating physics properties like mass, etc."]
        units: UnitLength,
    },
}

#[doc = "An invoice."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Invoice {
    #[doc = "Final amount due at this time for this invoice.\n\nIf the invoice's total is smaller than the minimum charge amount, for example, or if there is account credit that can be applied to the invoice, the `amount_due` may be 0. If there is a positive `starting_balance` for the invoice (the customer owes money), the `amount_due` will also take that into account. The charge that gets generated for the invoice will be for the amount specified in `amount_due`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount_due: Option<f64>,
    #[doc = "The amount, in USD, that was paid."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount_paid: Option<f64>,
    #[doc = "The amount remaining, in USD, that is due."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount_remaining: Option<f64>,
    #[doc = "Number of payment attempts made for this invoice, from the perspective of the payment retry schedule.\n\nAny payment attempt counts as the first attempt, and subsequently only automatic retries increment the attempt count. In other words, manual payment attempts after the first attempt do not affect the retry schedule."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attempt_count: Option<u64>,
    #[doc = "Whether an attempt has been made to pay the invoice.\n\nAn invoice is not attempted until 1 hour after the `invoice.created` webhook, for example, so you might not want to display that invoice as unpaid to your users."]
    #[serde(default)]
    pub attempted: bool,
    #[doc = "Time at which the object was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
    #[doc = "The email address for the customer. Until the invoice is finalized, this field will equal customer.email. Once the invoice is finalized, this field will no longer be updated."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub customer_email: Option<String>,
    #[doc = "Customer ID. The unique identifier for the customer this invoice belongs to. This is the customer ID in the payments service, not our database customer ID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub customer_id: Option<String>,
    #[doc = "Default payment method."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_payment_method: Option<String>,
    #[doc = "Description of the invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The discounts applied to the invoice. This is an array of discount objects."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discounts: Option<Vec<Discount>>,
    #[doc = "Unique identifier for the object."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The individual line items that make up the invoice.\n\n`lines` is sorted as follows: invoice items in reverse chronological order, followed by the subscription, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lines: Option<Vec<InvoiceLineItem>>,
    #[doc = "Set of key-value pairs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
    #[doc = "A unique, identifying string that appears on emails sent to the customer for this invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<String>,
    #[doc = "Whether payment was successfully collected for this invoice.\n\nAn invoice can be paid (most commonly) with a charge or with credit from the customer's account balance."]
    #[serde(default)]
    pub paid: bool,
    #[doc = "The link to download the PDF for the invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pdf: Option<String>,
    #[doc = "This is the transaction number that appears on email receipts sent for this invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub receipt_number: Option<String>,
    #[doc = "Extra information about an invoice for the customer's credit card statement."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statement_descriptor: Option<String>,
    #[doc = "The status of the invoice, one of `draft`, `open`, `paid`, `uncollectible`, or `void`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<InvoiceStatus>,
    #[doc = "Total of all subscriptions, invoice items, and prorations on the invoice before any invoice level discount or tax is applied.\n\nItem discounts are already incorporated."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subtotal: Option<f64>,
    #[doc = "The amount of tax on this invoice.\n\nThis is the sum of all the tax amounts on this invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tax: Option<f64>,
    #[doc = "Total after discounts and taxes."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total: Option<f64>,
    #[doc = "The URL for the hosted invoice page, which allows customers to view and pay an invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

impl std::fmt::Display for Invoice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Invoice {
    const LENGTH: usize = 25;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(amount_due) = &self.amount_due {
                format!("{:?}", amount_due).into()
            } else {
                String::new().into()
            },
            if let Some(amount_paid) = &self.amount_paid {
                format!("{:?}", amount_paid).into()
            } else {
                String::new().into()
            },
            if let Some(amount_remaining) = &self.amount_remaining {
                format!("{:?}", amount_remaining).into()
            } else {
                String::new().into()
            },
            if let Some(attempt_count) = &self.attempt_count {
                format!("{:?}", attempt_count).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.attempted).into(),
            format!("{:?}", self.created_at).into(),
            if let Some(currency) = &self.currency {
                format!("{:?}", currency).into()
            } else {
                String::new().into()
            },
            if let Some(customer_email) = &self.customer_email {
                format!("{:?}", customer_email).into()
            } else {
                String::new().into()
            },
            if let Some(customer_id) = &self.customer_id {
                format!("{:?}", customer_id).into()
            } else {
                String::new().into()
            },
            if let Some(default_payment_method) = &self.default_payment_method {
                format!("{:?}", default_payment_method).into()
            } else {
                String::new().into()
            },
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            if let Some(discounts) = &self.discounts {
                format!("{:?}", discounts).into()
            } else {
                String::new().into()
            },
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(lines) = &self.lines {
                format!("{:?}", lines).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
            if let Some(number) = &self.number {
                format!("{:?}", number).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.paid).into(),
            if let Some(pdf) = &self.pdf {
                format!("{:?}", pdf).into()
            } else {
                String::new().into()
            },
            if let Some(receipt_number) = &self.receipt_number {
                format!("{:?}", receipt_number).into()
            } else {
                String::new().into()
            },
            if let Some(statement_descriptor) = &self.statement_descriptor {
                format!("{:?}", statement_descriptor).into()
            } else {
                String::new().into()
            },
            if let Some(status) = &self.status {
                format!("{:?}", status).into()
            } else {
                String::new().into()
            },
            if let Some(subtotal) = &self.subtotal {
                format!("{:?}", subtotal).into()
            } else {
                String::new().into()
            },
            if let Some(tax) = &self.tax {
                format!("{:?}", tax).into()
            } else {
                String::new().into()
            },
            if let Some(total) = &self.total {
                format!("{:?}", total).into()
            } else {
                String::new().into()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "amount_due".into(),
            "amount_paid".into(),
            "amount_remaining".into(),
            "attempt_count".into(),
            "attempted".into(),
            "created_at".into(),
            "currency".into(),
            "customer_email".into(),
            "customer_id".into(),
            "default_payment_method".into(),
            "description".into(),
            "discounts".into(),
            "id".into(),
            "lines".into(),
            "metadata".into(),
            "number".into(),
            "paid".into(),
            "pdf".into(),
            "receipt_number".into(),
            "statement_descriptor".into(),
            "status".into(),
            "subtotal".into(),
            "tax".into(),
            "total".into(),
            "url".into(),
        ]
    }
}

#[doc = "An invoice line item."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InvoiceLineItem {
    #[doc = "The amount, in USD."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount: Option<f64>,
    #[doc = "Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
    #[doc = "The description."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "Unique identifier for the object."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The ID of the invoice item associated with this line item if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub invoice_item: Option<String>,
    #[doc = "Set of key-value pairs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
}

impl std::fmt::Display for InvoiceLineItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for InvoiceLineItem {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(amount) = &self.amount {
                format!("{:?}", amount).into()
            } else {
                String::new().into()
            },
            if let Some(currency) = &self.currency {
                format!("{:?}", currency).into()
            } else {
                String::new().into()
            },
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(invoice_item) = &self.invoice_item {
                format!("{:?}", invoice_item).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "amount".into(),
            "currency".into(),
            "description".into(),
            "id".into(),
            "invoice_item".into(),
            "metadata".into(),
        ]
    }
}

#[doc = "An enum representing the possible values of an `Invoice`'s `status` field."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum InvoiceStatus {
    #[doc = "Draft."]
    #[serde(rename = "draft")]
    #[display("draft")]
    Draft,
    #[doc = "Open."]
    #[serde(rename = "open")]
    #[display("open")]
    Open,
    #[doc = "Paid."]
    #[serde(rename = "paid")]
    #[display("paid")]
    Paid,
    #[doc = "Uncollectible."]
    #[serde(rename = "uncollectible")]
    #[display("uncollectible")]
    Uncollectible,
    #[doc = "Void."]
    #[serde(rename = "void")]
    #[display("void")]
    Void,
}

#[doc = "Information about an ip address. Represents geographical and network-related information."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IpAddrInfo {
    #[doc = "Autonomous System Number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub asn: Option<i64>,
    #[doc = "City name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub city: Option<String>,
    #[doc = "Continent code (e.g., \"EU\" for Europe)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub continent_code: Option<String>,
    #[doc = "Country name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
    #[doc = "Two-letter country code (e.g., \"NL\" for Netherlands)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub country_code: Option<String>,
    #[doc = "Three-letter country code (e.g., \"NLD\" for Netherlands)."]
    #[serde(
        rename = "country_code3",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub country_code_3: Option<String>,
    #[doc = "IP address of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<std::net::IpAddr>,
    #[doc = "Flag indicating whether the country is in the European Union."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_in_european_union: Option<bool>,
    #[doc = "Geographic latitude."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latitude: Option<f64>,
    #[doc = "Geographic longitude."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub longitude: Option<f64>,
    #[doc = "Time offset in seconds from UTC."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    #[doc = "Organization name (e.g., \"RIPE NCC\")."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    #[doc = "Postal code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    #[doc = "Name of the region (e.g., \"North Holland\")."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "Region code (e.g., \"NH\" for North Holland)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region_code: Option<String>,
    #[doc = "Timezone (e.g., \"Europe/Amsterdam\")."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
}

impl std::fmt::Display for IpAddrInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IpAddrInfo {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(asn) = &self.asn {
                format!("{:?}", asn).into()
            } else {
                String::new().into()
            },
            if let Some(city) = &self.city {
                format!("{:?}", city).into()
            } else {
                String::new().into()
            },
            if let Some(continent_code) = &self.continent_code {
                format!("{:?}", continent_code).into()
            } else {
                String::new().into()
            },
            if let Some(country) = &self.country {
                format!("{:?}", country).into()
            } else {
                String::new().into()
            },
            if let Some(country_code) = &self.country_code {
                format!("{:?}", country_code).into()
            } else {
                String::new().into()
            },
            if let Some(country_code_3) = &self.country_code_3 {
                format!("{:?}", country_code_3).into()
            } else {
                String::new().into()
            },
            if let Some(ip) = &self.ip {
                format!("{:?}", ip).into()
            } else {
                String::new().into()
            },
            if let Some(is_in_european_union) = &self.is_in_european_union {
                format!("{:?}", is_in_european_union).into()
            } else {
                String::new().into()
            },
            if let Some(latitude) = &self.latitude {
                format!("{:?}", latitude).into()
            } else {
                String::new().into()
            },
            if let Some(longitude) = &self.longitude {
                format!("{:?}", longitude).into()
            } else {
                String::new().into()
            },
            if let Some(offset) = &self.offset {
                format!("{:?}", offset).into()
            } else {
                String::new().into()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization).into()
            } else {
                String::new().into()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{:?}", postal_code).into()
            } else {
                String::new().into()
            },
            if let Some(region) = &self.region {
                format!("{:?}", region).into()
            } else {
                String::new().into()
            },
            if let Some(region_code) = &self.region_code {
                format!("{:?}", region_code).into()
            } else {
                String::new().into()
            },
            if let Some(timezone) = &self.timezone {
                format!("{:?}", timezone).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "asn".into(),
            "city".into(),
            "continent_code".into(),
            "country".into(),
            "country_code".into(),
            "country_code_3".into(),
            "ip".into(),
            "is_in_european_union".into(),
            "latitude".into(),
            "longitude".into(),
            "offset".into(),
            "organization".into(),
            "postal_code".into(),
            "region".into(),
            "region_code".into(),
            "timezone".into(),
        ]
    }
}

#[doc = "Jetstream information."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Jetstream {
    #[doc = "The Jetstream config."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<JetstreamConfig>,
    #[doc = "Meta information about the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub meta: Option<MetaClusterInfo>,
    #[doc = "Jetstream statistics."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stats: Option<JetstreamStats>,
}

impl std::fmt::Display for Jetstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Jetstream {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(config) = &self.config {
                format!("{:?}", config).into()
            } else {
                String::new().into()
            },
            if let Some(meta) = &self.meta {
                format!("{:?}", meta).into()
            } else {
                String::new().into()
            },
            if let Some(stats) = &self.stats {
                format!("{:?}", stats).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["config".into(), "meta".into(), "stats".into()]
    }
}

#[doc = "Jetstream API statistics."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct JetstreamApiStats {
    #[doc = "The number of errors."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub errors: Option<i64>,
    #[doc = "The number of inflight requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inflight: Option<i64>,
    #[doc = "The number of requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total: Option<i64>,
}

impl std::fmt::Display for JetstreamApiStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for JetstreamApiStats {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(errors) = &self.errors {
                format!("{:?}", errors).into()
            } else {
                String::new().into()
            },
            if let Some(inflight) = &self.inflight {
                format!("{:?}", inflight).into()
            } else {
                String::new().into()
            },
            if let Some(total) = &self.total {
                format!("{:?}", total).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["errors".into(), "inflight".into(), "total".into()]
    }
}

#[doc = "Jetstream configuration."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct JetstreamConfig {
    #[doc = "The domain."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    #[doc = "The max memory."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_memory: Option<i64>,
    #[doc = "The max storage."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_storage: Option<i64>,
    #[doc = "The store directory."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub store_dir: Option<String>,
}

impl std::fmt::Display for JetstreamConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for JetstreamConfig {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(domain) = &self.domain {
                format!("{:?}", domain).into()
            } else {
                String::new().into()
            },
            if let Some(max_memory) = &self.max_memory {
                format!("{:?}", max_memory).into()
            } else {
                String::new().into()
            },
            if let Some(max_storage) = &self.max_storage {
                format!("{:?}", max_storage).into()
            } else {
                String::new().into()
            },
            if let Some(store_dir) = &self.store_dir {
                format!("{:?}", store_dir).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "domain".into(),
            "max_memory".into(),
            "max_storage".into(),
            "store_dir".into(),
        ]
    }
}

#[doc = "Jetstream statistics."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct JetstreamStats {
    #[doc = "The number of accounts."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub accounts: Option<i64>,
    #[doc = "API stats."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api: Option<JetstreamApiStats>,
    #[doc = "The number of HA assets."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ha_assets: Option<i64>,
    #[doc = "The memory used by the Jetstream server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<i64>,
    #[doc = "The reserved memory for the Jetstream server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reserved_memory: Option<i64>,
    #[doc = "The reserved storage for the Jetstream server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reserved_store: Option<i64>,
    #[doc = "The storage used by the Jetstream server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub store: Option<i64>,
}

impl std::fmt::Display for JetstreamStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for JetstreamStats {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(accounts) = &self.accounts {
                format!("{:?}", accounts).into()
            } else {
                String::new().into()
            },
            if let Some(api) = &self.api {
                format!("{:?}", api).into()
            } else {
                String::new().into()
            },
            if let Some(ha_assets) = &self.ha_assets {
                format!("{:?}", ha_assets).into()
            } else {
                String::new().into()
            },
            if let Some(memory) = &self.memory {
                format!("{:?}", memory).into()
            } else {
                String::new().into()
            },
            if let Some(reserved_memory) = &self.reserved_memory {
                format!("{:?}", reserved_memory).into()
            } else {
                String::new().into()
            },
            if let Some(reserved_store) = &self.reserved_store {
                format!("{:?}", reserved_store).into()
            } else {
                String::new().into()
            },
            if let Some(store) = &self.store {
                format!("{:?}", store).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "accounts".into(),
            "api".into(),
            "ha_assets".into(),
            "memory".into(),
            "reserved_memory".into(),
            "reserved_store".into(),
            "store".into(),
        ]
    }
}

#[doc = "Extra params for the completions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct KclCodeCompletionParams {
    #[doc = "The language of the code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    #[doc = "The next indent of the code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_indent: Option<u8>,
    #[doc = "The prompt tokens for the completions."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prompt_tokens: Option<u32>,
    #[doc = "The suffix tokens for the completions."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suffix_tokens: Option<u32>,
    #[doc = "If we should trim by indentation."]
    #[serde(default)]
    pub trim_by_indentation: bool,
}

impl std::fmt::Display for KclCodeCompletionParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for KclCodeCompletionParams {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(language) = &self.language {
                format!("{:?}", language).into()
            } else {
                String::new().into()
            },
            if let Some(next_indent) = &self.next_indent {
                format!("{:?}", next_indent).into()
            } else {
                String::new().into()
            },
            if let Some(prompt_tokens) = &self.prompt_tokens {
                format!("{:?}", prompt_tokens).into()
            } else {
                String::new().into()
            },
            if let Some(suffix_tokens) = &self.suffix_tokens {
                format!("{:?}", suffix_tokens).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.trim_by_indentation).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "language".into(),
            "next_indent".into(),
            "prompt_tokens".into(),
            "suffix_tokens".into(),
            "trim_by_indentation".into(),
        ]
    }
}

#[doc = "A request to generate KCL code completions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct KclCodeCompletionRequest {
    #[doc = "Extra parameters for the completions."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra: Option<KclCodeCompletionParams>,
    #[doc = "The maximum number of tokens that can be generated for the completions. The total length of input tokens and generated tokens is limited by the model’s context length."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_tokens: Option<u16>,
    #[doc = "How many completion choices to generate for each input message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub n: Option<u8>,
    #[doc = "For GitHub copilot this is the `{org}/{repo}`. This does not do anything yet. But we wanted the same API as GitHub Copilot. It might be used in the future."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nwo: Option<String>,
    #[doc = "The prompt for the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prompt: Option<String>,
    #[doc = "Up to 4 sequences where the API will stop generating further tokens."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stop: Option<Vec<String>>,
    #[doc = "If set, partial message deltas will be sent, like in ChatGPT or OpenAPI. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message."]
    #[serde(default)]
    pub stream: bool,
    #[doc = "The suffix for the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suffix: Option<String>,
    #[doc = "The temperature for the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f64>,
    #[doc = "The top p for the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub top_p: Option<f64>,
}

impl std::fmt::Display for KclCodeCompletionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for KclCodeCompletionRequest {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(extra) = &self.extra {
                format!("{:?}", extra).into()
            } else {
                String::new().into()
            },
            if let Some(max_tokens) = &self.max_tokens {
                format!("{:?}", max_tokens).into()
            } else {
                String::new().into()
            },
            if let Some(n) = &self.n {
                format!("{:?}", n).into()
            } else {
                String::new().into()
            },
            if let Some(nwo) = &self.nwo {
                format!("{:?}", nwo).into()
            } else {
                String::new().into()
            },
            if let Some(prompt) = &self.prompt {
                format!("{:?}", prompt).into()
            } else {
                String::new().into()
            },
            if let Some(stop) = &self.stop {
                format!("{:?}", stop).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.stream).into(),
            if let Some(suffix) = &self.suffix {
                format!("{:?}", suffix).into()
            } else {
                String::new().into()
            },
            if let Some(temperature) = &self.temperature {
                format!("{:?}", temperature).into()
            } else {
                String::new().into()
            },
            if let Some(top_p) = &self.top_p {
                format!("{:?}", top_p).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "extra".into(),
            "max_tokens".into(),
            "n".into(),
            "nwo".into(),
            "prompt".into(),
            "stop".into(),
            "stream".into(),
            "suffix".into(),
            "temperature".into(),
            "top_p".into(),
        ]
    }
}

#[doc = "A response with KCL code completions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct KclCodeCompletionResponse {
    #[doc = "The completions."]
    pub completions: Vec<String>,
}

impl std::fmt::Display for KclCodeCompletionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for KclCodeCompletionResponse {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.completions).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["completions".into()]
    }
}

#[doc = "Leaf node information."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct LeafNode {
    #[doc = "The auth timeout of the leaf node."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_timeout: Option<i64>,
    #[doc = "The host of the leaf node."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[doc = "The port of the leaf node."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    #[doc = "The TLS timeout for the leaf node."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_timeout: Option<i64>,
}

impl std::fmt::Display for LeafNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for LeafNode {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(auth_timeout) = &self.auth_timeout {
                format!("{:?}", auth_timeout).into()
            } else {
                String::new().into()
            },
            if let Some(host) = &self.host {
                format!("{:?}", host).into()
            } else {
                String::new().into()
            },
            if let Some(port) = &self.port {
                format!("{:?}", port).into()
            } else {
                String::new().into()
            },
            if let Some(tls_timeout) = &self.tls_timeout {
                format!("{:?}", tls_timeout).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "auth_timeout".into(),
            "host".into(),
            "port".into(),
            "tls_timeout".into(),
        ]
    }
}

#[doc = "The mass response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Mass {
    #[doc = "The mass."]
    pub mass: f64,
    #[doc = "The output unit for the mass."]
    pub output_unit: UnitMass,
}

impl std::fmt::Display for Mass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Mass {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.mass).into(),
            format!("{:?}", self.output_unit).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["mass".into(), "output_unit".into()]
    }
}

#[doc = "Jetstream statistics."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MetaClusterInfo {
    #[doc = "The size of the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster_size: Option<i64>,
    #[doc = "The leader of the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub leader: Option<String>,
    #[doc = "The name of the cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for MetaClusterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MetaClusterInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(cluster_size) = &self.cluster_size {
                format!("{:?}", cluster_size).into()
            } else {
                String::new().into()
            },
            if let Some(leader) = &self.leader {
                format!("{:?}", leader).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["cluster_size".into(), "leader".into(), "name".into()]
    }
}

#[doc = "Metadata about our currently running server.\n\nThis is mostly used for internal purposes and debugging."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Metadata {
    #[doc = "Metadata about our cache."]
    pub cache: CacheMetadata,
    #[doc = "The environment we are running in."]
    pub environment: Environment,
    #[doc = "Metadata about our file system."]
    pub fs: FileSystemMetadata,
    #[doc = "The git hash of the server."]
    pub git_hash: String,
    #[doc = "Metadata about our pub-sub connection."]
    pub pubsub: Connection,
}

impl std::fmt::Display for Metadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Metadata {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.cache).into(),
            format!("{:?}", self.environment).into(),
            format!("{:?}", self.fs).into(),
            self.git_hash.clone().into(),
            format!("{:?}", self.pubsub).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "cache".into(),
            "environment".into(),
            "fs".into(),
            "git_hash".into(),
            "pubsub".into(),
        ]
    }
}

#[doc = "The Request Method (VERB)\n\nThis type also contains constants for a number of common HTTP methods such as GET, POST, etc.\n\nCurrently includes 8 variants representing the 8 methods defined in [RFC 7230](https://tools.ietf.org/html/rfc7231#section-4.1), plus PATCH, and an Extension variant for all extensions."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Method {
    #[doc = "The `OPTIONS` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.2.1)."]
    #[serde(rename = "OPTIONS")]
    #[display("OPTIONS")]
    Options,
    #[doc = "The `GET` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1)."]
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[doc = "The `POST` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1)."]
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[doc = "The `PUT` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1)."]
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[doc = "The `DELETE` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.5)."]
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
    #[doc = "The `HEAD` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.2)."]
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[doc = "The `TRACE` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3)."]
    #[serde(rename = "TRACE")]
    #[display("TRACE")]
    Trace,
    #[doc = "The `CONNECT` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.6)."]
    #[serde(rename = "CONNECT")]
    #[display("CONNECT")]
    Connect,
    #[doc = "The `PATCH` method as defined in [RFC 5789](https://tools.ietf.org/html/rfc5789)."]
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[doc = "A catch all."]
    #[serde(rename = "EXTENSION")]
    #[display("EXTENSION")]
    Extension,
}

#[doc = "Type for modeling-app events"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ModelingAppEventType {
    #[doc = "This event is sent before the modeling app or project is closed. The attachment should contain the contents of the most recent successful compile."]
    #[serde(rename = "successful_compile_before_close")]
    #[display("successful_compile_before_close")]
    SuccessfulCompileBeforeClose,
}

impl std::default::Default for ModelingAppEventType {
    fn default() -> Self {
        ModelingAppEventType::SuccessfulCompileBeforeClose
    }
}

#[doc = "The subscription tiers we offer for the Modeling App to individuals."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ModelingAppIndividualSubscriptionTier {
    #[doc = "The free tier."]
    #[serde(rename = "free")]
    #[display("free")]
    Free,
    #[doc = "The pro tier."]
    #[serde(rename = "pro")]
    #[display("pro")]
    Pro,
}

#[doc = "The subscription tiers we offer for the Modeling App to organizations."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ModelingAppOrganizationSubscriptionTier {
    #[doc = "The team tier."]
    #[serde(rename = "team")]
    #[display("team")]
    Team,
    #[doc = "The enterprise tier."]
    #[serde(rename = "enterprise")]
    #[display("enterprise")]
    Enterprise,
}

#[doc = "A subscription tier we offer for the Modeling App."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ModelingAppSubscriptionTier {
    #[doc = "A description of the tier."]
    pub description: String,
    #[doc = "Features that are included in the subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub features: Option<Vec<SubscriptionTierFeature>>,
    #[doc = "The name of the tier."]
    pub name: ModelingAppSubscriptionTierName,
    #[doc = "The amount of pay-as-you-go credits the individual or org gets outside the modeling app."]
    pub pay_as_you_go_credits: f64,
    #[doc = "The price of the tier per month. If this is for an individual, this is the price they pay. If this is for an organization, this is the price the organization pays per member in the org. This is in USD."]
    pub price: SubscriptionTierPrice,
    #[doc = "The support tier the subscription provides."]
    pub support_tier: SupportTier,
    #[doc = "The behavior of the users data (can it be used for training, etc)."]
    pub training_data_behavior: SubscriptionTrainingDataBehavior,
    #[doc = "If the tier is offered for an individual or an org."]
    #[serde(rename = "type")]
    pub type_: SubscriptionTierType,
    #[doc = "The Zoo tools that you can call unlimited times with this tier."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zoo_tools_included: Option<Vec<ZooTool>>,
}

impl std::fmt::Display for ModelingAppSubscriptionTier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ModelingAppSubscriptionTier {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            if let Some(features) = &self.features {
                format!("{:?}", features).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.name).into(),
            format!("{:?}", self.pay_as_you_go_credits).into(),
            format!("{:?}", self.price).into(),
            format!("{:?}", self.support_tier).into(),
            format!("{:?}", self.training_data_behavior).into(),
            format!("{:?}", self.type_).into(),
            if let Some(zoo_tools_included) = &self.zoo_tools_included {
                format!("{:?}", zoo_tools_included).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "features".into(),
            "name".into(),
            "pay_as_you_go_credits".into(),
            "price".into(),
            "support_tier".into(),
            "training_data_behavior".into(),
            "type_".into(),
            "zoo_tools_included".into(),
        ]
    }
}

#[doc = "An enum representing a Modeling App subscription tier name."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ModelingAppSubscriptionTierName {
    #[doc = "The free tier."]
    #[serde(rename = "free")]
    #[display("free")]
    Free,
    #[doc = "The pro tier."]
    #[serde(rename = "pro")]
    #[display("pro")]
    Pro,
    #[doc = "The team tier."]
    #[serde(rename = "team")]
    #[display("team")]
    Team,
    #[doc = "The enterprise tier."]
    #[serde(rename = "enterprise")]
    #[display("enterprise")]
    Enterprise,
}

#[doc = "Commands that the KittyCAD engine can execute."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum ModelingCmd {
    #[doc = "Start a new path."]
    #[serde(rename = "start_path")]
    StartPath {},
    #[doc = "Move the path's \"pen\"."]
    #[serde(rename = "move_path_pen")]
    MovePathPen {
        #[doc = "The ID of the command which created the path."]
        path: uuid::Uuid,
        #[doc = "Where the path's pen should be."]
        to: Point3D,
    },
    #[doc = "Extend a path by adding a new segment which starts at the path's \"pen\". If no \"pen\" location has been set before (via `MovePen`), then the pen is at the origin."]
    #[serde(rename = "extend_path")]
    ExtendPath {
        #[doc = "The ID of the command which created the path."]
        path: uuid::Uuid,
        #[doc = "Segment to append to the path. This segment will implicitly begin at the current \"pen\" location."]
        segment: PathSegment,
    },
    #[doc = "Command for extruding a solid 2d."]
    #[serde(rename = "extrude")]
    Extrude {
        #[doc = "Whether to cap the extrusion with a face, or not. If true, the resulting solid will be closed on all sides, like a dice. If false, it will be open on one side, like a drinking glass."]
        cap: bool,
        #[doc = "How far off the plane to extrude"]
        distance: f64,
        #[doc = "Which sketch to extrude. Must be a closed 2D solid."]
        target: uuid::Uuid,
    },
    #[doc = "Command for revolving a solid 2d."]
    #[serde(rename = "revolve")]
    Revolve {
        #[doc = "The signed angle of revolution (in degrees, must be <= 360 in either direction)"]
        angle: Angle,
        #[doc = "The axis of the extrusion (taken from the origin)"]
        axis: Point3D,
        #[doc = "If true, the axis is interpreted within the 2D space of the solid 2D's plane"]
        axis_is_2d: bool,
        #[doc = "The origin of the extrusion axis"]
        origin: Point3D,
        #[doc = "Which sketch to revolve. Must be a closed 2D solid."]
        target: uuid::Uuid,
        #[doc = "The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero)."]
        tolerance: f64,
    },
    #[doc = "Command for revolving a solid 2d about a brep edge"]
    #[serde(rename = "revolve_about_edge")]
    RevolveAboutEdge {
        #[doc = "The signed angle of revolution (in degrees, must be <= 360 in either direction)"]
        angle: Angle,
        #[doc = "The edge to use as the axis of revolution, must be linear and lie in the plane of the solid"]
        edge_id: uuid::Uuid,
        #[doc = "Which sketch to revolve. Must be a closed 2D solid."]
        target: uuid::Uuid,
        #[doc = "The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero)."]
        tolerance: f64,
    },
    #[doc = "Closes a path, converting it to a 2D solid."]
    #[serde(rename = "close_path")]
    ClosePath {
        #[doc = "Which path to close."]
        path_id: uuid::Uuid,
    },
    #[doc = "Camera drag started."]
    #[serde(rename = "camera_drag_start")]
    CameraDragStart {
        #[doc = "The type of camera drag interaction."]
        interaction: CameraDragInteractionType,
        #[doc = "The initial mouse position."]
        window: Point2D,
    },
    #[doc = "Camera drag continued."]
    #[serde(rename = "camera_drag_move")]
    CameraDragMove {
        #[doc = "The type of camera drag interaction."]
        interaction: CameraDragInteractionType,
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        sequence: Option<u32>,
        #[doc = "The current mouse position."]
        window: Point2D,
    },
    #[doc = "Camera drag ended"]
    #[serde(rename = "camera_drag_end")]
    CameraDragEnd {
        #[doc = "The type of camera drag interaction."]
        interaction: CameraDragInteractionType,
        #[doc = "The final mouse position."]
        window: Point2D,
    },
    #[doc = "Gets the default camera's camera settings"]
    #[serde(rename = "default_camera_get_settings")]
    DefaultCameraGetSettings {},
    #[doc = "Change what the default camera is looking at."]
    #[serde(rename = "default_camera_look_at")]
    DefaultCameraLookAt {
        #[doc = "What the camera is looking at. Center of the camera's field of vision"]
        center: Point3D,
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        sequence: Option<u32>,
        #[doc = "Which way is \"up\", from the camera's point of view."]
        up: Point3D,
        #[doc = "Where the camera is positioned"]
        vantage: Point3D,
    },
    #[doc = "Change what the default camera is looking at."]
    #[serde(rename = "default_camera_perspective_settings")]
    DefaultCameraPerspectiveSettings {
        #[doc = "What the camera is looking at. Center of the camera's field of vision"]
        center: Point3D,
        #[doc = "The field of view angle in the y direction, in degrees."]
        fov_y: f64,
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        sequence: Option<u32>,
        #[doc = "Which way is \"up\", from the camera's point of view."]
        up: Point3D,
        #[doc = "Where the camera is positioned"]
        vantage: Point3D,
        #[doc = "The distance to the far clipping plane."]
        z_far: f64,
        #[doc = "The distance to the near clipping plane."]
        z_near: f64,
    },
    #[doc = "Adjust zoom of the default camera."]
    #[serde(rename = "default_camera_zoom")]
    DefaultCameraZoom {
        #[doc = "Move the camera forward along the vector it's looking at, by this magnitudedefaultCameraZoom. Basically, how much should the camera move forward by."]
        magnitude: f64,
    },
    #[doc = "Enable sketch mode, where users can sketch 2D geometry. Users choose a plane to sketch on."]
    #[serde(rename = "default_camera_enable_sketch_mode")]
    DefaultCameraEnableSketchMode {
        #[doc = "Should we animate or snap for the camera transition?"]
        animated: bool,
        #[doc = "How far to the sketching plane?"]
        distance_to_plane: f64,
        #[doc = "What's the origin of the sketching plane?"]
        origin: Point3D,
        #[doc = "Should the camera use orthographic projection? In other words, should an object's size in the rendered image stay constant regardless of its distance from the camera."]
        ortho: bool,
        #[doc = "Which 3D axis of the scene should be the X axis of the sketching plane?"]
        x_axis: Point3D,
        #[doc = "Which 3D axis of the scene should be the Y axis of the sketching plane?"]
        y_axis: Point3D,
    },
    #[doc = "Disable sketch mode, from the default camera."]
    #[serde(rename = "default_camera_disable_sketch_mode")]
    DefaultCameraDisableSketchMode {},
    #[doc = "Export the scene to a file."]
    #[serde(rename = "export")]
    Export {
        #[doc = "IDs of the entities to be exported. If this is empty, then all entities are exported."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The file format to export to."]
        format: OutputFormat,
    },
    #[doc = "What is this entity's parent?"]
    #[serde(rename = "entity_get_parent_id")]
    EntityGetParentId {
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "How many children does the entity have?"]
    #[serde(rename = "entity_get_num_children")]
    EntityGetNumChildren {
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "What is the UUID of this entity's n-th child?"]
    #[serde(rename = "entity_get_child_uuid")]
    EntityGetChildUuid {
        #[doc = "Index into the entity's list of children."]
        child_index: u32,
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "What are all UUIDs of this entity's children?"]
    #[serde(rename = "entity_get_all_child_uuids")]
    EntityGetAllChildUuids {
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "What is the distance between these two entities?"]
    #[serde(rename = "entity_get_distance")]
    EntityGetDistance {
        #[doc = "Type of distance to be measured."]
        distance_type: DistanceType,
        #[doc = "ID of the first entity being queried."]
        entity_id1: uuid::Uuid,
        #[doc = "ID of the second entity being queried."]
        entity_id2: uuid::Uuid,
    },
    #[doc = "Create a linear pattern using this entity."]
    #[serde(rename = "entity_linear_pattern")]
    EntityLinearPattern {
        #[doc = "Axis along which to make the copies. For Solid2d patterns, the z component is ignored."]
        axis: Point3D,
        #[doc = "ID of the entity being copied."]
        entity_id: uuid::Uuid,
        #[doc = "Number of repetitions to make."]
        num_repetitions: u32,
        #[doc = "Spacing between repetitions."]
        spacing: f64,
    },
    #[doc = "Create a circular pattern using this entity."]
    #[serde(rename = "entity_circular_pattern")]
    EntityCircularPattern {
        #[doc = "Arc angle (in degrees) to place repetitions along."]
        arc_degrees: f64,
        #[doc = "Axis around which to make the copies. For Solid2d patterns, this is ignored."]
        axis: Point3D,
        #[doc = "Point around which to make the copies. For Solid2d patterns, the z component is ignored."]
        center: Point3D,
        #[doc = "ID of the entity being copied."]
        entity_id: uuid::Uuid,
        #[doc = "Number of repetitions to make."]
        num_repetitions: u32,
        #[doc = "Whether or not to rotate the objects as they are copied."]
        rotate_duplicates: bool,
    },
    #[doc = "Create a helix using the input cylinder and other specified parameters."]
    #[serde(rename = "entity_make_helix")]
    EntityMakeHelix {
        #[doc = "ID of the cylinder."]
        cylinder_id: uuid::Uuid,
        #[doc = "Is the helix rotation clockwise?"]
        is_clockwise: bool,
        #[doc = "Length of the helix."]
        length: f64,
        #[doc = "Number of revolutions."]
        revolutions: f64,
        #[doc = "Start angle (in degrees)."]
        start_angle: Angle,
    },
    #[doc = "Enter edit mode"]
    #[serde(rename = "edit_mode_enter")]
    EditModeEnter {
        #[doc = "The edit target"]
        target: uuid::Uuid,
    },
    #[doc = "Modifies the selection by simulating a \"mouse click\" at the given x,y window coordinate Returns ID of whatever was selected."]
    #[serde(rename = "select_with_point")]
    SelectWithPoint {
        #[doc = "Where in the window was selected"]
        selected_at_window: Point2D,
        #[doc = "What entity was selected?"]
        selection_type: SceneSelectionType,
    },
    #[doc = "Adds one or more entities (by UUID) to the selection."]
    #[serde(rename = "select_add")]
    SelectAdd {
        #[doc = "Which entities to select"]
        entities: Vec<uuid::Uuid>,
    },
    #[doc = "Removes one or more entities (by UUID) from the selection."]
    #[serde(rename = "select_remove")]
    SelectRemove {
        #[doc = "Which entities to unselect"]
        entities: Vec<uuid::Uuid>,
    },
    #[doc = "Removes all of the Objects in the scene"]
    #[serde(rename = "scene_clear_all")]
    SceneClearAll {},
    #[doc = "Replaces current selection with these entities (by UUID)."]
    #[serde(rename = "select_replace")]
    SelectReplace {
        #[doc = "Which entities to select"]
        entities: Vec<uuid::Uuid>,
    },
    #[doc = "Changes the current highlighted entity to whichever one is at the given window coordinate. If there's no entity at this location, clears the highlight."]
    #[serde(rename = "highlight_set_entity")]
    HighlightSetEntity {
        #[doc = "Coordinates of the window being clicked"]
        selected_at_window: Point2D,
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        sequence: Option<u32>,
    },
    #[doc = "Changes the current highlighted entity to these entities."]
    #[serde(rename = "highlight_set_entities")]
    HighlightSetEntities {
        #[doc = "Highlight these entities."]
        entities: Vec<uuid::Uuid>,
    },
    #[doc = "Create a new annotation"]
    #[serde(rename = "new_annotation")]
    NewAnnotation {
        #[doc = "What type of annotation to create."]
        annotation_type: AnnotationType,
        #[doc = "If true, any existing drawables within the obj will be replaced (the object will be reset)"]
        clobber: bool,
        #[doc = "What should the annotation contain?"]
        options: AnnotationOptions,
    },
    #[doc = "Update an annotation"]
    #[serde(rename = "update_annotation")]
    UpdateAnnotation {
        #[doc = "Which annotation to update"]
        annotation_id: uuid::Uuid,
        #[doc = "If any of these fields are set, they will overwrite the previous options for the annotation."]
        options: AnnotationOptions,
    },
    #[doc = "Hide or show an object"]
    #[serde(rename = "object_visible")]
    ObjectVisible {
        #[doc = "Whether or not the object should be hidden."]
        hidden: bool,
        #[doc = "Which object to change"]
        object_id: uuid::Uuid,
    },
    #[doc = "Bring an object to the front of the scene"]
    #[serde(rename = "object_bring_to_front")]
    ObjectBringToFront {
        #[doc = "Which object to change"]
        object_id: uuid::Uuid,
    },
    #[doc = "Set the material properties of an object"]
    #[serde(rename = "object_set_material_params_pbr")]
    ObjectSetMaterialParamsPbr {
        #[doc = "Ambient Occlusion of the new material"]
        ambient_occlusion: f64,
        #[doc = "Color of the new material"]
        color: Color,
        #[doc = "Metalness of the new material"]
        metalness: f64,
        #[doc = "Which object to change"]
        object_id: uuid::Uuid,
        #[doc = "Roughness of the new material"]
        roughness: f64,
    },
    #[doc = "What type of entity is this?"]
    #[serde(rename = "get_entity_type")]
    GetEntityType {
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "Gets all faces which use the given edge."]
    #[serde(rename = "solid3d_get_all_edge_faces")]
    Solid3DGetAllEdgeFaces {
        #[doc = "Which edge you want the faces of."]
        edge_id: uuid::Uuid,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Add a hole to a Solid2d object before extruding it."]
    #[serde(rename = "solid2d_add_hole")]
    Solid2DAddHole {
        #[doc = "The id of the path to use as the inner profile (hole)."]
        hole_id: uuid::Uuid,
        #[doc = "Which object to add the hole to."]
        object_id: uuid::Uuid,
    },
    #[doc = "Gets all edges which are opposite the given edge, across all possible faces."]
    #[serde(rename = "solid3d_get_all_opposite_edges")]
    Solid3DGetAllOppositeEdges {
        #[doc = "If given, only faces parallel to this vector will be considered."]
        along_vector: Option<Point3D>,
        #[doc = "Which edge you want the opposites of."]
        edge_id: uuid::Uuid,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Gets the edge opposite the given edge, along the given face."]
    #[serde(rename = "solid3d_get_opposite_edge")]
    Solid3DGetOppositeEdge {
        #[doc = "Which edge you want the opposite of."]
        edge_id: uuid::Uuid,
        #[doc = "Which face is used to figure out the opposite edge?"]
        face_id: uuid::Uuid,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Gets the next adjacent edge for the given edge, along the given face."]
    #[serde(rename = "solid3d_get_next_adjacent_edge")]
    Solid3DGetNextAdjacentEdge {
        #[doc = "Which edge you want the opposite of."]
        edge_id: uuid::Uuid,
        #[doc = "Which face is used to figure out the opposite edge?"]
        face_id: uuid::Uuid,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Gets the previous adjacent edge for the given edge, along the given face."]
    #[serde(rename = "solid3d_get_prev_adjacent_edge")]
    Solid3DGetPrevAdjacentEdge {
        #[doc = "Which edge you want the opposite of."]
        edge_id: uuid::Uuid,
        #[doc = "Which face is used to figure out the opposite edge?"]
        face_id: uuid::Uuid,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Fillets the given edge with the specified radius."]
    #[serde(rename = "solid3d_fillet_edge")]
    Solid3DFilletEdge {
        #[doc = "Which edge you want to fillet."]
        edge_id: uuid::Uuid,
        #[doc = "Which object is being filletted."]
        object_id: uuid::Uuid,
        #[doc = "The radius of the fillet. Measured in length (using the same units that the current sketch uses). Must be positive (i.e. greater than zero)."]
        radius: f64,
        #[doc = "The maximum acceptable surface gap computed between the filleted surfaces. Must be positive (i.e. greater than zero)."]
        tolerance: f64,
    },
    #[doc = "Determines whether a brep face is planar and returns its surface-local planar axes if so"]
    #[serde(rename = "face_is_planar")]
    FaceIsPlanar {
        #[doc = "Which face is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Determines a position on a brep face evaluated by parameters u,v"]
    #[serde(rename = "face_get_position")]
    FaceGetPosition {
        #[doc = "Which face is being queried."]
        object_id: uuid::Uuid,
        #[doc = "The 2D paramter-space u,v position to evaluate the surface at"]
        uv: Point2D,
    },
    #[doc = "Determines the gradient (dFdu, dFdv) + normal vector on a brep face evaluated by parameters u,v"]
    #[serde(rename = "face_get_gradient")]
    FaceGetGradient {
        #[doc = "Which face is being queried."]
        object_id: uuid::Uuid,
        #[doc = "The 2D paramter-space u,v position to evaluate the surface at"]
        uv: Point2D,
    },
    #[doc = "Send object to front or back."]
    #[serde(rename = "send_object")]
    SendObject {
        #[doc = "Bring to front = true, send to back = false."]
        front: bool,
        #[doc = "Which object is being changed."]
        object_id: uuid::Uuid,
    },
    #[doc = "Set opacity of the entity."]
    #[serde(rename = "entity_set_opacity")]
    EntitySetOpacity {
        #[doc = "Which entity is being changed."]
        entity_id: uuid::Uuid,
        #[doc = "How transparent should it be? 0 or lower is totally transparent. 1 or greater is totally opaque."]
        opacity: f64,
    },
    #[doc = "Fade entity in or out."]
    #[serde(rename = "entity_fade")]
    EntityFade {
        #[doc = "How many seconds the animation should take."]
        duration_seconds: Option<f64>,
        #[doc = "Which entity is being changed."]
        entity_id: uuid::Uuid,
        #[doc = "Fade in = true, fade out = false."]
        fade_in: bool,
    },
    #[doc = "Make a new plane"]
    #[serde(rename = "make_plane")]
    MakePlane {
        #[doc = "If true, any existing drawables within the obj will be replaced (the object will be reset)"]
        clobber: bool,
        #[doc = "If true, the plane will be created but hidden initially."]
        hide: Option<bool>,
        #[doc = "Origin of the plane"]
        origin: Point3D,
        #[doc = "What should the plane's span/extent? When rendered visually, this is both the width and height along X and Y axis respectively."]
        size: f64,
        #[doc = "What should the plane's X axis be?"]
        x_axis: Point3D,
        #[doc = "What should the plane's Y axis be?"]
        y_axis: Point3D,
    },
    #[doc = "Set the color of a plane."]
    #[serde(rename = "plane_set_color")]
    PlaneSetColor {
        #[doc = "What color it should be."]
        color: Color,
        #[doc = "Which plane is being changed."]
        plane_id: uuid::Uuid,
    },
    #[doc = "Set the current tool."]
    #[serde(rename = "set_tool")]
    SetTool {
        #[doc = "What tool should be active."]
        tool: SceneToolType,
    },
    #[doc = "Send a mouse move event"]
    #[serde(rename = "mouse_move")]
    MouseMove {
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        sequence: Option<u32>,
        #[doc = "Where the mouse is"]
        window: Point2D,
    },
    #[doc = "Send a mouse click event Updates modified/selected entities."]
    #[serde(rename = "mouse_click")]
    MouseClick {
        #[doc = "Where the mouse is"]
        window: Point2D,
    },
    #[doc = "Enable sketch mode on the given plane. If you want to sketch on a face, use `enable_sketch_mode` instead."]
    #[serde(rename = "sketch_mode_enable")]
    SketchModeEnable {
        #[doc = "Animate the transition to sketch mode."]
        animated: bool,
        #[doc = "Disable the camera entirely for sketch mode and sketch on a plane (this would be the normal of that plane)."]
        disable_camera_with_plane: Option<Point3D>,
        #[doc = "Use an orthographic camera."]
        ortho: bool,
        #[doc = "Sketch on this plane."]
        plane_id: uuid::Uuid,
    },
    #[doc = "Disable sketch mode. If you are sketching on a face, be sure to not disable sketch mode until you have extruded. Otherwise, your object will not be fused with the face."]
    #[serde(rename = "sketch_mode_disable")]
    SketchModeDisable {},
    #[doc = "Get the plane for sketch mode."]
    #[serde(rename = "get_sketch_mode_plane")]
    GetSketchModePlane {},
    #[doc = "Get the plane for sketch mode."]
    #[serde(rename = "curve_set_constraint")]
    CurveSetConstraint {
        #[doc = "Which constraint to apply."]
        constraint_bound: PathComponentConstraintBound,
        #[doc = "What part of the curve should be constrained."]
        constraint_type: PathComponentConstraintType,
        #[doc = "Which curve to constrain."]
        object_id: uuid::Uuid,
    },
    #[doc = "Sketch on some entity (e.g. a plane, a face)."]
    #[serde(rename = "enable_sketch_mode")]
    EnableSketchMode {
        #[doc = "Should the camera move at all?"]
        adjust_camera: bool,
        #[doc = "Should we animate or snap for the camera transition?"]
        animated: bool,
        #[doc = "Which entity to sketch on."]
        entity_id: uuid::Uuid,
        #[doc = "Should the camera use orthographic projection? In other words, should an object's size in the rendered image stay constant regardless of its distance from the camera."]
        ortho: bool,
    },
    #[doc = "Set the background color of the scene."]
    #[serde(rename = "set_background_color")]
    SetBackgroundColor {
        #[doc = "The color to set the background to."]
        color: Color,
    },
    #[doc = "Set the properties of the tool lines for the scene."]
    #[serde(rename = "set_current_tool_properties")]
    SetCurrentToolProperties {
        #[doc = "The color to set the tool line to."]
        color: Option<Color>,
    },
    #[doc = "Set the default system properties used when a specific property isn't set."]
    #[serde(rename = "set_default_system_properties")]
    SetDefaultSystemProperties {
        #[doc = "The default system color."]
        color: Option<Color>,
    },
    #[doc = "Get type of the given curve."]
    #[serde(rename = "curve_get_type")]
    CurveGetType {
        #[doc = "Which curve to query."]
        curve_id: uuid::Uuid,
    },
    #[doc = "Get control points of the given curve."]
    #[serde(rename = "curve_get_control_points")]
    CurveGetControlPoints {
        #[doc = "Which curve to query."]
        curve_id: uuid::Uuid,
    },
    #[doc = "Take a snapshot of the current view."]
    #[serde(rename = "take_snapshot")]
    TakeSnapshot {
        #[doc = "What image format to return."]
        format: ImageFormat,
    },
    #[doc = "Add a gizmo showing the axes."]
    #[serde(rename = "make_axes_gizmo")]
    MakeAxesGizmo {
        #[doc = "If true, any existing drawables within the obj will be replaced (the object will be reset)"]
        clobber: bool,
        #[doc = "If true, axes gizmo will be placed in the corner of the screen. If false, it will be placed at the origin of the scene."]
        gizmo_mode: bool,
    },
    #[doc = "Query the given path."]
    #[serde(rename = "path_get_info")]
    PathGetInfo {
        #[doc = "Which path to query"]
        path_id: uuid::Uuid,
    },
    #[doc = "Obtain curve ids for vertex ids"]
    #[serde(rename = "path_get_curve_uuids_for_vertices")]
    PathGetCurveUuidsForVertices {
        #[doc = "Which path to query"]
        path_id: uuid::Uuid,
        #[doc = "IDs of the vertices for which to obtain curve ids from"]
        vertex_ids: Vec<uuid::Uuid>,
    },
    #[doc = "Obtain vertex ids for a path"]
    #[serde(rename = "path_get_vertex_uuids")]
    PathGetVertexUuids {
        #[doc = "Which path to query"]
        path_id: uuid::Uuid,
    },
    #[doc = "Start dragging the mouse."]
    #[serde(rename = "handle_mouse_drag_start")]
    HandleMouseDragStart {
        #[doc = "The mouse position."]
        window: Point2D,
    },
    #[doc = "Continue dragging the mouse."]
    #[serde(rename = "handle_mouse_drag_move")]
    HandleMouseDragMove {
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        sequence: Option<u32>,
        #[doc = "The mouse position."]
        window: Point2D,
    },
    #[doc = "Stop dragging the mouse."]
    #[serde(rename = "handle_mouse_drag_end")]
    HandleMouseDragEnd {
        #[doc = "The mouse position."]
        window: Point2D,
    },
    #[doc = "Remove scene objects."]
    #[serde(rename = "remove_scene_objects")]
    RemoveSceneObjects {
        #[doc = "Objects to remove."]
        object_ids: Vec<uuid::Uuid>,
    },
    #[doc = "Utility method. Performs both a ray cast and projection to plane-local coordinates. Returns the plane coordinates for the given window coordinates."]
    #[serde(rename = "plane_intersect_and_project")]
    PlaneIntersectAndProject {
        #[doc = "The plane you're intersecting against."]
        plane_id: uuid::Uuid,
        #[doc = "Window coordinates where the ray cast should be aimed."]
        window: Point2D,
    },
    #[doc = "Find the start and end of a curve."]
    #[serde(rename = "curve_get_end_points")]
    CurveGetEndPoints {
        #[doc = "ID of the curve being queried."]
        curve_id: uuid::Uuid,
    },
    #[doc = "Reconfigure the stream."]
    #[serde(rename = "reconfigure_stream")]
    ReconfigureStream {
        #[doc = "Frames per second."]
        fps: u32,
        #[doc = "Height of the stream."]
        height: u32,
        #[doc = "Width of the stream."]
        width: u32,
    },
    #[doc = "Import files to the current model."]
    #[serde(rename = "import_files")]
    ImportFiles {
        #[doc = "Files to import."]
        files: Vec<ImportFile>,
        #[doc = "Input file format."]
        format: InputFormat,
    },
    #[doc = "Set the units of the scene. For all following commands, the units will be interpreted as the given units."]
    #[serde(rename = "set_scene_units")]
    SetSceneUnits {
        #[doc = "Which units the scene uses."]
        unit: UnitLength,
    },
    #[doc = "Get the mass of entities in the scene or the default scene."]
    #[serde(rename = "mass")]
    Mass {
        #[doc = "IDs of the entities to get the mass of. If this is empty, then the default scene is included in the mass."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The material density."]
        material_density: f64,
        #[doc = "The material density unit."]
        material_density_unit: UnitDensity,
        #[doc = "The output unit for the mass."]
        output_unit: UnitMass,
    },
    #[doc = "Get the density of entities in the scene or the default scene."]
    #[serde(rename = "density")]
    Density {
        #[doc = "IDs of the entities to get the density of. If this is empty, then the default scene is included in the density."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The material mass."]
        material_mass: f64,
        #[doc = "The material mass unit."]
        material_mass_unit: UnitMass,
        #[doc = "The output unit for the density."]
        output_unit: UnitDensity,
    },
    #[doc = "Get the volume of entities in the scene or the default scene."]
    #[serde(rename = "volume")]
    Volume {
        #[doc = "IDs of the entities to get the volume of. If this is empty, then the default scene is included in the volume."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The output unit for the volume."]
        output_unit: UnitVolume,
    },
    #[doc = "Get the center of mass of entities in the scene or the default scene."]
    #[serde(rename = "center_of_mass")]
    CenterOfMass {
        #[doc = "IDs of the entities to get the center of mass of. If this is empty, then the default scene is included in the center of mass."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The output unit for the center of mass."]
        output_unit: UnitLength,
    },
    #[doc = "Get the surface area of entities in the scene or the default scene."]
    #[serde(rename = "surface_area")]
    SurfaceArea {
        #[doc = "IDs of the entities to get the surface area of. If this is empty, then the default scene is included in the surface area."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The output unit for the surface area."]
        output_unit: UnitArea,
    },
    #[doc = "Focus the default camera upon an object in the scene."]
    #[serde(rename = "default_camera_focus_on")]
    DefaultCameraFocusOn {
        #[doc = "UUID of object to focus on."]
        uuid: uuid::Uuid,
    },
    #[doc = "When you select some entity with the current tool, what should happen to the entity?"]
    #[serde(rename = "set_selection_type")]
    SetSelectionType {
        #[doc = "What type of selection should occur when you select something?"]
        selection_type: SceneSelectionType,
    },
    #[doc = "What kind of entities can be selected?"]
    #[serde(rename = "set_selection_filter")]
    SetSelectionFilter {
        #[doc = "If vector is empty, clear all filters. If vector is non-empty, only the given entity types will be selectable."]
        filter: Vec<EntityType>,
    },
    #[doc = "Use orthographic projection."]
    #[serde(rename = "default_camera_set_orthographic")]
    DefaultCameraSetOrthographic {},
    #[doc = "Use perspective projection."]
    #[serde(rename = "default_camera_set_perspective")]
    DefaultCameraSetPerspective {
        #[doc = "If this is not given, use the same parameters as last time the perspective camera was used."]
        parameters: Option<PerspectiveCameraParameters>,
    },
    #[doc = "Get a concise description of all of an extrusion's faces."]
    #[serde(rename = "solid3d_get_extrusion_face_info")]
    Solid3DGetExtrusionFaceInfo {
        #[doc = "Any edge that lies on the extrusion base path."]
        edge_id: uuid::Uuid,
        #[doc = "The Solid3d object whose extrusion is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Exit edit mode"]
    #[serde(rename = "edit_mode_exit")]
    EditModeExit {},
    #[doc = "Clear the selection"]
    #[serde(rename = "select_clear")]
    SelectClear {},
    #[doc = "Find all IDs of selected entities"]
    #[serde(rename = "select_get")]
    SelectGet {},
    #[doc = "Get the number of objects in the scene"]
    #[serde(rename = "get_num_objects")]
    GetNumObjects {},
}

#[doc = "A graphics command submitted to the KittyCAD engine via the Modeling API."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ModelingCmdReq {
    #[doc = "Which command to submit to the Kittycad engine."]
    pub cmd: ModelingCmd,
    #[doc = "ID of command being submitted."]
    pub cmd_id: uuid::Uuid,
}

impl std::fmt::Display for ModelingCmdReq {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ModelingCmdReq {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.cmd).into(),
            format!("{:?}", self.cmd_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["cmd".into(), "cmd_id".into()]
    }
}

#[doc = "The response from the `MouseClick` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MouseClick {
    #[doc = "Entities that are modified."]
    pub entities_modified: Vec<uuid::Uuid>,
    #[doc = "Entities that are selected."]
    pub entities_selected: Vec<uuid::Uuid>,
}

impl std::fmt::Display for MouseClick {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MouseClick {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.entities_modified).into(),
            format!("{:?}", self.entities_selected).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entities_modified".into(), "entities_selected".into()]
    }
}

#[doc = "Information about an OAuth 2.0 client."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Oauth2ClientInfo {
    #[doc = "Value used for [CSRF](https://tools.ietf.org/html/rfc6749#section-10.12) protection via the `state` parameter."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csrf_token: Option<String>,
    #[doc = "Code Verifier used for [PKCE]((https://tools.ietf.org/html/rfc7636)) protection via the `code_verifier` parameter. The value must have a minimum length of 43 characters and a maximum length of 128 characters.  Each character must be ASCII alphanumeric or one of the characters \"-\" / \".\" / \"_\" / \"~\"."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pkce_code_verifier: Option<String>,
    #[doc = "The URL for consent."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

impl std::fmt::Display for Oauth2ClientInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Oauth2ClientInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(csrf_token) = &self.csrf_token {
                format!("{:?}", csrf_token).into()
            } else {
                String::new().into()
            },
            if let Some(pkce_code_verifier) = &self.pkce_code_verifier {
                format!("{:?}", pkce_code_verifier).into()
            } else {
                String::new().into()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "csrf_token".into(),
            "pkce_code_verifier".into(),
            "url".into(),
        ]
    }
}

#[doc = "An OAuth 2.0 Grant Type. These are documented here: <https://oauth.net/2/grant-types/>."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Oauth2GrantType {
    #[doc = "An OAuth 2.0 Device Authorization Grant."]
    #[serde(rename = "urn:ietf:params:oauth:grant-type:device_code")]
    #[display("urn:ietf:params:oauth:grant-type:device_code")]
    UrnIetfParamsOauthGrantTypeDeviceCode,
}

impl std::default::Default for Oauth2GrantType {
    fn default() -> Self {
        Oauth2GrantType::UrnIetfParamsOauthGrantTypeDeviceCode
    }
}

#[doc = "A successful response from a modeling command. This can be one of several types of responses, depending on the command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum OkModelingCmdResponse {
    #[doc = "An empty response, used for any command that does not explicitly have a response defined here."]
    #[serde(rename = "empty")]
    Empty {},
    #[doc = "The response to the 'Export' endpoint"]
    #[serde(rename = "export")]
    Export {
        #[doc = "The response from the `Export` endpoint."]
        data: Export,
    },
    #[doc = "The response to the 'SelectWithPoint' endpoint"]
    #[serde(rename = "select_with_point")]
    SelectWithPoint {
        #[doc = "The response from the `SelectWithPoint` command."]
        data: SelectWithPoint,
    },
    #[doc = "The response to the 'HighlightSetEntity' endpoint"]
    #[serde(rename = "highlight_set_entity")]
    HighlightSetEntity {
        #[doc = "The response from the `HighlightSetEntity` command."]
        data: HighlightSetEntity,
    },
    #[doc = "The response to the 'EntityGetChildUuid' endpoint"]
    #[serde(rename = "entity_get_child_uuid")]
    EntityGetChildUuid {
        #[doc = "The response from the `EntityGetChildUuid` command."]
        data: EntityGetChildUuid,
    },
    #[doc = "The response to the 'EntityGetNumChildren' endpoint"]
    #[serde(rename = "entity_get_num_children")]
    EntityGetNumChildren {
        #[doc = "The response from the `EntityGetNumChildren` command."]
        data: EntityGetNumChildren,
    },
    #[doc = "The response to the 'EntityGetParentId' endpoint"]
    #[serde(rename = "entity_get_parent_id")]
    EntityGetParentId {
        #[doc = "The response from the `EntityGetParentId` command."]
        data: EntityGetParentId,
    },
    #[doc = "The response to the 'EntityGetAllChildUuids' endpoint"]
    #[serde(rename = "entity_get_all_child_uuids")]
    EntityGetAllChildUuids {
        #[doc = "The response from the `EntityGetAllChildUuids` command."]
        data: EntityGetAllChildUuids,
    },
    #[doc = "The response to the 'CameraDragMove' endpoint"]
    #[serde(rename = "camera_drag_move")]
    CameraDragMove {
        #[doc = "The response from the `CameraDragMove` command. Note this is an \"unreliable\" channel message, so this data may need more data like a \"sequence\""]
        data: CameraDragMove,
    },
    #[doc = "The response to the 'CameraDragEnd' endpoint"]
    #[serde(rename = "camera_drag_end")]
    CameraDragEnd {
        #[doc = "The response from the `CameraDragEnd` command."]
        data: CameraDragEnd,
    },
    #[doc = "The response to the 'DefaultCameraGetSettings' endpoint"]
    #[serde(rename = "default_camera_get_settings")]
    DefaultCameraGetSettings {
        #[doc = "The response from the `DefaultCameraGetSettings` command."]
        data: DefaultCameraGetSettings,
    },
    #[doc = "The response to the 'DefaultCameraZoom' endpoint"]
    #[serde(rename = "default_camera_zoom")]
    DefaultCameraZoom {
        #[doc = "The response from the `DefaultCameraZoom` command."]
        data: DefaultCameraZoom,
    },
    #[doc = "The response to the 'GetNumObjects' endpoint"]
    #[serde(rename = "get_num_objects")]
    GetNumObjects {
        #[doc = "The response from the `GetNumObjects` command."]
        data: GetNumObjects,
    },
    #[doc = "The response to the 'DefaultCameraFocusOn' endpoint"]
    #[serde(rename = "default_camera_focus_on")]
    DefaultCameraFocusOn {
        #[doc = "The response from the `DefaultCameraFocusOn` command."]
        data: DefaultCameraFocusOn,
    },
    #[doc = "The response to the 'SelectGet' endpoint"]
    #[serde(rename = "select_get")]
    SelectGet {
        #[doc = "The response from the `SelectGet` command."]
        data: SelectGet,
    },
    #[doc = "The response to the 'Solid3dGetAllEdgeFaces' endpoint"]
    #[serde(rename = "solid3d_get_all_edge_faces")]
    Solid3DGetAllEdgeFaces {
        #[doc = "The response from the `Solid3dGetAllEdgeFaces` command."]
        data: Solid3DGetAllEdgeFaces,
    },
    #[doc = "The response to the 'Solid3dGetAllOppositeEdges' endpoint"]
    #[serde(rename = "solid3d_get_all_opposite_edges")]
    Solid3DGetAllOppositeEdges {
        #[doc = "The response from the `Solid3dGetAllOppositeEdges` command."]
        data: Solid3DGetAllOppositeEdges,
    },
    #[doc = "The response to the 'Solid3dGetOppositeEdge' endpoint"]
    #[serde(rename = "solid3d_get_opposite_edge")]
    Solid3DGetOppositeEdge {
        #[doc = "The response from the `Solid3dGetOppositeEdge` command."]
        data: Solid3DGetOppositeEdge,
    },
    #[doc = "The response to the 'Solid3dGetNextAdjacentEdge' endpoint"]
    #[serde(rename = "solid3d_get_next_adjacent_edge")]
    Solid3DGetNextAdjacentEdge {
        #[doc = "The response from the `Solid3dGetNextAdjacentEdge` command."]
        data: Solid3DGetNextAdjacentEdge,
    },
    #[doc = "The response to the 'Solid3dGetPrevAdjacentEdge' endpoint"]
    #[serde(rename = "solid3d_get_prev_adjacent_edge")]
    Solid3DGetPrevAdjacentEdge {
        #[doc = "The response from the `Solid3dGetPrevAdjacentEdge` command."]
        data: Solid3DGetPrevAdjacentEdge,
    },
    #[doc = "The response to the 'GetEntityType' endpoint"]
    #[serde(rename = "get_entity_type")]
    GetEntityType {
        #[doc = "The response from the `GetEntityType` command."]
        data: GetEntityType,
    },
    #[doc = "The response to the 'CurveGetControlPoints' endpoint"]
    #[serde(rename = "curve_get_control_points")]
    CurveGetControlPoints {
        #[doc = "The response from the `CurveGetControlPoints` command."]
        data: CurveGetControlPoints,
    },
    #[doc = "The response to the 'CurveGetType' endpoint"]
    #[serde(rename = "curve_get_type")]
    CurveGetType {
        #[doc = "The response from the `CurveGetType` command."]
        data: CurveGetType,
    },
    #[doc = "The response to the 'MouseClick' endpoint"]
    #[serde(rename = "mouse_click")]
    MouseClick {
        #[doc = "The response from the `MouseClick` command."]
        data: MouseClick,
    },
    #[doc = "The response to the 'TakeSnapshot' endpoint"]
    #[serde(rename = "take_snapshot")]
    TakeSnapshot {
        #[doc = "The response from the `TakeSnapshot` command."]
        data: TakeSnapshot,
    },
    #[doc = "The response to the 'PathGetInfo' endpoint"]
    #[serde(rename = "path_get_info")]
    PathGetInfo {
        #[doc = "The response from the `PathGetInfo` command."]
        data: PathGetInfo,
    },
    #[doc = "The response to the 'PathSegmentInfo' endpoint"]
    #[serde(rename = "path_segment_info")]
    PathSegmentInfo {
        #[doc = "Info about a path segment"]
        data: PathSegmentInfo,
    },
    #[doc = "The response to the 'PathGetCurveUuidsForVertices' endpoint"]
    #[serde(rename = "path_get_curve_uuids_for_vertices")]
    PathGetCurveUuidsForVertices {
        #[doc = "The response from the `PathGetCurveUuidsForVertices` command."]
        data: PathGetCurveUuidsForVertices,
    },
    #[doc = "The response to the 'PathGetVertexUuids' endpoint"]
    #[serde(rename = "path_get_vertex_uuids")]
    PathGetVertexUuids {
        #[doc = "The response from the `PathGetVertexUuids` command."]
        data: PathGetVertexUuids,
    },
    #[doc = "The response to the 'CurveGetEndPoints' endpoint"]
    #[serde(rename = "curve_get_end_points")]
    CurveGetEndPoints {
        #[doc = "Endpoints of a curve"]
        data: CurveGetEndPoints,
    },
    #[doc = "The response to the 'FaceIsPlanar' endpoint"]
    #[serde(rename = "face_is_planar")]
    FaceIsPlanar {
        #[doc = "Surface-local planar axes (if available)"]
        data: FaceIsPlanar,
    },
    #[doc = "The response to the 'FaceGetPosition' endpoint"]
    #[serde(rename = "face_get_position")]
    FaceGetPosition {
        #[doc = "The 3D position on the surface that was evaluated"]
        data: FaceGetPosition,
    },
    #[doc = "The response to the 'FaceGetGradient' endpoint"]
    #[serde(rename = "face_get_gradient")]
    FaceGetGradient {
        #[doc = "The gradient (dFdu, dFdv) + normal vector on a brep face"]
        data: FaceGetGradient,
    },
    #[doc = "The response to the 'PlaneIntersectAndProject' endpoint"]
    #[serde(rename = "plane_intersect_and_project")]
    PlaneIntersectAndProject {
        #[doc = "Corresponding coordinates of given window coordinates, intersected on given plane."]
        data: PlaneIntersectAndProject,
    },
    #[doc = "The response to the 'ImportFiles' endpoint"]
    #[serde(rename = "import_files")]
    ImportFiles {
        #[doc = "Data from importing the files"]
        data: ImportFiles,
    },
    #[doc = "The response to the 'ImportedGeometry' endpoint"]
    #[serde(rename = "imported_geometry")]
    ImportedGeometry {
        #[doc = "Data from importing the files"]
        data: ImportedGeometry,
    },
    #[doc = "The response to the 'Mass' endpoint"]
    #[serde(rename = "mass")]
    Mass {
        #[doc = "The mass response."]
        data: Mass,
    },
    #[doc = "The response to the 'Volume' endpoint"]
    #[serde(rename = "volume")]
    Volume {
        #[doc = "The volume response."]
        data: Volume,
    },
    #[doc = "The response to the 'Density' endpoint"]
    #[serde(rename = "density")]
    Density {
        #[doc = "The density response."]
        data: Density,
    },
    #[doc = "The response to the 'SurfaceArea' endpoint"]
    #[serde(rename = "surface_area")]
    SurfaceArea {
        #[doc = "The surface area response."]
        data: SurfaceArea,
    },
    #[doc = "The response to the 'CenterOfMass' endpoint"]
    #[serde(rename = "center_of_mass")]
    CenterOfMass {
        #[doc = "The center of mass response."]
        data: CenterOfMass,
    },
    #[doc = "The response to the 'GetSketchModePlane' endpoint"]
    #[serde(rename = "get_sketch_mode_plane")]
    GetSketchModePlane {
        #[doc = "The plane for sketch mode."]
        data: GetSketchModePlane,
    },
    #[doc = "The response to the 'EntityGetDistance' endpoint"]
    #[serde(rename = "entity_get_distance")]
    EntityGetDistance {
        #[doc = "The response from the `EntitiesGetDistance` command."]
        data: EntityGetDistance,
    },
    #[doc = "The response to the 'EntityLinearPattern' endpoint"]
    #[serde(rename = "entity_linear_pattern")]
    EntityLinearPattern {
        #[doc = "The response from the `EntityLinearPattern` command."]
        data: EntityLinearPattern,
    },
    #[doc = "The response to the 'EntityCircularPattern' endpoint"]
    #[serde(rename = "entity_circular_pattern")]
    EntityCircularPattern {
        #[doc = "The response from the `EntityCircularPattern` command."]
        data: EntityCircularPattern,
    },
    #[doc = "The response to the 'Solid3dGetExtrusionFaceInfo' endpoint"]
    #[serde(rename = "solid3d_get_extrusion_face_info")]
    Solid3DGetExtrusionFaceInfo {
        #[doc = "Extrusion face info struct (useful for maintaining mappings between source path segment ids and extrusion faces)"]
        data: Solid3DGetExtrusionFaceInfo,
    },
    #[doc = "The response to the 'ExtrusionFaceInfo' endpoint"]
    #[serde(rename = "extrusion_face_info")]
    ExtrusionFaceInfo {
        #[doc = "Extrusion face info struct (useful for maintaining mappings between source path segment ids and extrusion faces)"]
        data: ExtrusionFaceInfo,
    },
}

#[doc = "The websocket messages this server sends."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type", content = "data")]
pub enum OkWebSocketResponseData {
    #[doc = "Information about the ICE servers."]
    #[serde(rename = "ice_server_info")]
    IceServerInfo {
        #[doc = "Information about the ICE servers."]
        ice_servers: Vec<IceServer>,
    },
    #[doc = "The trickle ICE candidate response."]
    #[serde(rename = "trickle_ice")]
    TrickleIce {
        #[doc = "Information about the ICE candidate."]
        candidate: RtcIceCandidateInit,
    },
    #[doc = "The SDP answer response."]
    #[serde(rename = "sdp_answer")]
    SdpAnswer {
        #[doc = "The session description."]
        answer: RtcSessionDescription,
    },
    #[doc = "The modeling command response."]
    #[serde(rename = "modeling")]
    Modeling {
        #[doc = "The result of the command."]
        modeling_response: OkModelingCmdResponse,
    },
    #[doc = "The exported files."]
    #[serde(rename = "export")]
    Export {
        #[doc = "The exported files"]
        files: Vec<RawFile>,
    },
    #[doc = "Request a collection of metrics, to include WebRTC."]
    #[serde(rename = "metrics_request")]
    MetricsRequest {},
    #[doc = "Pong response to a Ping message."]
    #[serde(rename = "pong")]
    Pong {},
}

#[doc = "Onboarding details"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Onboarding {
    #[doc = "When the user first used the modeling app."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_call_from_modeling_app_date: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "When the user first used text-to-CAD."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_call_from_text_to_cad_date: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "When the user created their first token."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_token_date: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for Onboarding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Onboarding {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(first_call_from_modeling_app_date) = &self.first_call_from_modeling_app_date
            {
                format!("{:?}", first_call_from_modeling_app_date).into()
            } else {
                String::new().into()
            },
            if let Some(first_call_from_text_to_cad_date) = &self.first_call_from_text_to_cad_date {
                format!("{:?}", first_call_from_text_to_cad_date).into()
            } else {
                String::new().into()
            },
            if let Some(first_token_date) = &self.first_token_date {
                format!("{:?}", first_token_date).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "first_call_from_modeling_app_date".into(),
            "first_call_from_text_to_cad_date".into(),
            "first_token_date".into(),
        ]
    }
}

#[doc = "An organization."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Org {
    #[doc = "If we should allow all future users who are created with email addresses from this domain to join the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_users_in_domain_to_auto_join: Option<bool>,
    #[doc = "The billing email address of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub billing_email: Option<String>,
    #[doc = "The date and time the billing email address was verified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub billing_email_verified: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "If the org should be blocked and the reason why."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block: Option<BlockReason>,
    #[doc = "If we can train on the orgs's data. This value overrides any individual user's `can_train_on_data` value if they are a member of the org."]
    #[serde(default)]
    pub can_train_on_data: bool,
    #[doc = "The date and time the org was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The org's domain."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    #[doc = "The unique identifier for the org."]
    pub id: uuid::Uuid,
    #[doc = "The image for the org. This is a URL."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[doc = "The name of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The org's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
    #[doc = "The org's stripe id."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stripe_id: Option<String>,
    #[doc = "The date and time the org was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Org {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Org {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(allow_users_in_domain_to_auto_join) =
                &self.allow_users_in_domain_to_auto_join
            {
                format!("{:?}", allow_users_in_domain_to_auto_join).into()
            } else {
                String::new().into()
            },
            if let Some(billing_email) = &self.billing_email {
                format!("{:?}", billing_email).into()
            } else {
                String::new().into()
            },
            if let Some(billing_email_verified) = &self.billing_email_verified {
                format!("{:?}", billing_email_verified).into()
            } else {
                String::new().into()
            },
            if let Some(block) = &self.block {
                format!("{:?}", block).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.can_train_on_data).into(),
            format!("{:?}", self.created_at).into(),
            if let Some(domain) = &self.domain {
                format!("{:?}", domain).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(image) = &self.image {
                format!("{:?}", image).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
            if let Some(stripe_id) = &self.stripe_id {
                format!("{:?}", stripe_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "allow_users_in_domain_to_auto_join".into(),
            "billing_email".into(),
            "billing_email_verified".into(),
            "block".into(),
            "can_train_on_data".into(),
            "created_at".into(),
            "domain".into(),
            "id".into(),
            "image".into(),
            "name".into(),
            "phone".into(),
            "stripe_id".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "The user-modifiable parts of an organization."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgDetails {
    #[doc = "If we should allow all future users who are created with email addresses from this domain to join the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_users_in_domain_to_auto_join: Option<bool>,
    #[doc = "The billing email address of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub billing_email: Option<String>,
    #[doc = "The org's domain."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    #[doc = "The image for the org. This is a URL."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[doc = "The name of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The org's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
}

impl std::fmt::Display for OrgDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrgDetails {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(allow_users_in_domain_to_auto_join) =
                &self.allow_users_in_domain_to_auto_join
            {
                format!("{:?}", allow_users_in_domain_to_auto_join).into()
            } else {
                String::new().into()
            },
            if let Some(billing_email) = &self.billing_email {
                format!("{:?}", billing_email).into()
            } else {
                String::new().into()
            },
            if let Some(domain) = &self.domain {
                format!("{:?}", domain).into()
            } else {
                String::new().into()
            },
            if let Some(image) = &self.image {
                format!("{:?}", image).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "allow_users_in_domain_to_auto_join".into(),
            "billing_email".into(),
            "domain".into(),
            "image".into(),
            "name".into(),
            "phone".into(),
        ]
    }
}

#[doc = "A member of an organization."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgMember {
    #[doc = "The user's company."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[doc = "The date and time the user was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user's Discord handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord: Option<String>,
    #[doc = "The email address of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = "The date and time the email address was verified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email_verified: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The user's first name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[doc = "The user's GitHub handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub github: Option<String>,
    #[doc = "The unique identifier for the user."]
    pub id: uuid::Uuid,
    #[doc = "The image avatar for the user. This is a URL."]
    pub image: String,
    #[doc = "The user's last name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    #[doc = "The name of the user. This is auto populated at first from the authentication provider (if there was a name). It can be updated by the user by updating their `first_name` and `last_name` fields."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The user's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
    #[doc = "The user's role in the org."]
    pub role: OrgRole,
    #[doc = "The date and time the user was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for OrgMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrgMember {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(company) = &self.company {
                format!("{:?}", company).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(discord) = &self.discord {
                format!("{:?}", discord).into()
            } else {
                String::new().into()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email).into()
            } else {
                String::new().into()
            },
            if let Some(email_verified) = &self.email_verified {
                format!("{:?}", email_verified).into()
            } else {
                String::new().into()
            },
            if let Some(first_name) = &self.first_name {
                format!("{:?}", first_name).into()
            } else {
                String::new().into()
            },
            if let Some(github) = &self.github {
                format!("{:?}", github).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            self.image.clone().into(),
            if let Some(last_name) = &self.last_name {
                format!("{:?}", last_name).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
            format!("{:?}", self.role).into(),
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "company".into(),
            "created_at".into(),
            "discord".into(),
            "email".into(),
            "email_verified".into(),
            "first_name".into(),
            "github".into(),
            "id".into(),
            "image".into(),
            "last_name".into(),
            "name".into(),
            "phone".into(),
            "role".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgMemberResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<OrgMember>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for OrgMemberResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for OrgMemberResultsPage {
    type Item = OrgMember;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrgMemberResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Org>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for OrgResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for OrgResultsPage {
    type Item = Org;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrgResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "The roles in an organization."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum OrgRole {
    #[doc = "Admins can do anything in the org."]
    #[serde(rename = "admin")]
    #[display("admin")]
    Admin,
    #[doc = "Members of an org can not modify an org, but they belong in the org."]
    #[serde(rename = "member")]
    #[display("member")]
    Member,
    #[doc = "A service account role."]
    #[serde(rename = "service_account")]
    #[display("service_account")]
    ServiceAccount,
}

#[doc = "Output file contents.\n\n<details><summary>JSON schema</summary>\n\n```json { \"description\": \"Output file contents.\", \"type\": \"object\", \"properties\": { \"contents\": { \"description\": \"The contents of the file. This is base64 encoded so we can ensure it is UTF-8 for JSON.\", \"type\": \"string\" }, \"name\": { \"description\": \"The name of the file.\", \"default\": \"\", \"type\": \"string\" } } } ``` </details>"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OutputFile {
    #[doc = "The contents of the file. This is base64 encoded so we can ensure it is UTF-8 for JSON."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<String>,
    #[doc = "The name of the file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for OutputFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OutputFile {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(contents) = &self.contents {
                format!("{:?}", contents).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["contents".into(), "name".into()]
    }
}

#[doc = "Output format specifier."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum OutputFormat {
    #[doc = "Autodesk Filmbox (FBX) format."]
    #[serde(rename = "fbx")]
    Fbx {
        #[doc = "Specifies which kind of FBX will be exported."]
        storage: FbxStorage,
    },
    #[doc = "glTF 2.0. We refer to this as glTF since that is how our customers refer to it, although by default it will be in binary format and thus technically (glb). If you prefer ASCII output, you can set that option for the export."]
    #[serde(rename = "gltf")]
    Gltf {
        #[doc = "Specifies how the JSON will be presented."]
        presentation: GltfPresentation,
        #[doc = "Specifies which kind of glTF 2.0 will be exported."]
        storage: GltfStorage,
    },
    #[doc = "Wavefront OBJ format."]
    #[serde(rename = "obj")]
    Obj {
        #[doc = "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "Export length unit.\n\nDefaults to meters."]
        units: UnitLength,
    },
    #[doc = "The PLY Polygon File Format."]
    #[serde(rename = "ply")]
    Ply {
        #[doc = "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "Export selection."]
        selection: Selection,
        #[doc = "The storage for the output PLY file."]
        storage: PlyStorage,
        #[doc = "Export length unit.\n\nDefaults to meters."]
        units: UnitLength,
    },
    #[doc = "ISO 10303-21 (STEP) format."]
    #[serde(rename = "step")]
    Step {
        #[doc = "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
    },
    #[doc = "*ST**ereo**L**ithography format."]
    #[serde(rename = "stl")]
    Stl {
        #[doc = "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "Export selection."]
        selection: Selection,
        #[doc = "Export storage."]
        storage: StlStorage,
        #[doc = "Export length unit.\n\nDefaults to meters."]
        units: UnitLength,
    },
}

#[doc = "The path component command type (within a Path)"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PathCommand {
    #[serde(rename = "move_to")]
    #[display("move_to")]
    MoveTo,
    #[serde(rename = "line_to")]
    #[display("line_to")]
    LineTo,
    #[serde(rename = "bez_curve_to")]
    #[display("bez_curve_to")]
    BezCurveTo,
    #[serde(rename = "nurbs_curve_to")]
    #[display("nurbs_curve_to")]
    NurbsCurveTo,
    #[serde(rename = "add_arc")]
    #[display("add_arc")]
    AddArc,
}

#[doc = "The path component constraint bounds type"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PathComponentConstraintBound {
    #[serde(rename = "unconstrained")]
    #[display("unconstrained")]
    Unconstrained,
    #[serde(rename = "partially_constrained")]
    #[display("partially_constrained")]
    PartiallyConstrained,
    #[serde(rename = "fully_constrained")]
    #[display("fully_constrained")]
    FullyConstrained,
}

#[doc = "The path component constraint type"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PathComponentConstraintType {
    #[serde(rename = "unconstrained")]
    #[display("unconstrained")]
    Unconstrained,
    #[serde(rename = "vertical")]
    #[display("vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    #[display("horizontal")]
    Horizontal,
    #[serde(rename = "equal_length")]
    #[display("equal_length")]
    EqualLength,
    #[serde(rename = "parallel")]
    #[display("parallel")]
    Parallel,
    #[serde(rename = "angle_between")]
    #[display("angle_between")]
    AngleBetween,
}

#[doc = "The response from the `PathGetCurveUuidsForVertices` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PathGetCurveUuidsForVertices {
    #[doc = "The UUIDs of the curve entities."]
    pub curve_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for PathGetCurveUuidsForVertices {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PathGetCurveUuidsForVertices {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.curve_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["curve_ids".into()]
    }
}

#[doc = "The response from the `PathGetInfo` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PathGetInfo {
    #[doc = "All segments in the path, in the order they were added."]
    pub segments: Vec<PathSegmentInfo>,
}

impl std::fmt::Display for PathGetInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PathGetInfo {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.segments).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["segments".into()]
    }
}

#[doc = "The response from the `PathGetVertexUuids` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PathGetVertexUuids {
    #[doc = "The UUIDs of the vertex entities."]
    pub vertex_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for PathGetVertexUuids {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PathGetVertexUuids {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.vertex_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["vertex_ids".into()]
    }
}

#[doc = "A segment of a path. Paths are composed of many segments."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum PathSegment {
    #[doc = "A straight line segment. Goes from the current path \"pen\" to the given endpoint."]
    #[serde(rename = "line")]
    Line {
        #[doc = "End point of the line."]
        end: Point3D,
        #[doc = "Whether or not this line is a relative offset"]
        relative: bool,
    },
    #[doc = "A circular arc segment."]
    #[serde(rename = "arc")]
    Arc {
        #[doc = "Center of the circle"]
        center: Point2D,
        #[doc = "End of the arc along circle's perimeter."]
        end: Angle,
        #[doc = "Radius of the circle"]
        radius: f64,
        #[doc = "Whether or not this arc is a relative offset"]
        relative: bool,
        #[doc = "Start of the arc along circle's perimeter."]
        start: Angle,
    },
    #[doc = "A cubic bezier curve segment. Start at the end of the current line, go through control point 1 and 2, then end at a given point."]
    #[serde(rename = "bezier")]
    Bezier {
        #[doc = "First control point."]
        control1: Point3D,
        #[doc = "Second control point."]
        control2: Point3D,
        #[doc = "Final control point."]
        end: Point3D,
        #[doc = "Whether or not this bezier is a relative offset"]
        relative: bool,
    },
    #[doc = "Adds a tangent arc from current pen position with the given radius and angle."]
    #[serde(rename = "tangential_arc")]
    TangentialArc {
        #[doc = "Offset of the arc."]
        offset: Angle,
        #[doc = "Radius of the arc. Not to be confused with Raiders of the Lost Ark."]
        radius: f64,
    },
    #[doc = "Adds a tangent arc from current pen position to the new position."]
    #[serde(rename = "tangential_arc_to")]
    TangentialArcTo {
        #[doc = "0 will be interpreted as none/null."]
        angle_snap_increment: Option<Angle>,
        #[doc = "Where the arc should end. Must lie in the same plane as the current path pen position. Must not be colinear with current path pen position."]
        to: Point3D,
    },
}

#[doc = "Info about a path segment"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PathSegmentInfo {
    #[doc = "What is the path segment?"]
    pub command: PathCommand,
    #[doc = "Which command created this path? This field is absent if the path command is not actually creating a path segment, e.g. moving the pen doesn't create a path segment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command_id: Option<uuid::Uuid>,
    #[doc = "Whether or not this segment is a relative offset"]
    pub relative: bool,
}

impl std::fmt::Display for PathSegmentInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PathSegmentInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.command).into(),
            if let Some(command_id) = &self.command_id {
                format!("{:?}", command_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.relative).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["command".into(), "command_id".into(), "relative".into()]
    }
}

#[doc = "A payment intent response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PaymentIntent {
    #[doc = "The client secret is used for client-side retrieval using a publishable key. The client secret can be used to complete payment setup from your frontend. It should not be stored, logged, or exposed to anyone other than the customer. Make sure that you have TLS enabled on any page that includes the client secret."]
    pub client_secret: String,
}

impl std::fmt::Display for PaymentIntent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PaymentIntent {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.client_secret.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["client_secret".into()]
    }
}

#[doc = "A payment method."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PaymentMethod {
    #[doc = "The billing info for the payment method."]
    pub billing_info: BillingInfo,
    #[doc = "The card, if it is one. For our purposes, this is the only type of payment method that we support."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub card: Option<CardDetails>,
    #[doc = "Time at which the object was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Unique identifier for the object."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Set of key-value pairs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
    #[doc = "The type of payment method."]
    #[serde(rename = "type")]
    pub type_: PaymentMethodType,
}

impl std::fmt::Display for PaymentMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PaymentMethod {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.billing_info).into(),
            if let Some(card) = &self.card {
                format!("{:?}", card).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.type_).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "billing_info".into(),
            "card".into(),
            "created_at".into(),
            "id".into(),
            "metadata".into(),
            "type_".into(),
        ]
    }
}

#[doc = "Card checks."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PaymentMethodCardChecks {
    #[doc = "If a address line1 was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`."]
    #[serde(
        rename = "address_line1_check",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub address_line_1_check: Option<String>,
    #[doc = "If a address postal code was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_postal_code_check: Option<String>,
    #[doc = "If a CVC was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cvc_check: Option<String>,
}

impl std::fmt::Display for PaymentMethodCardChecks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PaymentMethodCardChecks {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(address_line_1_check) = &self.address_line_1_check {
                format!("{:?}", address_line_1_check).into()
            } else {
                String::new().into()
            },
            if let Some(address_postal_code_check) = &self.address_postal_code_check {
                format!("{:?}", address_postal_code_check).into()
            } else {
                String::new().into()
            },
            if let Some(cvc_check) = &self.cvc_check {
                format!("{:?}", cvc_check).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "address_line_1_check".into(),
            "address_postal_code_check".into(),
            "cvc_check".into(),
        ]
    }
}

#[doc = "An enum representing the possible values of an `PaymentMethod`'s `type` field."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PaymentMethodType {
    #[doc = "A card payment method."]
    #[serde(rename = "card")]
    #[display("card")]
    Card,
}

impl std::default::Default for PaymentMethodType {
    fn default() -> Self {
        PaymentMethodType::Card
    }
}

#[doc = "Defines a perspective view."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PerspectiveCameraParameters {
    #[doc = "Camera frustum vertical field of view."]
    pub fov_y: f64,
    #[doc = "Camera frustum far plane."]
    pub z_far: f64,
    #[doc = "Camera frustum near plane."]
    pub z_near: f64,
}

impl std::fmt::Display for PerspectiveCameraParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PerspectiveCameraParameters {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.fov_y).into(),
            format!("{:?}", self.z_far).into(),
            format!("{:?}", self.z_near).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["fov_y".into(), "z_far".into(), "z_near".into()]
    }
}

#[doc = "A plan's interval."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PlanInterval {
    #[doc = "Day."]
    #[serde(rename = "day")]
    #[display("day")]
    Day,
    #[doc = "Month."]
    #[serde(rename = "month")]
    #[display("month")]
    Month,
    #[doc = "Week."]
    #[serde(rename = "week")]
    #[display("week")]
    Week,
    #[doc = "Year."]
    #[serde(rename = "year")]
    #[display("year")]
    Year,
}

#[doc = "Corresponding coordinates of given window coordinates, intersected on given plane."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PlaneIntersectAndProject {
    #[doc = "Corresponding coordinates of given window coordinates, intersected on given plane."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plane_coordinates: Option<Point2D>,
}

impl std::fmt::Display for PlaneIntersectAndProject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PlaneIntersectAndProject {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(plane_coordinates) = &self.plane_coordinates {
            format!("{:?}", plane_coordinates).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["plane_coordinates".into()]
    }
}

#[doc = "The storage for the output PLY file."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PlyStorage {
    #[doc = "Write numbers in their ascii representation (e.g. -13, 6.28, etc.). Properties are separated by spaces and elements are separated by line breaks."]
    #[serde(rename = "ascii")]
    #[display("ascii")]
    Ascii,
    #[doc = "Encode payload as binary using little endian."]
    #[serde(rename = "binary_little_endian")]
    #[display("binary_little_endian")]
    BinaryLittleEndian,
    #[doc = "Encode payload as binary using big endian."]
    #[serde(rename = "binary_big_endian")]
    #[display("binary_big_endian")]
    BinaryBigEndian,
}

#[doc = "A point in 2D space"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Point2D {
    pub x: f64,
    pub y: f64,
}

impl std::fmt::Display for Point2D {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Point2D {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.x).into(),
            format!("{:?}", self.y).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["x".into(), "y".into()]
    }
}

#[doc = "A point in 3D space"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Point3D {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

impl std::fmt::Display for Point3D {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Point3D {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.x).into(),
            format!("{:?}", self.y).into(),
            format!("{:?}", self.z).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["x".into(), "y".into(), "z".into()]
    }
}

#[doc = "The response from the `/ping` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Pong {
    #[doc = "The pong response."]
    pub message: String,
}

impl std::fmt::Display for Pong {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Pong {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.message.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["message".into()]
    }
}

#[doc = "Post effect type"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PostEffectType {
    #[serde(rename = "phosphor")]
    #[display("phosphor")]
    Phosphor,
    #[serde(rename = "ssao")]
    #[display("ssao")]
    Ssao,
    #[serde(rename = "noeffect")]
    #[display("noeffect")]
    Noeffect,
}

#[doc = "Privacy settings for an org or user."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PrivacySettings {
    #[doc = "If we can train on the data. If the user is a member of an organization, the organization's setting will override this. The organization's setting takes priority."]
    pub can_train_on_data: bool,
}

impl std::fmt::Display for PrivacySettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PrivacySettings {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.can_train_on_data).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["can_train_on_data".into()]
    }
}

#[doc = "A raw file with unencoded contents to be passed over binary websockets. When raw files come back for exports it is sent as binary/bson, not text/json."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RawFile {
    #[doc = "The contents of the file."]
    #[serde(
        serialize_with = "serde_bytes::serialize",
        deserialize_with = "serde_bytes::deserialize"
    )]
    pub contents: Vec<u8>,
    #[doc = "The name of the file."]
    pub name: String,
}

impl std::fmt::Display for RawFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RawFile {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.contents).into(),
            self.name.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["contents".into(), "name".into()]
    }
}

#[doc = "ICECandidateInit is used to serialize ice candidates"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RtcIceCandidateInit {
    #[doc = "The candidate string associated with the object."]
    pub candidate: String,
    #[doc = "The index (starting at zero) of the m-line in the SDP this candidate is associated with."]
    #[serde(
        rename = "sdpMLineIndex",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sdp_m_line_index: Option<u16>,
    #[doc = "The identifier of the \"media stream identification\" as defined in [RFC 8841](https://tools.ietf.org/html/rfc8841)."]
    #[serde(rename = "sdpMid", default, skip_serializing_if = "Option::is_none")]
    pub sdp_mid: Option<String>,
    #[doc = "The username fragment (as defined in [RFC 8445](https://tools.ietf.org/html/rfc8445#section-5.2.1)) associated with the object."]
    #[serde(
        rename = "usernameFragment",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub username_fragment: Option<String>,
}

impl std::fmt::Display for RtcIceCandidateInit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RtcIceCandidateInit {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.candidate.clone().into(),
            if let Some(sdp_m_line_index) = &self.sdp_m_line_index {
                format!("{:?}", sdp_m_line_index).into()
            } else {
                String::new().into()
            },
            if let Some(sdp_mid) = &self.sdp_mid {
                format!("{:?}", sdp_mid).into()
            } else {
                String::new().into()
            },
            if let Some(username_fragment) = &self.username_fragment {
                format!("{:?}", username_fragment).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "candidate".into(),
            "sdp_m_line_index".into(),
            "sdp_mid".into(),
            "username_fragment".into(),
        ]
    }
}

#[doc = "SDPType describes the type of an SessionDescription."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum RtcSdpType {
    #[doc = "Unspecified indicates that the type is unspecified."]
    #[serde(rename = "unspecified")]
    #[display("unspecified")]
    Unspecified,
    #[doc = "indicates that a description MUST be treated as an SDP offer."]
    #[serde(rename = "offer")]
    #[display("offer")]
    Offer,
    #[doc = "indicates that a description MUST be treated as an SDP answer, but not a final answer. A description used as an SDP pranswer may be applied as a response to an SDP offer, or an update to a previously sent SDP pranswer."]
    #[serde(rename = "pranswer")]
    #[display("pranswer")]
    Pranswer,
    #[doc = "indicates that a description MUST be treated as an SDP final answer, and the offer-answer exchange MUST be considered complete. A description used as an SDP answer may be applied as a response to an SDP offer or as an update to a previously sent SDP pranswer."]
    #[serde(rename = "answer")]
    #[display("answer")]
    Answer,
    #[doc = "indicates that a description MUST be treated as canceling the current SDP negotiation and moving the SDP offer and answer back to what it was in the previous stable state. Note the local or remote SDP descriptions in the previous stable state could be null if there has not yet been a successful offer-answer negotiation."]
    #[serde(rename = "rollback")]
    #[display("rollback")]
    Rollback,
}

#[doc = "SessionDescription is used to expose local and remote session descriptions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RtcSessionDescription {
    #[doc = "SDP string."]
    pub sdp: String,
    #[doc = "SDP type."]
    #[serde(rename = "type")]
    pub type_: RtcSdpType,
}

impl std::fmt::Display for RtcSessionDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RtcSessionDescription {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.sdp.clone().into(), format!("{:?}", self.type_).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["sdp".into(), "type_".into()]
    }
}

#[doc = "A SAML identity provider."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SamlIdentityProvider {
    #[doc = "The ACS (Assertion Consumer Service) url."]
    pub acs_url: String,
    #[doc = "The date and time the SAML identity provider was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The unique identifier for the SAML identity provider."]
    pub id: uuid::Uuid,
    #[doc = "The entity ID of the SAML identity provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub idp_entity_id: Option<String>,
    #[doc = "The metadata document as a string."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub idp_metadata_document_string: Option<String>,
    #[doc = "The organization ID the SAML identity provider belongs to."]
    pub org_id: uuid::Uuid,
    #[doc = "The private key for the SAML identity provider. This is the PEM corresponding to the X509 pair."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private_key: Option<base64::Base64Data>,
    #[doc = "The public certificate for the SAML identity provider. This is the PEM corresponding to the X509 pair."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_cert: Option<base64::Base64Data>,
    #[doc = "The SLO (Single Logout) url."]
    pub slo_url: String,
    #[doc = "The technical contact email address for the SAML identity provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub technical_contact_email: Option<String>,
    #[doc = "The date and time the SAML identity provider was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for SamlIdentityProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SamlIdentityProvider {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.acs_url.clone().into(),
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.id).into(),
            if let Some(idp_entity_id) = &self.idp_entity_id {
                format!("{:?}", idp_entity_id).into()
            } else {
                String::new().into()
            },
            if let Some(idp_metadata_document_string) = &self.idp_metadata_document_string {
                format!("{:?}", idp_metadata_document_string).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.org_id).into(),
            if let Some(private_key) = &self.private_key {
                format!("{:?}", private_key).into()
            } else {
                String::new().into()
            },
            if let Some(public_cert) = &self.public_cert {
                format!("{:?}", public_cert).into()
            } else {
                String::new().into()
            },
            self.slo_url.clone().into(),
            if let Some(technical_contact_email) = &self.technical_contact_email {
                format!("{:?}", technical_contact_email).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "acs_url".into(),
            "created_at".into(),
            "id".into(),
            "idp_entity_id".into(),
            "idp_metadata_document_string".into(),
            "org_id".into(),
            "private_key".into(),
            "public_cert".into(),
            "slo_url".into(),
            "technical_contact_email".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "Parameters for creating a SAML identity provider."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SamlIdentityProviderCreate {
    #[doc = "The entity ID of the SAML identity provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub idp_entity_id: Option<String>,
    #[doc = "The source of an identity provider metadata descriptor."]
    pub idp_metadata_source: IdpMetadataSource,
    #[doc = "The request signing key pair."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signing_keypair: Option<DerEncodedKeyPair>,
    #[doc = "The technical contact email address for the SAML identity provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub technical_contact_email: Option<String>,
}

impl std::fmt::Display for SamlIdentityProviderCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SamlIdentityProviderCreate {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(idp_entity_id) = &self.idp_entity_id {
                format!("{:?}", idp_entity_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.idp_metadata_source).into(),
            if let Some(signing_keypair) = &self.signing_keypair {
                format!("{:?}", signing_keypair).into()
            } else {
                String::new().into()
            },
            if let Some(technical_contact_email) = &self.technical_contact_email {
                format!("{:?}", technical_contact_email).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "idp_entity_id".into(),
            "idp_metadata_source".into(),
            "signing_keypair".into(),
            "technical_contact_email".into(),
        ]
    }
}

#[doc = "The type of scene selection change"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum SceneSelectionType {
    #[doc = "Replaces the selection"]
    #[serde(rename = "replace")]
    #[display("replace")]
    Replace,
    #[doc = "Adds to the selection"]
    #[serde(rename = "add")]
    #[display("add")]
    Add,
    #[doc = "Removes from the selection"]
    #[serde(rename = "remove")]
    #[display("remove")]
    Remove,
}

#[doc = "The type of scene's active tool"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum SceneToolType {
    #[serde(rename = "camera_revolve")]
    #[display("camera_revolve")]
    CameraRevolve,
    #[serde(rename = "select")]
    #[display("select")]
    Select,
    #[serde(rename = "move")]
    #[display("move")]
    Move,
    #[serde(rename = "sketch_line")]
    #[display("sketch_line")]
    SketchLine,
    #[serde(rename = "sketch_tangential_arc")]
    #[display("sketch_tangential_arc")]
    SketchTangentialArc,
    #[serde(rename = "sketch_curve")]
    #[display("sketch_curve")]
    SketchCurve,
    #[serde(rename = "sketch_curve_mod")]
    #[display("sketch_curve_mod")]
    SketchCurveMod,
}

#[doc = "The response from the `SelectGet` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SelectGet {
    #[doc = "The UUIDs of the selected entities."]
    pub entity_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for SelectGet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SelectGet {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_ids".into()]
    }
}

#[doc = "The response from the `SelectWithPoint` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SelectWithPoint {
    #[doc = "The UUID of the entity that was selected."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity_id: Option<uuid::Uuid>,
}

impl std::fmt::Display for SelectWithPoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SelectWithPoint {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(entity_id) = &self.entity_id {
            format!("{:?}", entity_id).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_id".into()]
    }
}

#[doc = "Data item selection."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum Selection {
    #[doc = "Visit the default scene."]
    #[serde(rename = "default_scene")]
    DefaultScene {},
    #[doc = "Visit the indexed scene."]
    #[serde(rename = "scene_by_index")]
    SceneByIndex {
        #[doc = "The index."]
        index: u32,
    },
    #[doc = "Visit the first scene with the given name."]
    #[serde(rename = "scene_by_name")]
    SceneByName {
        #[doc = "The name."]
        name: String,
    },
    #[doc = "Visit the indexed mesh."]
    #[serde(rename = "mesh_by_index")]
    MeshByIndex {
        #[doc = "The index."]
        index: u32,
    },
    #[doc = "Visit the first mesh with the given name."]
    #[serde(rename = "mesh_by_name")]
    MeshByName {
        #[doc = "The name."]
        name: String,
    },
}

#[doc = "A service account.\n\nThese are used to authenticate orgs with Bearer authentication.\n\nThis works just like an API token, but it is tied to an organization versus an individual user."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ServiceAccount {
    #[doc = "The date and time the API token was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The unique identifier for the API token."]
    pub id: uuid::Uuid,
    #[doc = "If the token is valid. We never delete API tokens, but we can mark them as invalid. We save them for ever to preserve the history of the API token."]
    pub is_valid: bool,
    #[doc = "An optional label for the API token."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[doc = "The ID of the organization that owns the API token."]
    pub org_id: uuid::Uuid,
    #[doc = "The API token itself."]
    pub token: uuid::Uuid,
    #[doc = "The date and time the API token was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for ServiceAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ServiceAccount {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.is_valid).into(),
            if let Some(label) = &self.label {
                format!("{:?}", label).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.org_id).into(),
            format!("{:?}", self.token).into(),
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "id".into(),
            "is_valid".into(),
            "label".into(),
            "org_id".into(),
            "token".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ServiceAccountResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<ServiceAccount>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ServiceAccountResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ServiceAccountResultsPage {
    type Item = ServiceAccount;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ServiceAccountResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "An authentication session."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Session {
    #[doc = "The date and time the session was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The date and time the session expires."]
    pub expires_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The session token."]
    pub token: uuid::Uuid,
    #[doc = "The date and time the session was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user that the session belongs to."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for Session {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Session {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.expires_at).into(),
            format!("{:?}", self.token).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "expires_at".into(),
            "token".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The response from the `Solid3dGetAllEdgeFaces` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetAllEdgeFaces {
    #[doc = "The UUIDs of the faces."]
    pub faces: Vec<uuid::Uuid>,
}

impl std::fmt::Display for Solid3DGetAllEdgeFaces {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetAllEdgeFaces {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.faces).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["faces".into()]
    }
}

#[doc = "The response from the `Solid3dGetAllOppositeEdges` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetAllOppositeEdges {
    #[doc = "The UUIDs of the edges."]
    pub edges: Vec<uuid::Uuid>,
}

impl std::fmt::Display for Solid3DGetAllOppositeEdges {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetAllOppositeEdges {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.edges).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edges".into()]
    }
}

#[doc = "Extrusion face info struct (useful for maintaining mappings between source path segment ids and extrusion faces)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetExtrusionFaceInfo {
    #[doc = "Details of each face."]
    pub faces: Vec<ExtrusionFaceInfo>,
}

impl std::fmt::Display for Solid3DGetExtrusionFaceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetExtrusionFaceInfo {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.faces).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["faces".into()]
    }
}

#[doc = "The response from the `Solid3dGetNextAdjacentEdge` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetNextAdjacentEdge {
    #[doc = "The UUID of the edge."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub edge: Option<uuid::Uuid>,
}

impl std::fmt::Display for Solid3DGetNextAdjacentEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetNextAdjacentEdge {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(edge) = &self.edge {
            format!("{:?}", edge).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edge".into()]
    }
}

#[doc = "The response from the `Solid3dGetOppositeEdge` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetOppositeEdge {
    #[doc = "The UUID of the edge."]
    pub edge: uuid::Uuid,
}

impl std::fmt::Display for Solid3DGetOppositeEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetOppositeEdge {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.edge).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edge".into()]
    }
}

#[doc = "The response from the `Solid3dGetPrevAdjacentEdge` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetPrevAdjacentEdge {
    #[doc = "The UUID of the edge."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub edge: Option<uuid::Uuid>,
}

impl std::fmt::Display for Solid3DGetPrevAdjacentEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetPrevAdjacentEdge {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(edge) = &self.edge {
            format!("{:?}", edge).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edge".into()]
    }
}

#[doc = "Export storage."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum StlStorage {
    #[doc = "Plaintext encoding."]
    #[serde(rename = "ascii")]
    #[display("ascii")]
    Ascii,
    #[doc = "Binary STL encoding.\n\nThis is the default setting."]
    #[serde(rename = "binary")]
    #[display("binary")]
    Binary,
}

#[doc = "The parameters for a new store coupon."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct StoreCouponParams {
    #[doc = "The percentage off."]
    pub percent_off: u32,
}

impl std::fmt::Display for StoreCouponParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for StoreCouponParams {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.percent_off).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["percent_off".into()]
    }
}

#[doc = "A subscription tier feature."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SubscriptionTierFeature {
    #[doc = "Information about the feature."]
    pub info: String,
}

impl std::fmt::Display for SubscriptionTierFeature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SubscriptionTierFeature {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.info.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["info".into()]
    }
}

#[doc = "The price for a subscription tier."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum SubscriptionTierPrice {
    #[doc = "A flat price that we publicly list."]
    #[serde(rename = "flat")]
    Flat {
        #[doc = "The interval the price is charged."]
        interval: PlanInterval,
        #[doc = "The price."]
        price: f64,
    },
    #[doc = "A per user price that we publicly list."]
    #[serde(rename = "per_user")]
    PerUser {
        #[doc = "The interval the price is charged."]
        interval: PlanInterval,
        #[doc = "The price."]
        price: f64,
    },
    #[doc = "Enterprise: The price is not listed and the user needs to contact sales."]
    #[serde(rename = "enterprise")]
    Enterprise {},
}

#[doc = "An enum representing a subscription tier type."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum SubscriptionTierType {
    #[doc = "A subscription tier that can be applied to individuals only."]
    #[serde(rename = "individual")]
    Individual {},
    #[doc = "An subscription tier that can be applied to organizations only."]
    #[serde(rename = "organization")]
    Organization {
        #[doc = "Whether or not the subscription type supports SAML SSO."]
        saml_sso: bool,
    },
}

#[doc = "An enum representing a subscription training data behavior."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum SubscriptionTrainingDataBehavior {
    #[doc = "The data is always used for training and cannot be turned off."]
    #[serde(rename = "always")]
    #[display("always")]
    Always,
    #[doc = "The data is used for training by default, but can be turned off."]
    #[serde(rename = "default_on")]
    #[display("default_on")]
    DefaultOn,
    #[doc = "The data is not used for training by default, but can be turned on."]
    #[serde(rename = "default_off")]
    #[display("default_off")]
    DefaultOff,
}

#[doc = "Successful Websocket response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SuccessWebSocketResponse {
    #[doc = "Which request this is a response to. If the request was a modeling command, this is the modeling command ID. If no request ID was sent, this will be null."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<uuid::Uuid>,
    #[doc = "The data sent with a successful response. This will be flattened into a 'type' and 'data' field."]
    pub resp: OkWebSocketResponseData,
    #[doc = "Always true"]
    pub success: bool,
}

impl std::fmt::Display for SuccessWebSocketResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SuccessWebSocketResponse {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(request_id) = &self.request_id {
                format!("{:?}", request_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.resp).into(),
            format!("{:?}", self.success).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["request_id".into(), "resp".into(), "success".into()]
    }
}

#[doc = "The support tier the subscription provides."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum SupportTier {
    #[doc = "Community support."]
    #[serde(rename = "community")]
    #[display("community")]
    Community,
    #[doc = "Standard support."]
    #[serde(rename = "standard")]
    #[display("standard")]
    Standard,
    #[doc = "Premium support."]
    #[serde(rename = "premium")]
    #[display("premium")]
    Premium,
    #[doc = "Priority support."]
    #[serde(rename = "priority")]
    #[display("priority")]
    Priority,
}

#[doc = "The surface area response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SurfaceArea {
    #[doc = "The output unit for the surface area."]
    pub output_unit: UnitArea,
    #[doc = "The surface area."]
    pub surface_area: f64,
}

impl std::fmt::Display for SurfaceArea {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SurfaceArea {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.surface_area).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["output_unit".into(), "surface_area".into()]
    }
}

#[doc = "Co-ordinate system definition.\n\nThe `up` axis must be orthogonal to the `forward` axis.\n\nSee [cglearn.eu] for background reading.\n\n[cglearn.eu](https://cglearn.eu/pub/computer-graphics/introduction-to-geometry#material-coordinate-systems-1)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct System {
    #[doc = "Axis the front face of a model looks along."]
    pub forward: AxisDirectionPair,
    #[doc = "Axis pointing up and away from a model."]
    pub up: AxisDirectionPair,
}

impl std::fmt::Display for System {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for System {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.forward).into(),
            format!("{:?}", self.up).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["forward".into(), "up".into()]
    }
}

#[doc = "The response from the `TakeSnapshot` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TakeSnapshot {
    #[doc = "Contents of the image."]
    pub contents: base64::Base64Data,
}

impl std::fmt::Display for TakeSnapshot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TakeSnapshot {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.contents).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["contents".into()]
    }
}

#[doc = "A response from a text to CAD prompt."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCad {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "Feedback from the user, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub feedback: Option<AiFeedback>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The version of the model."]
    pub model_version: String,
    #[doc = "The output format of the model."]
    pub output_format: FileExportFormat,
    #[doc = "The output of the model in the given file format the user requested, base64 encoded. The key of the map is the path of the output file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub outputs: Option<std::collections::HashMap<String, base64::Base64Data>>,
    #[doc = "The prompt."]
    pub prompt: String,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for TextToCad {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCad {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            if let Some(feedback) = &self.feedback {
                format!("{:?}", feedback).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            self.model_version.clone().into(),
            format!("{:?}", self.output_format).into(),
            if let Some(outputs) = &self.outputs {
                format!("{:?}", outputs).into()
            } else {
                String::new().into()
            },
            self.prompt.clone().into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "feedback".into(),
            "id".into(),
            "model_version".into(),
            "output_format".into(),
            "outputs".into(),
            "prompt".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "Body for generating models from text."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCadCreateBody {
    #[doc = "The prompt for the model."]
    pub prompt: String,
}

impl std::fmt::Display for TextToCadCreateBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCadCreateBody {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.prompt.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["prompt".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCadResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<TextToCad>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for TextToCadResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for TextToCadResultsPage {
    type Item = TextToCad;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCadResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "The valid types of angle formats."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitAngle {
    #[doc = "Degrees <https://en.wikipedia.org/wiki/Degree_(angle)>"]
    #[serde(rename = "degrees")]
    #[display("degrees")]
    Degrees,
    #[doc = "Radians <https://en.wikipedia.org/wiki/Radian>"]
    #[serde(rename = "radians")]
    #[display("radians")]
    Radians,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitAngleConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitAngle,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitAngle,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitAngleConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitAngleConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of area units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitArea {
    #[doc = "Square centimeters <https://en.wikipedia.org/wiki/Square_centimeter>"]
    #[serde(rename = "cm2")]
    #[display("cm2")]
    Cm2,
    #[doc = "Square decimeters <https://en.wikipedia.org/wiki/Square_decimeter>"]
    #[serde(rename = "dm2")]
    #[display("dm2")]
    Dm2,
    #[doc = "Square feet <https://en.wikipedia.org/wiki/Square_foot>"]
    #[serde(rename = "ft2")]
    #[display("ft2")]
    Ft2,
    #[doc = "Square inches <https://en.wikipedia.org/wiki/Square_inch>"]
    #[serde(rename = "in2")]
    #[display("in2")]
    In2,
    #[doc = "Square kilometers <https://en.wikipedia.org/wiki/Square_kilometer>"]
    #[serde(rename = "km2")]
    #[display("km2")]
    Km2,
    #[doc = "Square meters <https://en.wikipedia.org/wiki/Square_meter>"]
    #[serde(rename = "m2")]
    #[display("m2")]
    M2,
    #[doc = "Square millimeters <https://en.wikipedia.org/wiki/Square_millimeter>"]
    #[serde(rename = "mm2")]
    #[display("mm2")]
    Mm2,
    #[doc = "Square yards <https://en.wikipedia.org/wiki/Square_mile>"]
    #[serde(rename = "yd2")]
    #[display("yd2")]
    Yd2,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitAreaConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitArea,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitArea,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitAreaConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitAreaConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of current units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitCurrent {
    #[doc = "Amperes <https://en.wikipedia.org/wiki/Ampere>"]
    #[serde(rename = "amperes")]
    #[display("amperes")]
    Amperes,
    #[doc = "Microamperes <https://en.wikipedia.org/wiki/Microampere>"]
    #[serde(rename = "microamperes")]
    #[display("microamperes")]
    Microamperes,
    #[doc = "Milliamperes <https://en.wikipedia.org/wiki/Milliampere>"]
    #[serde(rename = "milliamperes")]
    #[display("milliamperes")]
    Milliamperes,
    #[doc = "Nanoamperes <https://en.wikipedia.org/wiki/Nanoampere>"]
    #[serde(rename = "nanoamperes")]
    #[display("nanoamperes")]
    Nanoamperes,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitCurrentConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitCurrent,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitCurrent,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitCurrentConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitCurrentConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types for density units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitDensity {
    #[doc = "Pounds per cubic feet."]
    #[serde(rename = "lb:ft3")]
    #[display("lb:ft3")]
    LbFt3,
    #[doc = "Kilograms per cubic meter."]
    #[serde(rename = "kg:m3")]
    #[display("kg:m3")]
    KgM3,
}

#[doc = "The valid types of energy units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitEnergy {
    #[doc = "British Thermal Unit (BTU) <https://en.wikipedia.org/wiki/British_thermal_unit>"]
    #[serde(rename = "btu")]
    #[display("btu")]
    Btu,
    #[doc = "Electron Volts (eV) <https://en.wikipedia.org/wiki/Electronvolt>"]
    #[serde(rename = "electronvolts")]
    #[display("electronvolts")]
    Electronvolts,
    #[doc = "Joules (or watt-seconds) <https://en.wikipedia.org/wiki/Joule>"]
    #[serde(rename = "joules")]
    #[display("joules")]
    Joules,
    #[doc = "Kilocalories (often just called calories) <https://en.wikipedia.org/wiki/Kilocalorie>"]
    #[serde(rename = "kilocalories")]
    #[display("kilocalories")]
    Kilocalories,
    #[doc = "Kilowatt hours (kWh) <https://en.wikipedia.org/wiki/Kilowatt-hour>"]
    #[serde(rename = "kilowatt_hours")]
    #[display("kilowatt_hours")]
    KilowattHours,
    #[doc = "Watt hours (Wh) <https://en.wikipedia.org/wiki/Kilowatt-hour>"]
    #[serde(rename = "watt_hours")]
    #[display("watt_hours")]
    WattHours,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitEnergyConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitEnergy,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitEnergy,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitEnergyConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitEnergyConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of force units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitForce {
    #[doc = "Dynes <https://en.wikipedia.org/wiki/Dyne>"]
    #[serde(rename = "dynes")]
    #[display("dynes")]
    Dynes,
    #[doc = "Kiloponds <https://en.wikipedia.org/wiki/Kilopond>"]
    #[serde(rename = "kiloponds")]
    #[display("kiloponds")]
    Kiloponds,
    #[doc = "Micronewtons <https://en.wikipedia.org/wiki/Newton_(unit)>"]
    #[serde(rename = "micronewtons")]
    #[display("micronewtons")]
    Micronewtons,
    #[doc = "Millinewtons <https://en.wikipedia.org/wiki/Newton_(unit)>"]
    #[serde(rename = "millinewtons")]
    #[display("millinewtons")]
    Millinewtons,
    #[doc = "Newtons <https://en.wikipedia.org/wiki/Newton_(unit)>"]
    #[serde(rename = "newtons")]
    #[display("newtons")]
    Newtons,
    #[doc = "Poundals <https://en.wikipedia.org/wiki/Poundal>"]
    #[serde(rename = "poundals")]
    #[display("poundals")]
    Poundals,
    #[doc = "Pounds <https://en.wikipedia.org/wiki/Pound_(force)>"]
    #[serde(rename = "pounds")]
    #[display("pounds")]
    Pounds,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitForceConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitForce,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitForce,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitForceConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitForceConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of frequency units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitFrequency {
    #[doc = "Gigahertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "gigahertz")]
    #[display("gigahertz")]
    Gigahertz,
    #[doc = "Hertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "hertz")]
    #[display("hertz")]
    Hertz,
    #[doc = "Kilohertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "kilohertz")]
    #[display("kilohertz")]
    Kilohertz,
    #[doc = "Megahertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "megahertz")]
    #[display("megahertz")]
    Megahertz,
    #[doc = "Microhertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "microhertz")]
    #[display("microhertz")]
    Microhertz,
    #[doc = "Millihertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "millihertz")]
    #[display("millihertz")]
    Millihertz,
    #[doc = "Nanohertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "nanohertz")]
    #[display("nanohertz")]
    Nanohertz,
    #[doc = "Terahertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "terahertz")]
    #[display("terahertz")]
    Terahertz,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitFrequencyConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitFrequency,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitFrequency,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitFrequencyConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitFrequencyConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of length units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitLength {
    #[doc = "Centimeters <https://en.wikipedia.org/wiki/Centimeter>"]
    #[serde(rename = "cm")]
    #[display("cm")]
    Cm,
    #[doc = "Feet <https://en.wikipedia.org/wiki/Foot_(unit)>"]
    #[serde(rename = "ft")]
    #[display("ft")]
    Ft,
    #[doc = "Inches <https://en.wikipedia.org/wiki/Inch>"]
    #[serde(rename = "in")]
    #[display("in")]
    In,
    #[doc = "Meters <https://en.wikipedia.org/wiki/Meter>"]
    #[serde(rename = "m")]
    #[display("m")]
    M,
    #[doc = "Millimeters <https://en.wikipedia.org/wiki/Millimeter>"]
    #[serde(rename = "mm")]
    #[display("mm")]
    Mm,
    #[doc = "Yards <https://en.wikipedia.org/wiki/Yard>"]
    #[serde(rename = "yd")]
    #[display("yd")]
    Yd,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitLengthConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitLength,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitLength,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitLengthConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitLengthConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of mass units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitMass {
    #[doc = "Grams <https://en.wikipedia.org/wiki/Gram>"]
    #[serde(rename = "g")]
    #[display("g")]
    G,
    #[doc = "Kilograms <https://en.wikipedia.org/wiki/Kilogram>"]
    #[serde(rename = "kg")]
    #[display("kg")]
    Kg,
    #[doc = "Pounds <https://en.wikipedia.org/wiki/Pound_(mass)>"]
    #[serde(rename = "lb")]
    #[display("lb")]
    Lb,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitMassConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitMass,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitMass,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitMassConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitMassConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of power units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitPower {
    #[doc = "British thermal units (BTU) per minute <https://en.wikipedia.org/wiki/British_thermal_unit>"]
    #[serde(rename = "btu_per_minute")]
    #[display("btu_per_minute")]
    BtuPerMinute,
    #[doc = "Horsepower (hp) <https://en.wikipedia.org/wiki/Horsepower>"]
    #[serde(rename = "horsepower")]
    #[display("horsepower")]
    Horsepower,
    #[doc = "Kilowatts <https://en.wikipedia.org/wiki/Kilowatt>"]
    #[serde(rename = "kilowatts")]
    #[display("kilowatts")]
    Kilowatts,
    #[doc = "Metric horsepower (PS) <https://en.wikipedia.org/wiki/Horsepower#Metric_horsepower>"]
    #[serde(rename = "metric_horsepower")]
    #[display("metric_horsepower")]
    MetricHorsepower,
    #[doc = "Microwatts <https://en.wikipedia.org/wiki/Microwatt>"]
    #[serde(rename = "microwatts")]
    #[display("microwatts")]
    Microwatts,
    #[doc = "Millwatts <https://en.wikipedia.org/wiki/Milliwatt>"]
    #[serde(rename = "milliwatts")]
    #[display("milliwatts")]
    Milliwatts,
    #[doc = "Watts <https://en.wikipedia.org/wiki/Watt>"]
    #[serde(rename = "watts")]
    #[display("watts")]
    Watts,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitPowerConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitPower,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitPower,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitPowerConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitPowerConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of pressure units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitPressure {
    #[doc = "Atmospheres <https://en.wikipedia.org/wiki/Standard_atmosphere_(unit)>"]
    #[serde(rename = "atmospheres")]
    #[display("atmospheres")]
    Atmospheres,
    #[doc = "Bars <https://en.wikipedia.org/wiki/Bar_(unit)>"]
    #[serde(rename = "bars")]
    #[display("bars")]
    Bars,
    #[doc = "Hectopascals <https://en.wikipedia.org/wiki/Hectopascal>"]
    #[serde(rename = "hectopascals")]
    #[display("hectopascals")]
    Hectopascals,
    #[doc = "Kilopascals <https://en.wikipedia.org/wiki/Kilopascal>"]
    #[serde(rename = "kilopascals")]
    #[display("kilopascals")]
    Kilopascals,
    #[doc = "Millibars <https://en.wikipedia.org/wiki/Bar_(unit)>"]
    #[serde(rename = "millibars")]
    #[display("millibars")]
    Millibars,
    #[doc = "Pascals <https://en.wikipedia.org/wiki/Pascal_(unit)>"]
    #[serde(rename = "pascals")]
    #[display("pascals")]
    Pascals,
    #[doc = "Pounds per square inch (PSI) - <https://en.wikipedia.org/wiki/Pound_per_square_inch>"]
    #[serde(rename = "psi")]
    #[display("psi")]
    Psi,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitPressureConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitPressure,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitPressure,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitPressureConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitPressureConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of temperature units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitTemperature {
    #[doc = "Celsius <https://en.wikipedia.org/wiki/Celsius>"]
    #[serde(rename = "celsius")]
    #[display("celsius")]
    Celsius,
    #[doc = "Fahrenheit <https://en.wikipedia.org/wiki/Fahrenheit>"]
    #[serde(rename = "fahrenheit")]
    #[display("fahrenheit")]
    Fahrenheit,
    #[doc = "Kelvin <https://en.wikipedia.org/wiki/Kelvin>"]
    #[serde(rename = "kelvin")]
    #[display("kelvin")]
    Kelvin,
    #[doc = "Rankine <https://en.wikipedia.org/wiki/Rankine_scale>"]
    #[serde(rename = "rankine")]
    #[display("rankine")]
    Rankine,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitTemperatureConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitTemperature,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitTemperature,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitTemperatureConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitTemperatureConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of torque units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitTorque {
    #[doc = "Newton metres <https://en.wikipedia.org/wiki/Newton_metre>"]
    #[serde(rename = "newton_metres")]
    #[display("newton_metres")]
    NewtonMetres,
    #[doc = "Pound foot <https://en.wikipedia.org/wiki/Pound-foot_(torque)>"]
    #[serde(rename = "pound_foot")]
    #[display("pound_foot")]
    PoundFoot,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitTorqueConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitTorque,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitTorque,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitTorqueConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitTorqueConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of volume units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitVolume {
    #[doc = "Cubic centimeters (cc or cm³) <https://en.wikipedia.org/wiki/Cubic_centimeter>"]
    #[serde(rename = "cm3")]
    #[display("cm3")]
    Cm3,
    #[doc = "Cubic feet (ft³) <https://en.wikipedia.org/wiki/Cubic_foot>"]
    #[serde(rename = "ft3")]
    #[display("ft3")]
    Ft3,
    #[doc = "Cubic inches (cu in or in³) <https://en.wikipedia.org/wiki/Cubic_inch>"]
    #[serde(rename = "in3")]
    #[display("in3")]
    In3,
    #[doc = "Cubic meters (m³) <https://en.wikipedia.org/wiki/Cubic_meter>"]
    #[serde(rename = "m3")]
    #[display("m3")]
    M3,
    #[doc = "Cubic yards (yd³) <https://en.wikipedia.org/wiki/Cubic_yard>"]
    #[serde(rename = "yd3")]
    #[display("yd3")]
    Yd3,
    #[doc = "US Fluid Ounces (fl oz) <https://en.wikipedia.org/wiki/Fluid_ounce>"]
    #[serde(rename = "usfloz")]
    #[display("usfloz")]
    Usfloz,
    #[doc = "US Gallons (gal US) <https://en.wikipedia.org/wiki/Gallon>"]
    #[serde(rename = "usgal")]
    #[display("usgal")]
    Usgal,
    #[doc = "Liters (l) <https://en.wikipedia.org/wiki/Litre>"]
    #[serde(rename = "l")]
    #[display("l")]
    L,
    #[doc = "Milliliters (ml) <https://en.wikipedia.org/wiki/Litre>"]
    #[serde(rename = "ml")]
    #[display("ml")]
    Ml,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitVolumeConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitVolume,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitVolume,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitVolumeConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitVolumeConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "Data for updating a member of an org."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateMemberToOrgBody {
    #[doc = "The organization role to give the user."]
    pub role: UserOrgRole,
}

impl std::fmt::Display for UpdateMemberToOrgBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UpdateMemberToOrgBody {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.role).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["role".into()]
    }
}

#[doc = "The data for updating a balance."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdatePaymentBalance {
    #[doc = "The monthy credits remaining in the balance. This gets re-upped every month, but if the credits are not used for a month they do not carry over to the next month. It is a stable amount granted to the user per month."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monthly_credits_remaining: Option<f64>,
    #[doc = "The amount of pre-pay cash remaining in the balance. This number goes down as the user uses their pre-paid credits. The reason we track this amount is if a user ever wants to withdraw their pre-pay cash, we can use this amount to determine how much to give them. Say a user has $100 in pre-paid cash, their bill is worth, $50 after subtracting any other credits (like monthly etc.) Their bill is $50, their pre-pay cash remaining will be subtracted by 50 to pay the bill and their `pre_pay_credits_remaining` will be subtracted by 50 to pay the bill. This way if they want to withdraw money after, they can only withdraw $50 since that is the amount of cash they have remaining."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pre_pay_cash_remaining: Option<f64>,
    #[doc = "The amount of credits remaining in the balance. This is typically the amount of cash * some multiplier they get for pre-paying their account. This number lowers every time a bill is paid with the balance. This number increases every time a user adds funds to their balance. This may be through a subscription or a one off payment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pre_pay_credits_remaining: Option<f64>,
}

impl std::fmt::Display for UpdatePaymentBalance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UpdatePaymentBalance {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(monthly_credits_remaining) = &self.monthly_credits_remaining {
                format!("{:?}", monthly_credits_remaining).into()
            } else {
                String::new().into()
            },
            if let Some(pre_pay_cash_remaining) = &self.pre_pay_cash_remaining {
                format!("{:?}", pre_pay_cash_remaining).into()
            } else {
                String::new().into()
            },
            if let Some(pre_pay_credits_remaining) = &self.pre_pay_credits_remaining {
                format!("{:?}", pre_pay_credits_remaining).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "monthly_credits_remaining".into(),
            "pre_pay_cash_remaining".into(),
            "pre_pay_credits_remaining".into(),
        ]
    }
}

#[doc = "The user-modifiable parts of a User."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateUser {
    #[doc = "The user's company."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[doc = "The user's Discord handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord: Option<String>,
    #[doc = "The user's first name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[doc = "The user's GitHub handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub github: Option<String>,
    #[doc = "The image URL for the user. NOTE: If the user uses an OAuth2 provider, this will be overwritten by the provider's image URL when the user logs in next."]
    pub image: String,
    #[doc = "The user's last name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    #[doc = "The user's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
}

impl std::fmt::Display for UpdateUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UpdateUser {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(company) = &self.company {
                format!("{:?}", company).into()
            } else {
                String::new().into()
            },
            if let Some(discord) = &self.discord {
                format!("{:?}", discord).into()
            } else {
                String::new().into()
            },
            if let Some(first_name) = &self.first_name {
                format!("{:?}", first_name).into()
            } else {
                String::new().into()
            },
            if let Some(github) = &self.github {
                format!("{:?}", github).into()
            } else {
                String::new().into()
            },
            self.image.clone().into(),
            if let Some(last_name) = &self.last_name {
                format!("{:?}", last_name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "company".into(),
            "discord".into(),
            "first_name".into(),
            "github".into(),
            "image".into(),
            "last_name".into(),
            "phone".into(),
        ]
    }
}

#[doc = "A user."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct User {
    #[doc = "If the user should be blocked and the reason why."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block: Option<BlockReason>,
    #[doc = "If we can train on the user's data. If the user is a member of an organization, the organization's setting will override this."]
    #[serde(default)]
    pub can_train_on_data: bool,
    #[doc = "The user's company."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[doc = "The date and time the user was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user's Discord handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord: Option<String>,
    #[doc = "The email address of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = "The date and time the email address was verified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email_verified: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The user's first name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[doc = "The user's GitHub handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub github: Option<String>,
    #[doc = "The unique identifier for the user."]
    pub id: uuid::Uuid,
    #[doc = "The image avatar for the user. This is a URL."]
    pub image: String,
    #[doc = "If the user is tied to a service account."]
    #[serde(default)]
    pub is_service_account: bool,
    #[doc = "The user's last name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    #[doc = "The name of the user. This is auto populated at first from the authentication provider (if there was a name). It can be updated by the user by updating their `first_name` and `last_name` fields."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The user's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
    #[doc = "The date and time the user was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for User {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(block) = &self.block {
                format!("{:?}", block).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.can_train_on_data).into(),
            if let Some(company) = &self.company {
                format!("{:?}", company).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(discord) = &self.discord {
                format!("{:?}", discord).into()
            } else {
                String::new().into()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email).into()
            } else {
                String::new().into()
            },
            if let Some(email_verified) = &self.email_verified {
                format!("{:?}", email_verified).into()
            } else {
                String::new().into()
            },
            if let Some(first_name) = &self.first_name {
                format!("{:?}", first_name).into()
            } else {
                String::new().into()
            },
            if let Some(github) = &self.github {
                format!("{:?}", github).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            self.image.clone().into(),
            format!("{:?}", self.is_service_account).into(),
            if let Some(last_name) = &self.last_name {
                format!("{:?}", last_name).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "block".into(),
            "can_train_on_data".into(),
            "company".into(),
            "created_at".into(),
            "discord".into(),
            "email".into(),
            "email_verified".into(),
            "first_name".into(),
            "github".into(),
            "id".into(),
            "image".into(),
            "is_service_account".into(),
            "last_name".into(),
            "name".into(),
            "phone".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "A user's information about an org, including their role."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UserOrgInfo {
    #[doc = "If we should allow all future users who are created with email addresses from this domain to join the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_users_in_domain_to_auto_join: Option<bool>,
    #[doc = "The billing email address of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub billing_email: Option<String>,
    #[doc = "The date and time the billing email address was verified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub billing_email_verified: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "If the org should be blocked and the reason why."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block: Option<BlockReason>,
    #[doc = "The date and time the org was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The org's domain."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    #[doc = "The unique identifier for the org."]
    pub id: uuid::Uuid,
    #[doc = "The image for the org. This is a URL."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[doc = "The name of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The org's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
    #[doc = "The user's role in the org."]
    pub role: OrgRole,
    #[doc = "The org's stripe id."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stripe_id: Option<String>,
    #[doc = "The date and time the org was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for UserOrgInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UserOrgInfo {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(allow_users_in_domain_to_auto_join) =
                &self.allow_users_in_domain_to_auto_join
            {
                format!("{:?}", allow_users_in_domain_to_auto_join).into()
            } else {
                String::new().into()
            },
            if let Some(billing_email) = &self.billing_email {
                format!("{:?}", billing_email).into()
            } else {
                String::new().into()
            },
            if let Some(billing_email_verified) = &self.billing_email_verified {
                format!("{:?}", billing_email_verified).into()
            } else {
                String::new().into()
            },
            if let Some(block) = &self.block {
                format!("{:?}", block).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(domain) = &self.domain {
                format!("{:?}", domain).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(image) = &self.image {
                format!("{:?}", image).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
            format!("{:?}", self.role).into(),
            if let Some(stripe_id) = &self.stripe_id {
                format!("{:?}", stripe_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "allow_users_in_domain_to_auto_join".into(),
            "billing_email".into(),
            "billing_email_verified".into(),
            "block".into(),
            "created_at".into(),
            "domain".into(),
            "id".into(),
            "image".into(),
            "name".into(),
            "phone".into(),
            "role".into(),
            "stripe_id".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "The roles for users in an organization."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UserOrgRole {
    #[doc = "Admins can do anything in the org."]
    #[serde(rename = "admin")]
    #[display("admin")]
    Admin,
    #[doc = "Members of an org can not modify an org, but they belong in the org."]
    #[serde(rename = "member")]
    #[display("member")]
    Member,
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UserResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<User>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for UserResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for UserResultsPage {
    type Item = User;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UserResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "A verification token response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VerificationTokenResponse {
    #[doc = "The date and time the verification token was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The date and time the verification token expires."]
    pub expires: chrono::DateTime<chrono::Utc>,
    #[doc = "The token used for verification. This is used as the id for the table since it is unique per record."]
    pub id: uuid::Uuid,
    #[doc = "The identifier for the user. This is typically the user's email address since that is what we are verifying."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
    #[doc = "The URL to redirect to if the user requires SAML authentication."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub saml_redirect_url: Option<String>,
    #[doc = "The date and time the verification token was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for VerificationTokenResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VerificationTokenResponse {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.expires).into(),
            format!("{:?}", self.id).into(),
            if let Some(identifier) = &self.identifier {
                format!("{:?}", identifier).into()
            } else {
                String::new().into()
            },
            if let Some(saml_redirect_url) = &self.saml_redirect_url {
                format!("{:?}", saml_redirect_url).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "expires".into(),
            "id".into(),
            "identifier".into(),
            "saml_redirect_url".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "The volume response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Volume {
    #[doc = "The output unit for the volume."]
    pub output_unit: UnitVolume,
    #[doc = "The volume."]
    pub volume: f64,
}

impl std::fmt::Display for Volume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Volume {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.volume).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["output_unit".into(), "volume".into()]
    }
}

#[doc = "The websocket messages the server receives."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum WebSocketRequest {
    #[doc = "The trickle ICE candidate request."]
    #[serde(rename = "trickle_ice")]
    TrickleIce {
        #[doc = "Information about the ICE candidate."]
        candidate: RtcIceCandidateInit,
    },
    #[doc = "The SDP offer request."]
    #[serde(rename = "sdp_offer")]
    SdpOffer {
        #[doc = "The session description."]
        offer: RtcSessionDescription,
    },
    #[doc = "The modeling command request."]
    #[serde(rename = "modeling_cmd_req")]
    ModelingCmdReq {
        #[doc = "Which command to submit to the Kittycad engine."]
        cmd: ModelingCmd,
        #[doc = "ID of command being submitted."]
        cmd_id: uuid::Uuid,
    },
    #[doc = "A sequence of modeling requests. If any request fails, following requests will not be tried."]
    #[serde(rename = "modeling_cmd_batch_req")]
    ModelingCmdBatchReq {
        #[doc = "ID of batch being submitted. Each request has their own individual ModelingCmdId, but this is the ID of the overall batch."]
        batch_id: uuid::Uuid,
        #[doc = "A sequence of modeling requests. If any request fails, following requests will not be tried."]
        requests: Vec<ModelingCmdReq>,
        #[doc = "If false or omitted, responses to each batch command will just be Ok(()). If true, responses will be the actual response data for that modeling command."]
        responses: Option<bool>,
    },
    #[doc = "The client-to-server Ping to ensure the WebSocket stays alive."]
    #[serde(rename = "ping")]
    Ping {},
    #[doc = "The response to a metrics collection request from the server."]
    #[serde(rename = "metrics_response")]
    MetricsResponse {
        #[doc = "Collected metrics from the Client's end of the engine connection."]
        metrics: ClientMetrics,
    },
}

#[doc = "Websocket responses can either be successful or unsuccessful. Slightly different schemas in either case."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WebSocketResponse {
    #[doc = "Which request this is a response to. If the request was a modeling command, this is the modeling command ID. If no request ID was sent, this will be null."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<uuid::Uuid>,
    #[doc = "The data sent with a successful response. This will be flattened into a 'type' and 'data' field."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resp: Option<OkWebSocketResponseData>,
    #[doc = "Always false"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub success: Option<bool>,
    #[doc = "The errors that occurred."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<ApiError>>,
}

impl std::fmt::Display for WebSocketResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for WebSocketResponse {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(request_id) = &self.request_id {
                format!("{:?}", request_id).into()
            } else {
                String::new().into()
            },
            if let Some(resp) = &self.resp {
                format!("{:?}", resp).into()
            } else {
                String::new().into()
            },
            if let Some(success) = &self.success {
                format!("{:?}", success).into()
            } else {
                String::new().into()
            },
            if let Some(errors) = &self.errors {
                format!("{:?}", errors).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "request_id".into(),
            "resp".into(),
            "success".into(),
            "errors".into(),
        ]
    }
}

#[doc = "A subscription to the modeling app."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ZooProductSubscription {
    #[doc = "A description of the tier."]
    pub description: String,
    #[doc = "Features that are included in the subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub features: Option<Vec<SubscriptionTierFeature>>,
    #[doc = "The name of the tier."]
    pub name: ModelingAppSubscriptionTierName,
    #[doc = "The amount of pay-as-you-go credits the individual or org gets outside the modeling app."]
    pub pay_as_you_go_credits: f64,
    #[doc = "The price of the tier per month. If this is for an individual, this is the price they pay. If this is for an organization, this is the price the organization pays per member in the org. This is in USD."]
    pub price: SubscriptionTierPrice,
    #[doc = "The support tier the subscription provides."]
    pub support_tier: SupportTier,
    #[doc = "The behavior of the users data (can it be used for training, etc)."]
    pub training_data_behavior: SubscriptionTrainingDataBehavior,
    #[doc = "If the tier is offered for an individual or an org."]
    #[serde(rename = "type")]
    pub type_: SubscriptionTierType,
    #[doc = "The Zoo tools that you can call unlimited times with this tier."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zoo_tools_included: Option<Vec<ZooTool>>,
}

impl std::fmt::Display for ZooProductSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ZooProductSubscription {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            if let Some(features) = &self.features {
                format!("{:?}", features).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.name).into(),
            format!("{:?}", self.pay_as_you_go_credits).into(),
            format!("{:?}", self.price).into(),
            format!("{:?}", self.support_tier).into(),
            format!("{:?}", self.training_data_behavior).into(),
            format!("{:?}", self.type_).into(),
            if let Some(zoo_tools_included) = &self.zoo_tools_included {
                format!("{:?}", zoo_tools_included).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "features".into(),
            "name".into(),
            "pay_as_you_go_credits".into(),
            "price".into(),
            "support_tier".into(),
            "training_data_behavior".into(),
            "type_".into(),
            "zoo_tools_included".into(),
        ]
    }
}

#[doc = "A struct of Zoo product subscriptions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ZooProductSubscriptions {
    #[doc = "A modeling app subscription."]
    pub modeling_app: ModelingAppSubscriptionTier,
}

impl std::fmt::Display for ZooProductSubscriptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ZooProductSubscriptions {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.modeling_app).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["modeling_app".into()]
    }
}

#[doc = "A struct of Zoo product subscriptions an organization can request."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ZooProductSubscriptionsOrgRequest {
    #[doc = "A modeling app subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modeling_app: Option<ModelingAppOrganizationSubscriptionTier>,
}

impl std::fmt::Display for ZooProductSubscriptionsOrgRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ZooProductSubscriptionsOrgRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(modeling_app) = &self.modeling_app {
            format!("{:?}", modeling_app).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["modeling_app".into()]
    }
}

#[doc = "A struct of Zoo product subscriptions a user can request."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ZooProductSubscriptionsUserRequest {
    #[doc = "A modeling app subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modeling_app: Option<ModelingAppIndividualSubscriptionTier>,
}

impl std::fmt::Display for ZooProductSubscriptionsUserRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ZooProductSubscriptionsUserRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(modeling_app) = &self.modeling_app {
            format!("{:?}", modeling_app).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["modeling_app".into()]
    }
}

#[doc = "The Zoo tools that can make API calls."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ZooTool {
    #[doc = "The modeling app."]
    #[serde(rename = "modeling_app")]
    #[display("modeling_app")]
    ModelingApp,
    #[doc = "The Text-to-CAD UI."]
    #[serde(rename = "text_to_cad")]
    #[display("text_to_cad")]
    TextToCad,
    #[doc = "The Diff Chrome Extension."]
    #[serde(rename = "diff_chrome_extension")]
    #[display("diff_chrome_extension")]
    DiffChromeExtension,
}
