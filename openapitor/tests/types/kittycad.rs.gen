#![doc = r" This module contains the generated types for the library."]
#[cfg(feature = "tabled")]
use tabled::Tabled;
pub mod base64 {
    #![doc = " Base64 data that encodes to url safe base64, but can decode from multiple"]
    #![doc = " base64 implementations to account for various clients and libraries. Compatible"]
    #![doc = " with serde and JsonSchema."]
    use serde::{
        de::{Error, Unexpected, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    };
    use std::{convert::TryFrom, fmt};
    static ALLOWED_DECODING_FORMATS: &[data_encoding::Encoding] = &[
        data_encoding::BASE64,
        data_encoding::BASE64URL,
        data_encoding::BASE64URL_NOPAD,
        data_encoding::BASE64_MIME,
        data_encoding::BASE64_NOPAD,
    ];
    #[derive(Debug, Clone, PartialEq, Eq)]
    #[doc = " A container for binary that should be base64 encoded in serialisation. In reverse"]
    #[doc = " when deserializing, will decode from many different types of base64 possible."]
    pub struct Base64Data(pub Vec<u8>);
    impl Base64Data {
        #[doc = " Return is the data is empty."]
        pub fn is_empty(&self) -> bool {
            self.0.is_empty()
        }
    }

    impl fmt::Display for Base64Data {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", data_encoding::BASE64URL_NOPAD.encode(&self.0))
        }
    }

    impl From<Base64Data> for Vec<u8> {
        fn from(data: Base64Data) -> Vec<u8> {
            data.0
        }
    }

    impl From<Vec<u8>> for Base64Data {
        fn from(data: Vec<u8>) -> Base64Data {
            Base64Data(data)
        }
    }

    impl AsRef<[u8]> for Base64Data {
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    }

    impl TryFrom<&str> for Base64Data {
        type Error = anyhow::Error;
        fn try_from(v: &str) -> Result<Self, Self::Error> {
            for config in ALLOWED_DECODING_FORMATS {
                if let Ok(data) = config.decode(v.as_bytes()) {
                    return Ok(Base64Data(data));
                }
            }
            anyhow::bail!("Could not decode base64 data: {}", v);
        }
    }

    struct Base64DataVisitor;
    impl Visitor<'_> for Base64DataVisitor {
        type Value = Base64Data;
        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            write!(formatter, "a base64 encoded string")
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: Error,
        {
            for config in ALLOWED_DECODING_FORMATS {
                if let Ok(data) = config.decode(v.as_bytes()) {
                    return Ok(Base64Data(data));
                }
            }
            Err(serde::de::Error::invalid_value(Unexpected::Str(v), &self))
        }
    }

    impl<'de> Deserialize<'de> for Base64Data {
        fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
        where
            D: Deserializer<'de>,
        {
            deserializer.deserialize_str(Base64DataVisitor)
        }
    }

    impl Serialize for Base64Data {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            let encoded = data_encoding::BASE64URL_NOPAD.encode(&self.0);
            serializer.serialize_str(&encoded)
        }
    }

    impl schemars::JsonSchema for Base64Data {
        fn schema_name() -> String {
            "Base64Data".to_string()
        }

        fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
            let mut obj = gen.root_schema_for::<String>().schema;
            obj.format = Some("byte".to_string());
            schemars::schema::Schema::Object(obj)
        }

        fn is_referenceable() -> bool {
            false
        }
    }

    #[cfg(test)]
    mod tests {
        use super::Base64Data;
        use std::convert::TryFrom;
        #[test]
        fn test_base64_try_from() {
            assert!(Base64Data::try_from("aGVsbG8=").is_ok());
            assert!(Base64Data::try_from("abcdefghij").is_err());
        }
    }
}

#[cfg(feature = "requests")]
pub mod multipart {
    #![doc = " Multipart form data types."]
    use std::path::PathBuf;
    #[doc = " An attachement to a multipart form."]
    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    pub struct Attachment {
        #[doc = " The name of the field."]
        pub name: String,
        #[doc = " The file path of the attachment."]
        pub filepath: Option<PathBuf>,
        #[doc = " The content type of the attachment."]
        pub content_type: Option<String>,
        #[doc = " The data of the attachment."]
        pub data: Vec<u8>,
    }

    impl std::convert::TryFrom<Attachment> for reqwest::multipart::Part {
        type Error = reqwest::Error;
        fn try_from(attachment: Attachment) -> Result<Self, Self::Error> {
            let mut part = reqwest::multipart::Part::bytes(attachment.data);
            if let Some(filepath) = attachment.filepath {
                part = part.file_name(filepath.to_string_lossy().to_string());
            }
            if let Some(content_type) = attachment.content_type {
                part = part.mime_str(&content_type)?;
            }
            Ok(part)
        }
    }

    impl std::convert::TryFrom<std::path::PathBuf> for Attachment {
        type Error = std::io::Error;
        fn try_from(path: std::path::PathBuf) -> Result<Self, Self::Error> {
            let content_type = mime_guess::from_path(&path).first_raw();
            let data = std::fs::read(&path)?;
            Ok(Attachment {
                name: "file".to_string(),
                filepath: Some(path),
                content_type: content_type.map(|s| s.to_string()),
                data,
            })
        }
    }
}

#[cfg(feature = "requests")]
pub mod paginate {
    #![doc = " Utility functions used for pagination."]
    use anyhow::Result;
    #[doc = " A trait for types that allow pagination."]
    pub trait Pagination {
        #[doc = " The item that is paginated."]
        type Item: serde::de::DeserializeOwned;
        #[doc = " Returns true if the response has more pages."]
        fn has_more_pages(&self) -> bool;
        #[doc = " Returns the next page token."]
        fn next_page_token(&self) -> Option<String>;
        #[doc = " Modify a request to get the next page."]
        fn next_page(
            &self,
            req: reqwest::Request,
        ) -> Result<reqwest::Request, crate::types::error::Error>;
        #[doc = " Get the items from a page."]
        fn items(&self) -> Vec<Self::Item>;
    }
}

pub mod phone_number {
    #![doc = " A library to implement phone numbers for our database and JSON serialization and deserialization."]
    use schemars::JsonSchema;
    use std::str::FromStr;
    #[doc = " A phone number."]
    #[derive(Debug, Default, Clone, PartialEq, Hash, Eq)]
    pub struct PhoneNumber(pub Option<phonenumber::PhoneNumber>);
    impl From<phonenumber::PhoneNumber> for PhoneNumber {
        fn from(id: phonenumber::PhoneNumber) -> PhoneNumber {
            PhoneNumber(Some(id))
        }
    }

    impl AsRef<Option<phonenumber::PhoneNumber>> for PhoneNumber {
        fn as_ref(&self) -> &Option<phonenumber::PhoneNumber> {
            &self.0
        }
    }

    impl std::ops::Deref for PhoneNumber {
        type Target = Option<phonenumber::PhoneNumber>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl serde::ser::Serialize for PhoneNumber {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            serializer.serialize_str(&self.to_string())
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PhoneNumber {
        fn deserialize<D>(deserializer: D) -> Result<PhoneNumber, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let s = String::deserialize(deserializer).unwrap_or_default();
            PhoneNumber::from_str(&s).map_err(serde::de::Error::custom)
        }
    }

    impl std::str::FromStr for PhoneNumber {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            if s.trim().is_empty() {
                return Ok(PhoneNumber(None));
            }
            let s = if !s.trim().starts_with('+') {
                format!("+1{s}")
            } else {
                s.to_string()
            }
            .replace(['-', '(', ')', ' '], "");
            Ok(PhoneNumber(Some(phonenumber::parse(None, &s).map_err(
                |e| anyhow::anyhow!("invalid phone number `{}`: {}", s, e),
            )?)))
        }
    }

    impl std::fmt::Display for PhoneNumber {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let s = if let Some(phone) = &self.0 {
                phone
                    .format()
                    .mode(phonenumber::Mode::International)
                    .to_string()
            } else {
                String::new()
            };
            write!(f, "{}", s)
        }
    }

    impl JsonSchema for PhoneNumber {
        fn schema_name() -> String {
            "PhoneNumber".to_string()
        }

        fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
            let mut obj = gen.root_schema_for::<String>().schema;
            obj.format = Some("phone".to_string());
            schemars::schema::Schema::Object(obj)
        }

        fn is_referenceable() -> bool {
            false
        }
    }

    #[cfg(test)]
    mod test {
        use super::PhoneNumber;
        use pretty_assertions::assert_eq;
        #[test]
        fn test_parse_phone_number() {
            let mut phone = "+1-555-555-5555";
            let mut phone_parsed: PhoneNumber =
                serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            let mut expected = PhoneNumber(Some(phonenumber::parse(None, phone).unwrap()));
            assert_eq!(phone_parsed, expected);
            let mut expected_str = "+1 555-555-5555";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "555-555-5555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "+1 555-555-5555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "5555555555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "(510) 864-1234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            expected = PhoneNumber(Some(phonenumber::parse(None, "+15108641234").unwrap()));
            assert_eq!(phone_parsed, expected);
            expected_str = "+1 510-864-1234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "(510)8641234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            expected_str = "+1 510-864-1234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, PhoneNumber(None));
            assert_eq!("", serde_json::json!(phone_parsed));
            phone = "+49 30  1234 1234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            expected = PhoneNumber(Some(phonenumber::parse(None, phone).unwrap()));
            assert_eq!(phone_parsed, expected);
            expected_str = "+49 30 12341234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
        }
    }
}

#[cfg(feature = "requests")]
pub mod error {
    #![doc = " Error methods."]
    #[doc = " Error produced by generated client methods."]
    pub enum Error {
        #[doc = " The request did not conform to API requirements."]
        InvalidRequest(String),
        #[cfg(feature = "retry")]
        #[doc = " A server error either due to the data, or with the connection."]
        CommunicationError(reqwest_middleware::Error),
        #[doc = " A request error, caused when building the request."]
        RequestError(reqwest::Error),
        #[doc = " An expected response whose deserialization failed."]
        SerdeError {
            #[doc = " The error."]
            error: format_serde_error::SerdeError,
            #[doc = " The response status."]
            status: reqwest::StatusCode,
        },
        #[doc = " An expected error response."]
        InvalidResponsePayload {
            #[cfg(feature = "retry")]
            #[doc = " The error."]
            error: reqwest_middleware::Error,
            #[cfg(not(feature = "retry"))]
            #[doc = " The error."]
            error: reqwest::Error,
            #[doc = " The full response."]
            response: reqwest::Response,
        },
        #[doc = " An error from the server."]
        Server {
            #[doc = " The text from the body."]
            body: String,
            #[doc = " The response status."]
            status: reqwest::StatusCode,
        },
        #[doc = " A response not listed in the API description. This may represent a"]
        #[doc = " success or failure response; check `status().is_success()`."]
        UnexpectedResponse(reqwest::Response),
    }

    impl Error {
        #[doc = " Returns the status code, if the error was generated from a response."]
        pub fn status(&self) -> Option<reqwest::StatusCode> {
            match self {
                Error::InvalidRequest(_) => None,
                Error::RequestError(e) => e.status(),
                #[cfg(feature = "retry")]
                Error::CommunicationError(reqwest_middleware::Error::Reqwest(e)) => e.status(),
                #[cfg(feature = "retry")]
                Error::CommunicationError(reqwest_middleware::Error::Middleware(_)) => None,
                Error::SerdeError { error: _, status } => Some(*status),
                Error::InvalidResponsePayload { error: _, response } => Some(response.status()),
                Error::Server { body: _, status } => Some(*status),
                Error::UnexpectedResponse(r) => Some(r.status()),
            }
        }

        #[doc = " Creates a new error from a response status and a serde error."]
        pub fn from_serde_error(
            e: format_serde_error::SerdeError,
            status: reqwest::StatusCode,
        ) -> Self {
            Self::SerdeError { error: e, status }
        }
    }

    #[cfg(feature = "retry")]
    impl From<reqwest_middleware::Error> for Error {
        fn from(e: reqwest_middleware::Error) -> Self {
            Self::CommunicationError(e)
        }
    }

    impl From<reqwest::Error> for Error {
        fn from(e: reqwest::Error) -> Self {
            Self::RequestError(e)
        }
    }

    impl From<serde_json::Error> for Error {
        fn from(e: serde_json::Error) -> Self {
            Self::SerdeError {
                error: format_serde_error::SerdeError::new(String::new(), e),
                status: reqwest::StatusCode::INTERNAL_SERVER_ERROR,
            }
        }
    }

    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Error::InvalidRequest(s) => {
                    write!(f, "Invalid Request: {}", s)
                }
                #[cfg(feature = "retry")]
                Error::CommunicationError(e) => {
                    write!(f, "Communication Error: {}", e)
                }
                Error::RequestError(e) => {
                    write!(f, "Request Error: {}", e)
                }
                Error::SerdeError { error, status: _ } => {
                    write!(f, "Serde Error: {}", error)
                }
                Error::InvalidResponsePayload { error, response: _ } => {
                    write!(f, "Invalid Response Payload: {}", error)
                }
                Error::Server { body, status } => {
                    write!(f, "Server Error: {} {}", status, body)
                }
                Error::UnexpectedResponse(r) => {
                    write!(f, "Unexpected Response: {:?}", r)
                }
            }
        }
    }

    impl std::fmt::Debug for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            std::fmt::Display::fmt(self, f)
        }
    }

    impl std::error::Error for Error {
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            match self {
                #[cfg(feature = "retry")]
                Error::CommunicationError(e) => Some(e),
                Error::SerdeError { error, status: _ } => Some(error),
                Error::InvalidResponsePayload { error, response: _ } => Some(error),
                _ => None,
            }
        }
    }
}

#[doc = "An account provider."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AccountProvider {
    #[doc = "The Apple account provider."]
    #[serde(rename = "apple")]
    #[display("apple")]
    Apple,
    #[doc = "The Discord account provider."]
    #[serde(rename = "discord")]
    #[display("discord")]
    Discord,
    #[doc = "The Google account provider."]
    #[serde(rename = "google")]
    #[display("google")]
    Google,
    #[doc = "The GitHub account provider."]
    #[serde(rename = "github")]
    #[display("github")]
    Github,
    #[doc = "The Microsoft account provider."]
    #[serde(rename = "microsoft")]
    #[display("microsoft")]
    Microsoft,
    #[doc = "The SAML account provider."]
    #[serde(rename = "saml")]
    #[display("saml")]
    Saml,
    #[doc = "The Tencent QQ account provider."]
    #[serde(rename = "tencent")]
    #[display("tencent")]
    Tencent,
}

#[doc = "The response from the `AddHoleFromOffset` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AddHoleFromOffset {
    #[doc = "If the offset path splits into multiple paths, this will contain the UUIDs of the new paths. If the offset path remains as a single path, this will be empty, and the resulting ID of the (single) new path will be the ID of the `AddHoleFromOffset` command."]
    pub entity_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for AddHoleFromOffset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AddHoleFromOffset {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_ids".into()]
    }
}

#[doc = "Data for adding a member to an org."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AddOrgMember {
    #[doc = "The email address of the user to add to the org."]
    pub email: String,
    #[doc = "The organization role to give the user."]
    pub role: UserOrgRole,
}

impl std::fmt::Display for AddOrgMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AddOrgMember {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.email.clone().into(), format!("{:?}", self.role).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["email".into(), "role".into()]
    }
}

#[doc = "Address details."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AddressDetails {
    #[doc = "The city component."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub city: Option<String>,
    #[doc = "The country component. This is a two-letter ISO country code."]
    pub country: String,
    #[doc = "The state component."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    #[doc = "The first street component."]
    #[serde(rename = "street1", default, skip_serializing_if = "Option::is_none")]
    pub street_1: Option<String>,
    #[doc = "The second street component."]
    #[serde(rename = "street2", default, skip_serializing_if = "Option::is_none")]
    pub street_2: Option<String>,
    #[doc = "The zip component."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zip: Option<String>,
}

impl std::fmt::Display for AddressDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AddressDetails {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(city) = &self.city {
                format!("{:?}", city).into()
            } else {
                String::new().into()
            },
            self.country.clone().into(),
            if let Some(state) = &self.state {
                format!("{:?}", state).into()
            } else {
                String::new().into()
            },
            if let Some(street_1) = &self.street_1 {
                format!("{:?}", street_1).into()
            } else {
                String::new().into()
            },
            if let Some(street_2) = &self.street_2 {
                format!("{:?}", street_2).into()
            } else {
                String::new().into()
            },
            if let Some(zip) = &self.zip {
                format!("{:?}", zip).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "city".into(),
            "country".into(),
            "state".into(),
            "street_1".into(),
            "street_2".into(),
            "zip".into(),
        ]
    }
}

#[doc = "Edge info struct (useful for maintaining mappings between edges and faces and adjacent/opposite edges)."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AdjacencyInfo {
    #[doc = "Adjacent edge and face info."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub adjacent_info: Option<EdgeInfo>,
    #[doc = "Opposite edge and face info."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opposite_info: Option<EdgeInfo>,
    #[doc = "Original edge id and face info."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub original_info: Option<EdgeInfo>,
}

impl std::fmt::Display for AdjacencyInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AdjacencyInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(adjacent_info) = &self.adjacent_info {
                format!("{:?}", adjacent_info).into()
            } else {
                String::new().into()
            },
            if let Some(opposite_info) = &self.opposite_info {
                format!("{:?}", opposite_info).into()
            } else {
                String::new().into()
            },
            if let Some(original_info) = &self.original_info {
                format!("{:?}", original_info).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "adjacent_info".into(),
            "opposite_info".into(),
            "original_info".into(),
        ]
    }
}

#[doc = "An angle, with a specific unit."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Angle {
    #[doc = "What unit is the measurement?"]
    pub unit: UnitAngle,
    #[doc = "The size of the angle, measured in the chosen unit."]
    pub value: f64,
}

impl std::fmt::Display for Angle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Angle {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.unit).into(),
            format!("{:?}", self.value).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["unit".into(), "value".into()]
    }
}

#[doc = "Annotation line end type"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AnnotationLineEnd {
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[serde(rename = "arrow")]
    #[display("arrow")]
    Arrow,
}

#[doc = "Options for annotation text"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AnnotationLineEndOptions {
    #[doc = "How to style the end of the annotation line."]
    pub end: AnnotationLineEnd,
    #[doc = "How to style the start of the annotation line."]
    pub start: AnnotationLineEnd,
}

impl std::fmt::Display for AnnotationLineEndOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AnnotationLineEndOptions {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.end).into(),
            format!("{:?}", self.start).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["end".into(), "start".into()]
    }
}

#[doc = "Options for annotations"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AnnotationOptions {
    #[doc = "Color to render the annotation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<Color>,
    #[doc = "How to style the start and end of the line"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub line_ends: Option<AnnotationLineEndOptions>,
    #[doc = "Width of the annotation's line"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub line_width: Option<f64>,
    #[doc = "Position to put the annotation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<Point3D>,
    #[doc = "Text displayed on the annotation"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<AnnotationTextOptions>,
}

impl std::fmt::Display for AnnotationOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AnnotationOptions {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(color) = &self.color {
                format!("{:?}", color).into()
            } else {
                String::new().into()
            },
            if let Some(line_ends) = &self.line_ends {
                format!("{:?}", line_ends).into()
            } else {
                String::new().into()
            },
            if let Some(line_width) = &self.line_width {
                format!("{:?}", line_width).into()
            } else {
                String::new().into()
            },
            if let Some(position) = &self.position {
                format!("{:?}", position).into()
            } else {
                String::new().into()
            },
            if let Some(text) = &self.text {
                format!("{:?}", text).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "color".into(),
            "line_ends".into(),
            "line_width".into(),
            "position".into(),
            "text".into(),
        ]
    }
}

#[doc = "Horizontal Text alignment"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AnnotationTextAlignmentX {
    #[serde(rename = "left")]
    #[display("left")]
    Left,
    #[serde(rename = "center")]
    #[display("center")]
    Center,
    #[serde(rename = "right")]
    #[display("right")]
    Right,
}

#[doc = "Vertical Text alignment"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AnnotationTextAlignmentY {
    #[serde(rename = "bottom")]
    #[display("bottom")]
    Bottom,
    #[serde(rename = "center")]
    #[display("center")]
    Center,
    #[serde(rename = "top")]
    #[display("top")]
    Top,
}

#[doc = "Options for annotation text"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AnnotationTextOptions {
    #[doc = "Text font's point size"]
    pub point_size: u32,
    #[doc = "Text displayed on the annotation"]
    pub text: String,
    #[doc = "Alignment along the X axis"]
    pub x: AnnotationTextAlignmentX,
    #[doc = "Alignment along the Y axis"]
    pub y: AnnotationTextAlignmentY,
}

impl std::fmt::Display for AnnotationTextOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AnnotationTextOptions {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.point_size).into(),
            self.text.clone().into(),
            format!("{:?}", self.x).into(),
            format!("{:?}", self.y).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["point_size".into(), "text".into(), "x".into(), "y".into()]
    }
}

#[doc = "The type of annotation"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AnnotationType {
    #[doc = "2D annotation type (screen or planar space)"]
    #[serde(rename = "t2d")]
    #[display("t2d")]
    T2D,
    #[doc = "3D annotation type"]
    #[serde(rename = "t3d")]
    #[display("t3d")]
    T3D,
}

#[doc = "A response for a query on the API call table that is grouped by something."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiCallQueryGroup {
    pub count: i64,
    pub query: String,
}

impl std::fmt::Display for ApiCallQueryGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiCallQueryGroup {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.count).into(),
            self.query.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["count".into(), "query".into()]
    }
}

#[doc = "The field of an API call to group by."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ApiCallQueryGroupBy {
    #[doc = "The email of the user that requested the API call."]
    #[serde(rename = "email")]
    #[display("email")]
    Email,
    #[doc = "The HTTP method of the API call."]
    #[serde(rename = "method")]
    #[display("method")]
    Method,
    #[doc = "The endpoint of the API call."]
    #[serde(rename = "endpoint")]
    #[display("endpoint")]
    Endpoint,
    #[doc = "The user ID of the user that requested the API call."]
    #[serde(rename = "user_id")]
    #[display("user_id")]
    UserId,
    #[doc = "The origin of the API call. This is parsed from the `Origin` header."]
    #[serde(rename = "origin")]
    #[display("origin")]
    Origin,
    #[doc = "The IP address of the user making the API call."]
    #[serde(rename = "ip_address")]
    #[display("ip_address")]
    IpAddress,
}

#[doc = "The status of an async API call."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ApiCallStatus {
    #[doc = "The async API call is queued."]
    #[serde(rename = "queued")]
    #[display("queued")]
    Queued,
    #[doc = "The async API call was uploaded to be converted."]
    #[serde(rename = "uploaded")]
    #[display("uploaded")]
    Uploaded,
    #[doc = "The async API call is in progress."]
    #[serde(rename = "in_progress")]
    #[display("in_progress")]
    InProgress,
    #[doc = "The async API call has completed."]
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[doc = "The async API call has failed."]
    #[serde(rename = "failed")]
    #[display("failed")]
    Failed,
}

#[doc = "An API call with the price.\n\nThis is a join of the `ApiCall` and `ApiCallPrice` tables."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiCallWithPrice {
    #[doc = "The date and time the API call completed billing."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The duration of the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<i64>,
    #[doc = "The user's email address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = "The endpoint requested by the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    #[doc = "The unique identifier for the API call."]
    pub id: uuid::Uuid,
    #[doc = "The ip address of the origin."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<std::net::IpAddr>,
    #[doc = "The HTTP method requested by the API call."]
    pub method: Method,
    #[doc = "The number of minutes the API call was billed for."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<i32>,
    #[doc = "The organization ID of the API call if it is billable through an organization."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub org_id: Option<uuid::Uuid>,
    #[doc = "The origin of the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[doc = "The price of the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The request body sent by the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_body: Option<String>,
    #[doc = "The request query params sent by the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_query_params: Option<String>,
    #[doc = "The response body returned by the API call. We do not store this information if it is above a certain size."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response_body: Option<String>,
    #[doc = "The date and time the API call started billing."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status code returned by the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_code: Option<i32>,
    #[doc = "The Stripe invoice item ID of the API call if it is billable."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stripe_invoice_item_id: Option<String>,
    #[doc = "The API token that made the API call."]
    pub token: uuid::Uuid,
    #[doc = "The date and time the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user agent of the request."]
    pub user_agent: String,
    #[doc = "The ID of the user that made the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for ApiCallWithPrice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiCallWithPrice {
    const LENGTH: usize = 22;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(duration) = &self.duration {
                format!("{:?}", duration).into()
            } else {
                String::new().into()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email).into()
            } else {
                String::new().into()
            },
            if let Some(endpoint) = &self.endpoint {
                format!("{:?}", endpoint).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(ip_address) = &self.ip_address {
                format!("{:?}", ip_address).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.method).into(),
            if let Some(minutes) = &self.minutes {
                format!("{:?}", minutes).into()
            } else {
                String::new().into()
            },
            if let Some(org_id) = &self.org_id {
                format!("{:?}", org_id).into()
            } else {
                String::new().into()
            },
            if let Some(origin) = &self.origin {
                format!("{:?}", origin).into()
            } else {
                String::new().into()
            },
            if let Some(price) = &self.price {
                format!("{:?}", price).into()
            } else {
                String::new().into()
            },
            if let Some(request_body) = &self.request_body {
                format!("{:?}", request_body).into()
            } else {
                String::new().into()
            },
            if let Some(request_query_params) = &self.request_query_params {
                format!("{:?}", request_query_params).into()
            } else {
                String::new().into()
            },
            if let Some(response_body) = &self.response_body {
                format!("{:?}", response_body).into()
            } else {
                String::new().into()
            },
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            if let Some(status_code) = &self.status_code {
                format!("{:?}", status_code).into()
            } else {
                String::new().into()
            },
            if let Some(stripe_invoice_item_id) = &self.stripe_invoice_item_id {
                format!("{:?}", stripe_invoice_item_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.token).into(),
            format!("{:?}", self.updated_at).into(),
            self.user_agent.clone().into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "duration".into(),
            "email".into(),
            "endpoint".into(),
            "id".into(),
            "ip_address".into(),
            "method".into(),
            "minutes".into(),
            "org_id".into(),
            "origin".into(),
            "price".into(),
            "request_body".into(),
            "request_query_params".into(),
            "response_body".into(),
            "started_at".into(),
            "status_code".into(),
            "stripe_invoice_item_id".into(),
            "token".into(),
            "updated_at".into(),
            "user_agent".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiCallWithPriceResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<ApiCallWithPrice>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ApiCallWithPriceResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ApiCallWithPriceResultsPage {
    type Item = ApiCallWithPrice;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiCallWithPriceResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Types of API endpoints."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ApiEndpoint {
    #[doc = "The modeling API."]
    #[serde(rename = "modeling")]
    #[display("modeling")]
    Modeling,
    #[doc = "Machine learning API."]
    #[serde(rename = "ml")]
    #[display("ml")]
    Ml,
    #[doc = "File API."]
    #[serde(rename = "file")]
    #[display("file")]
    File,
}

#[doc = "An error."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiError {
    #[doc = "The error code."]
    pub error_code: ErrorCode,
    #[doc = "The error message."]
    pub message: String,
}

impl std::fmt::Display for ApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiError {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.error_code).into(),
            self.message.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["error_code".into(), "message".into()]
    }
}

#[doc = "An API token.\n\nThese are used to authenticate users with Bearer authentication."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiToken {
    #[doc = "The date and time the API token was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The unique identifier for the API token."]
    pub id: uuid::Uuid,
    #[doc = "If the token is valid. We never delete API tokens, but we can mark them as invalid. We save them for ever to preserve the history of the API token."]
    pub is_valid: bool,
    #[doc = "An optional label for the API token."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[doc = "The API token itself."]
    pub token: String,
    #[doc = "The date and time the API token was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The ID of the user that owns the API token."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for ApiToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiToken {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.is_valid).into(),
            if let Some(label) = &self.label {
                format!("{:?}", label).into()
            } else {
                String::new().into()
            },
            self.token.clone().into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "id".into(),
            "is_valid".into(),
            "label".into(),
            "token".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiTokenResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<ApiToken>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ApiTokenResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ApiTokenResultsPage {
    type Item = ApiToken;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ApiTokenResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Information about a third party app client."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AppClientInfo {
    #[doc = "The URL for consent."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

impl std::fmt::Display for AppClientInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AppClientInfo {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(url) = &self.url {
            format!("{:?}", url).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["url".into()]
    }
}

#[doc = "An async API call."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AsyncApiCall {
    #[doc = "The number of times we've attempted to process this job."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attempts: Option<i16>,
    #[doc = "The time and date the async API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the async API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the async API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The JSON input for the API call. These are determined by the endpoint that is run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<serde_json::Value>,
    #[doc = "The JSON output for the API call. These are determined by the endpoint that is run."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<serde_json::Value>,
    #[doc = "The time and date the async API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the async API call."]
    pub status: ApiCallStatus,
    #[doc = "The type of async API call."]
    #[serde(rename = "type")]
    pub type_: AsyncApiCallType,
    #[doc = "The time and date the async API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the async API call."]
    pub user_id: uuid::Uuid,
    #[doc = "The worker node that is performing or performed the async API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub worker: Option<String>,
}

impl std::fmt::Display for AsyncApiCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AsyncApiCall {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(attempts) = &self.attempts {
                format!("{:?}", attempts).into()
            } else {
                String::new().into()
            },
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.type_).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
            if let Some(worker) = &self.worker {
                format!("{:?}", worker).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "attempts".into(),
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "output".into(),
            "started_at".into(),
            "status".into(),
            "type_".into(),
            "updated_at".into(),
            "user_id".into(),
            "worker".into(),
        ]
    }
}

#[doc = "The output from the async API call."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum AsyncApiCallOutput {
    #[doc = "A file conversion."]
    #[serde(rename = "file_conversion")]
    FileConversion {
        #[doc = "The time and date the API call was completed."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The output format of the file conversion."]
        output_format: FileExportFormat,
        #[doc = "The output format options of the file conversion."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        output_format_options: Option<OutputFormat3D>,
        #[doc = "The converted files (if multiple file conversion), if completed, base64 encoded. The key of the map is the path of the output file."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        outputs: Option<std::collections::HashMap<String, base64::Base64Data>>,
        #[doc = "The source format of the file conversion."]
        src_format: FileImportFormat,
        #[doc = "The source format options of the file conversion."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        src_format_options: Option<InputFormat3D>,
        #[doc = "The time and date the API call was started."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "File center of mass."]
    #[serde(rename = "file_center_of_mass")]
    FileCenterOfMass {
        #[doc = "The resulting center of mass."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        center_of_mass: Option<Point3D>,
        #[doc = "The time and date the API call was completed."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The output unit for the center of mass."]
        output_unit: UnitLength,
        #[doc = "The source format of the file."]
        src_format: FileImportFormat,
        #[doc = "The time and date the API call was started."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "A file mass."]
    #[serde(rename = "file_mass")]
    FileMass {
        #[doc = "The time and date the API call was completed."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The resulting mass."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mass: Option<f64>,
        #[doc = "The material density as denoted by the user."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        material_density: Option<f64>,
        #[doc = "The material density unit."]
        material_density_unit: UnitDensity,
        #[doc = "The output unit for the mass."]
        output_unit: UnitMass,
        #[doc = "The source format of the file."]
        src_format: FileImportFormat,
        #[doc = "The time and date the API call was started."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "A file volume."]
    #[serde(rename = "file_volume")]
    FileVolume {
        #[doc = "The time and date the API call was completed."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The output unit for the volume."]
        output_unit: UnitVolume,
        #[doc = "The source format of the file."]
        src_format: FileImportFormat,
        #[doc = "The time and date the API call was started."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
        #[doc = "The resulting volume."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        volume: Option<f64>,
    },
    #[doc = "A file density."]
    #[serde(rename = "file_density")]
    FileDensity {
        #[doc = "The time and date the API call was completed."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The resulting density."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        density: Option<f64>,
        #[doc = "The error the function returned, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The material mass as denoted by the user."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        material_mass: Option<f64>,
        #[doc = "The material mass unit."]
        material_mass_unit: UnitMass,
        #[doc = "The output unit for the density."]
        output_unit: UnitDensity,
        #[doc = "The source format of the file."]
        src_format: FileImportFormat,
        #[doc = "The time and date the API call was started."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "A file surface area."]
    #[serde(rename = "file_surface_area")]
    FileSurfaceArea {
        #[doc = "The time and date the API call was completed."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The output unit for the surface area."]
        output_unit: UnitArea,
        #[doc = "The source format of the file."]
        src_format: FileImportFormat,
        #[doc = "The time and date the API call was started."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The resulting surface area."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        surface_area: Option<f64>,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "Text to CAD."]
    #[serde(rename = "text_to_cad")]
    TextToCad {
        #[doc = "The code for the model. This is optional but will be required in the future once we are at v1."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        code: Option<String>,
        #[doc = "The time and date the API call was completed."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "Feedback from the user, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        feedback: Option<MlFeedback>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The version of kcl requested."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        kcl_version: Option<String>,
        #[doc = "The model being used."]
        model: TextToCadModel,
        #[doc = "The version of the model."]
        model_version: String,
        #[doc = "The output format of the model."]
        output_format: FileExportFormat,
        #[doc = "The output of the model in the given file format the user requested, base64 encoded. The key of the map is the path of the output file."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        outputs: Option<std::collections::HashMap<String, base64::Base64Data>>,
        #[doc = "The prompt."]
        prompt: String,
        #[doc = "The time and date the API call was started."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "Text to CAD iteration."]
    #[serde(rename = "text_to_cad_iteration")]
    TextToCadIteration {
        #[doc = "The code for the new model."]
        code: String,
        #[doc = "The time and date the API call was completed."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "Feedback from the user, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        feedback: Option<MlFeedback>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The model being used."]
        model: TextToCadModel,
        #[doc = "The version of the model."]
        model_version: String,
        #[doc = "The original source code for the model, previous to the changes."]
        original_source_code: String,
        #[doc = "The prompt for the overall changes. This is optional if you only want changes on specific source ranges."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        prompt: Option<String>,
        #[doc = "The source ranges the user suggested to change."]
        source_ranges: Vec<SourceRangePrompt>,
        #[doc = "The time and date the API call was started."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
    #[doc = "Text to CAD multi-file iteration."]
    #[serde(rename = "text_to_cad_multi_file_iteration")]
    TextToCadMultiFileIteration {
        #[doc = "The time and date the API call was completed."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        completed_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The conversation ID Conversations group different prompts together."]
        conversation_id: uuid::Uuid,
        #[doc = "The time and date the API call was created."]
        created_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The error the function returned, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "Feedback from the user, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        feedback: Option<MlFeedback>,
        #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
        id: uuid::Uuid,
        #[doc = "The version of kcl to use. If empty, the latest version will be used."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        kcl_version: Option<String>,
        #[doc = "The model being used."]
        model: TextToCadModel,
        #[doc = "The version of the model."]
        model_version: String,
        #[doc = "The output files. Returns a map of the file name to the file contents. The file contents are not encoded since kcl files are not binary."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        outputs: Option<std::collections::HashMap<String, String>>,
        #[doc = "The project name. This is used to tie the prompt to a project. Which helps us make our models better over time."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        project_name: Option<String>,
        #[doc = "The prompt for the overall changes. This is optional if you only want changes on specific source ranges. This will apply to all the files."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        prompt: Option<String>,
        #[doc = "The source ranges the user suggested to change."]
        source_ranges: Vec<SourceRangePrompt>,
        #[doc = "The time and date the API call was started."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        started_at: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "The status of the API call."]
        status: ApiCallStatus,
        #[doc = "The time and date the API call was last updated."]
        updated_at: chrono::DateTime<chrono::Utc>,
        #[doc = "The user ID of the user who created the API call."]
        user_id: uuid::Uuid,
    },
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AsyncApiCallResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<AsyncApiCall>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for AsyncApiCallResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for AsyncApiCallResultsPage {
    type Item = AsyncApiCall;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AsyncApiCallResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "The type of async API call."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum AsyncApiCallType {
    #[doc = "File conversion."]
    #[serde(rename = "file_conversion")]
    #[display("file_conversion")]
    FileConversion,
    #[doc = "File volume."]
    #[serde(rename = "file_volume")]
    #[display("file_volume")]
    FileVolume,
    #[doc = "File center of mass."]
    #[serde(rename = "file_center_of_mass")]
    #[display("file_center_of_mass")]
    FileCenterOfMass,
    #[doc = "File mass."]
    #[serde(rename = "file_mass")]
    #[display("file_mass")]
    FileMass,
    #[doc = "File density."]
    #[serde(rename = "file_density")]
    #[display("file_density")]
    FileDensity,
    #[doc = "File surface area."]
    #[serde(rename = "file_surface_area")]
    #[display("file_surface_area")]
    FileSurfaceArea,
    #[doc = "Text to CAD."]
    #[serde(rename = "text_to_cad")]
    #[display("text_to_cad")]
    TextToCad,
    #[doc = "Text to CAD iteration."]
    #[serde(rename = "text_to_cad_iteration")]
    #[display("text_to_cad_iteration")]
    TextToCadIteration,
    #[doc = "Text to CAD multi-file iteration."]
    #[serde(rename = "text_to_cad_multi_file_iteration")]
    #[display("text_to_cad_multi_file_iteration")]
    TextToCadMultiFileIteration,
}

#[doc = "The response from the `/auth/api-key` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AuthApiKeyResponse {
    #[doc = "The session token"]
    pub session_token: String,
}

impl std::fmt::Display for AuthApiKeyResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AuthApiKeyResponse {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.session_token.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["session_token".into()]
    }
}

#[doc = "The authentication callback from the OAuth 2.0 client. This is typically posted to the redirect URL as query params after authenticating."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AuthCallback {
    #[doc = "The authorization code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[doc = "For Apple only, a JSON web token containing the users identity information."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id_token: Option<String>,
    #[doc = "The state that we had passed in through the user consent URL."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    #[doc = "For Apple only, a JSON string containing the data requested in the scope property. The returned data is in the following format: `{ \"name\": { \"firstName\": string, \"lastName\": string }, \"email\": string }`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

impl std::fmt::Display for AuthCallback {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AuthCallback {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(code) = &self.code {
                format!("{:?}", code).into()
            } else {
                String::new().into()
            },
            if let Some(id_token) = &self.id_token {
                format!("{:?}", id_token).into()
            } else {
                String::new().into()
            },
            if let Some(state) = &self.state {
                format!("{:?}", state).into()
            } else {
                String::new().into()
            },
            if let Some(user) = &self.user {
                format!("{:?}", user).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "code".into(),
            "id_token".into(),
            "state".into(),
            "user".into(),
        ]
    }
}

#[doc = "Co-ordinate axis specifier.\n\nSee [cglearn.eu] for background reading.\n\n[cglearn.eu]: https://cglearn.eu/pub/computer-graphics/introduction-to-geometry#material-coordinate-systems-1"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Axis {
    #[doc = "'Y' axis."]
    #[serde(rename = "y")]
    #[display("y")]
    Y,
    #[doc = "'Z' axis."]
    #[serde(rename = "z")]
    #[display("z")]
    Z,
}

#[doc = "An [`Axis`] paired with a [`Direction`]."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct AxisDirectionPair {
    #[doc = "Axis specifier."]
    pub axis: Axis,
    #[doc = "Specifies which direction the axis is pointing."]
    pub direction: Direction,
}

impl std::fmt::Display for AxisDirectionPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for AxisDirectionPair {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.axis).into(),
            format!("{:?}", self.direction).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["axis".into(), "direction".into()]
    }
}

#[doc = "Websocket responses can either be successful or unsuccessful. Slightly different schemas in either case."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BatchResponse {
    #[doc = "Response to the modeling command."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<OkModelingCmdResponse>,
    #[doc = "Errors that occurred during the modeling command."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<ApiError>>,
}

impl std::fmt::Display for BatchResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for BatchResponse {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(response) = &self.response {
                format!("{:?}", response).into()
            } else {
                String::new().into()
            },
            if let Some(errors) = &self.errors {
                format!("{:?}", errors).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["response".into(), "errors".into()]
    }
}

#[doc = "The billing information for payments."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BillingInfo {
    #[doc = "The address of the customer."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<AddressDetails>,
    #[doc = "The name of the customer."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The phone for the customer."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
}

impl std::fmt::Display for BillingInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for BillingInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(address) = &self.address {
                format!("{:?}", address).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["address".into(), "name".into(), "phone".into()]
    }
}

#[doc = "The reason for blocking a user."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum BlockReason {
    #[doc = "The user is missing a payment method and has exceeded their free API call credits for the month."]
    #[serde(rename = "missing_payment_method")]
    #[display("missing_payment_method")]
    MissingPaymentMethod,
    #[doc = "The users payment method has failed."]
    #[serde(rename = "payment_method_failed")]
    #[display("payment_method_failed")]
    PaymentMethodFailed,
}

#[doc = "The response from the 'BooleanIntersection'."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BooleanIntersection {
    #[doc = "If the operation produced just one solid, then its ID will be the ID of the modeling command request. But if any extra solids are produced, then their IDs will be included here."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra_solid_ids: Option<Vec<uuid::Uuid>>,
}

impl std::fmt::Display for BooleanIntersection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for BooleanIntersection {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(extra_solid_ids) = &self.extra_solid_ids {
            format!("{:?}", extra_solid_ids).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["extra_solid_ids".into()]
    }
}

#[doc = "The response from the 'BooleanSubtract'."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BooleanSubtract {
    #[doc = "If the operation produced just one solid, then its ID will be the ID of the modeling command request. But if any extra solids are produced, then their IDs will be included here."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra_solid_ids: Option<Vec<uuid::Uuid>>,
}

impl std::fmt::Display for BooleanSubtract {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for BooleanSubtract {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(extra_solid_ids) = &self.extra_solid_ids {
            format!("{:?}", extra_solid_ids).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["extra_solid_ids".into()]
    }
}

#[doc = "The response from the 'BooleanUnion'."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct BooleanUnion {
    #[doc = "If the operation produced just one solid, then its ID will be the ID of the modeling command request. But if any extra solids are produced, then their IDs will be included here."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra_solid_ids: Option<Vec<uuid::Uuid>>,
}

impl std::fmt::Display for BooleanUnion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for BooleanUnion {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(extra_solid_ids) = &self.extra_solid_ids {
            format!("{:?}", extra_solid_ids).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["extra_solid_ids".into()]
    }
}

#[doc = "The response from the `CameraDragEnd` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CameraDragEnd {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for CameraDragEnd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CameraDragEnd {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}

#[doc = "The type of camera drag interaction."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CameraDragInteractionType {
    #[doc = "Camera pan"]
    #[serde(rename = "pan")]
    #[display("pan")]
    Pan,
    #[doc = "Camera rotate (spherical camera revolve/orbit)"]
    #[serde(rename = "rotate")]
    #[display("rotate")]
    Rotate,
    #[doc = "Camera rotate (trackball with 3 degrees of freedom)"]
    #[serde(rename = "rotatetrackball")]
    #[display("rotatetrackball")]
    Rotatetrackball,
    #[doc = "Camera zoom (increase or decrease distance to reference point center)"]
    #[serde(rename = "zoom")]
    #[display("zoom")]
    Zoom,
}

#[doc = "The response from the `CameraDragMove` command. Note this is an \"unreliable\" channel message, so this data may need more data like a \"sequence\""]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CameraDragMove {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for CameraDragMove {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CameraDragMove {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}

#[doc = "The response from the `CameraDragStart` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CameraDragStart {}

impl std::fmt::Display for CameraDragStart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CameraDragStart {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "A type of camera movement applied after certain camera operations"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CameraMovement {
    #[doc = "Adjusts the camera position during the camera operation"]
    #[serde(rename = "vantage")]
    #[display("vantage")]
    Vantage,
    #[doc = "Keeps the camera position in place"]
    #[serde(rename = "none")]
    #[display("none")]
    None,
}

#[doc = "Camera settings including position, center, fov etc"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CameraSettings {
    #[doc = "Camera's look-at center (center-pos gives viewing vector)"]
    pub center: Point3D,
    #[doc = "Camera's field-of-view angle (if ortho is false)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fov_y: Option<f64>,
    #[doc = "The Camera's orientation (in the form of a quaternion)"]
    pub orientation: Point4D,
    #[doc = "Whether or not the camera is in ortho mode"]
    pub ortho: bool,
    #[doc = "The camera's ortho scale (derived from viewing distance if ortho is true)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ortho_scale: Option<f64>,
    #[doc = "Camera position (vantage)"]
    pub pos: Point3D,
    #[doc = "Camera's world-space up vector"]
    pub up: Point3D,
}

impl std::fmt::Display for CameraSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CameraSettings {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.center).into(),
            if let Some(fov_y) = &self.fov_y {
                format!("{:?}", fov_y).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.orientation).into(),
            format!("{:?}", self.ortho).into(),
            if let Some(ortho_scale) = &self.ortho_scale {
                format!("{:?}", ortho_scale).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.pos).into(),
            format!("{:?}", self.up).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "center".into(),
            "fov_y".into(),
            "orientation".into(),
            "ortho".into(),
            "ortho_scale".into(),
            "pos".into(),
            "up".into(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CameraViewState {
    pub eye_offset: f64,
    pub fov_y: f64,
    pub is_ortho: bool,
    pub ortho_scale_enabled: bool,
    pub ortho_scale_factor: f64,
    #[doc = "A point in 3D space"]
    pub pivot_position: Point3D,
    #[doc = "A point in homogeneous (4D) space"]
    pub pivot_rotation: Point4D,
    pub world_coord_system: WorldCoordinateSystem,
}

impl std::fmt::Display for CameraViewState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CameraViewState {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.eye_offset).into(),
            format!("{:?}", self.fov_y).into(),
            format!("{:?}", self.is_ortho).into(),
            format!("{:?}", self.ortho_scale_enabled).into(),
            format!("{:?}", self.ortho_scale_factor).into(),
            format!("{:?}", self.pivot_position).into(),
            format!("{:?}", self.pivot_rotation).into(),
            format!("{:?}", self.world_coord_system).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "eye_offset".into(),
            "fov_y".into(),
            "is_ortho".into(),
            "ortho_scale_enabled".into(),
            "ortho_scale_factor".into(),
            "pivot_position".into(),
            "pivot_rotation".into(),
            "world_coord_system".into(),
        ]
    }
}

#[doc = "The card details of a payment method."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CardDetails {
    #[doc = "Card brand.\n\nCan be `amex`, `diners`, `discover`, `jcb`, `mastercard`, `unionpay`, `visa`, or `unknown`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub brand: Option<String>,
    #[doc = "Checks on Card address and CVC if provided."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<PaymentMethodCardChecks>,
    #[doc = "Two-letter ISO code representing the country of the card."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
    #[doc = "Two-digit number representing the card's expiration month."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exp_month: Option<i64>,
    #[doc = "Four-digit number representing the card's expiration year."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exp_year: Option<i64>,
    #[doc = "Uniquely identifies this particular card number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fingerprint: Option<String>,
    #[doc = "Card funding type.\n\nCan be `credit`, `debit`, `prepaid`, or `unknown`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub funding: Option<String>,
    #[doc = "The last four digits of the card."]
    #[serde(rename = "last4", default, skip_serializing_if = "Option::is_none")]
    pub last_4: Option<String>,
}

impl std::fmt::Display for CardDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CardDetails {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(brand) = &self.brand {
                format!("{:?}", brand).into()
            } else {
                String::new().into()
            },
            if let Some(checks) = &self.checks {
                format!("{:?}", checks).into()
            } else {
                String::new().into()
            },
            if let Some(country) = &self.country {
                format!("{:?}", country).into()
            } else {
                String::new().into()
            },
            if let Some(exp_month) = &self.exp_month {
                format!("{:?}", exp_month).into()
            } else {
                String::new().into()
            },
            if let Some(exp_year) = &self.exp_year {
                format!("{:?}", exp_year).into()
            } else {
                String::new().into()
            },
            if let Some(fingerprint) = &self.fingerprint {
                format!("{:?}", fingerprint).into()
            } else {
                String::new().into()
            },
            if let Some(funding) = &self.funding {
                format!("{:?}", funding).into()
            } else {
                String::new().into()
            },
            if let Some(last_4) = &self.last_4 {
                format!("{:?}", last_4).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "brand".into(),
            "checks".into(),
            "country".into(),
            "exp_month".into(),
            "exp_year".into(),
            "fingerprint".into(),
            "funding".into(),
            "last_4".into(),
        ]
    }
}

#[doc = "The center of mass response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CenterOfMass {
    #[doc = "The center of mass."]
    pub center_of_mass: Point3D,
    #[doc = "The output unit for the center of mass."]
    pub output_unit: UnitLength,
}

impl std::fmt::Display for CenterOfMass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CenterOfMass {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.center_of_mass).into(),
            format!("{:?}", self.output_unit).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["center_of_mass".into(), "output_unit".into()]
    }
}

#[doc = "ClientMetrics contains information regarding the state of the peer."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ClientMetrics {
    #[doc = "The height of the inbound video stream in pixels.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-frameheight"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_frame_height: Option<u32>,
    #[doc = "The width of the inbound video stream in pixels.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-framewidth"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_frame_width: Option<u32>,
    #[doc = "Counter of the number of WebRTC frames that the client has decoded from the inbound video stream.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-freezecount"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_frames_decoded: Option<u64>,
    #[doc = "Counter of the number of WebRTC frames the client has dropped from the inbound video stream.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-framesdropped"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_frames_dropped: Option<u32>,
    #[doc = "Current number of frames being rendered in the last second. A good target is 60 frames per second, but it can fluctuate depending on network conditions.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-freezecount"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_frames_per_second: Option<u8>,
    #[doc = "Counter of the number of WebRTC frames that the client has received from the inbound video stream.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-freezecount"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_frames_received: Option<u64>,
    #[doc = "Number of times the inbound video playback has frozen. This is usually due to network conditions.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-freezecount"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_freeze_count: Option<u32>,
    #[doc = "Amount of \"jitter\" in the inbound video stream. Network latency is the time it takes a packet to traverse the network. The amount that the latency varies is the jitter. Video latency is the time it takes to render a frame sent by the server (including network latency). A low jitter means the video latency can be reduced without impacting smooth playback. High jitter means clients will increase video latency to ensure smooth playback.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcreceivedrtpstreamstats-jitter"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_jitter_sec: Option<f64>,
    #[doc = "Number of \"key frames\" decoded in the inbound h.264 stream. A key frame is an expensive (bandwidth-wise) \"full image\" of the video frame. Data after the keyframe become -- effectively -- \"diff\" operations on that key frame. The Engine will only send a keyframe if required, which is an indication that some of the \"diffs\" have been lost, usually an indication of poor network conditions. We like this metric to understand times when the connection has had to recover.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-keyframesdecoded"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_keyframes_decoded: Option<u32>,
    #[doc = "Amount of packets lost in the inbound video stream.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcreceivedrtpstreamstats-packetslost"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_packets_lost: Option<u32>,
    #[doc = "Count of the total number of video pauses experienced by this receiver.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-pausecount"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_pause_count: Option<u32>,
    #[doc = "Count the total number of Picture Loss Indication (PLI) packets.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-plicount"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_pli_count: Option<u32>,
    #[doc = "Total duration of pauses in seconds.\n\nThis is the \"ping\" between the client and the STUN server. Not to be confused with the E2E RTT documented [here](https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats-roundtriptime)\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcicecandidatepairstats-currentroundtriptime"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_stun_rtt_sec: Option<f64>,
    #[doc = "Number of seconds of frozen video the user has been subjected to.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-totalfreezesduration"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_total_freezes_duration_sec: Option<f64>,
    #[doc = "Count of the total number of video pauses experienced by this receiver.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-totalpausesduration"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rtc_total_pauses_duration_sec: Option<f64>,
}

impl std::fmt::Display for ClientMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ClientMetrics {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(rtc_frame_height) = &self.rtc_frame_height {
                format!("{:?}", rtc_frame_height).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_frame_width) = &self.rtc_frame_width {
                format!("{:?}", rtc_frame_width).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_frames_decoded) = &self.rtc_frames_decoded {
                format!("{:?}", rtc_frames_decoded).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_frames_dropped) = &self.rtc_frames_dropped {
                format!("{:?}", rtc_frames_dropped).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_frames_per_second) = &self.rtc_frames_per_second {
                format!("{:?}", rtc_frames_per_second).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_frames_received) = &self.rtc_frames_received {
                format!("{:?}", rtc_frames_received).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_freeze_count) = &self.rtc_freeze_count {
                format!("{:?}", rtc_freeze_count).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_jitter_sec) = &self.rtc_jitter_sec {
                format!("{:?}", rtc_jitter_sec).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_keyframes_decoded) = &self.rtc_keyframes_decoded {
                format!("{:?}", rtc_keyframes_decoded).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_packets_lost) = &self.rtc_packets_lost {
                format!("{:?}", rtc_packets_lost).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_pause_count) = &self.rtc_pause_count {
                format!("{:?}", rtc_pause_count).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_pli_count) = &self.rtc_pli_count {
                format!("{:?}", rtc_pli_count).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_stun_rtt_sec) = &self.rtc_stun_rtt_sec {
                format!("{:?}", rtc_stun_rtt_sec).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_total_freezes_duration_sec) = &self.rtc_total_freezes_duration_sec {
                format!("{:?}", rtc_total_freezes_duration_sec).into()
            } else {
                String::new().into()
            },
            if let Some(rtc_total_pauses_duration_sec) = &self.rtc_total_pauses_duration_sec {
                format!("{:?}", rtc_total_pauses_duration_sec).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "rtc_frame_height".into(),
            "rtc_frame_width".into(),
            "rtc_frames_decoded".into(),
            "rtc_frames_dropped".into(),
            "rtc_frames_per_second".into(),
            "rtc_frames_received".into(),
            "rtc_freeze_count".into(),
            "rtc_jitter_sec".into(),
            "rtc_keyframes_decoded".into(),
            "rtc_packets_lost".into(),
            "rtc_pause_count".into(),
            "rtc_pli_count".into(),
            "rtc_stun_rtt_sec".into(),
            "rtc_total_freezes_duration_sec".into(),
            "rtc_total_pauses_duration_sec".into(),
        ]
    }
}

#[doc = "The response from the `ClosePath` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ClosePath {
    #[doc = "The UUID of the lone face of the resulting solid2D."]
    pub face_id: uuid::Uuid,
}

impl std::fmt::Display for ClosePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ClosePath {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.face_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["face_id".into()]
    }
}

#[doc = "The language code is written in.\n\n<details><summary>JSON schema</summary>\n\n```json { \"description\": \"The language code is written in.\", \"oneOf\": [ { \"description\": \"The `go` programming language.\", \"type\": \"string\", \"enum\": [ \"go\" ] }, { \"description\": \"The `python` programming language.\", \"type\": \"string\", \"enum\": [ \"python\" ] }, { \"description\": \"The `node` programming language.\", \"type\": \"string\", \"enum\": [ \"node\" ] } ] } ``` </details>"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CodeLanguage {
    #[doc = "The `go` programming language."]
    #[serde(rename = "go")]
    #[display("go")]
    Go,
    #[doc = "The `python` programming language."]
    #[serde(rename = "python")]
    #[display("python")]
    Python,
    #[doc = "The `node` programming language."]
    #[serde(rename = "node")]
    #[display("node")]
    Node,
}

#[doc = "Code option for running and verifying kcl.\n\n<details><summary>JSON schema</summary>\n\n```json { \"title\": \"CodeOption\", \"description\": \"Code option for running and verifying kcl.\", \"type\": \"string\", \"enum\": [ \"parse\", \"execute\", \"cleanup\", \"mock_execute\" ] } ``` </details>"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CodeOption {
    #[serde(rename = "parse")]
    #[display("parse")]
    Parse,
    #[serde(rename = "execute")]
    #[display("execute")]
    Execute,
    #[serde(rename = "cleanup")]
    #[display("cleanup")]
    Cleanup,
    #[serde(rename = "mock_execute")]
    #[display("mock_execute")]
    MockExecute,
}

#[doc = "Output of the code being executed.\n\n<details><summary>JSON schema</summary>\n\n```json { \"description\": \"Output of the code being executed.\", \"type\": \"object\", \"properties\": { \"output_files\": { \"description\": \"The contents of the files requested if they were passed.\", \"type\": \"array\", \"items\": { \"$ref\": \"#/components/schemas/OutputFile\" } }, \"stderr\": { \"description\": \"The stderr of the code.\", \"default\": \"\", \"type\": \"string\" }, \"stdout\": { \"description\": \"The stdout of the code.\", \"default\": \"\", \"type\": \"string\" } } } ``` </details>"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CodeOutput {
    #[doc = "The contents of the files requested if they were passed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output_files: Option<Vec<OutputFile>>,
    #[doc = "The stderr of the code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<String>,
    #[doc = "The stdout of the code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<String>,
}

impl std::fmt::Display for CodeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CodeOutput {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(output_files) = &self.output_files {
                format!("{:?}", output_files).into()
            } else {
                String::new().into()
            },
            if let Some(stderr) = &self.stderr {
                format!("{:?}", stderr).into()
            } else {
                String::new().into()
            },
            if let Some(stdout) = &self.stdout {
                format!("{:?}", stdout).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["output_files".into(), "stderr".into(), "stdout".into()]
    }
}

#[doc = "An RGBA color"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Color {
    #[doc = "Alpha"]
    pub a: f64,
    #[doc = "Blue"]
    pub b: f64,
    #[doc = "Green"]
    pub g: f64,
    #[doc = "Red"]
    pub r: f64,
}

impl std::fmt::Display for Color {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Color {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.a).into(),
            format!("{:?}", self.b).into(),
            format!("{:?}", self.g).into(),
            format!("{:?}", self.r).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["a".into(), "b".into(), "g".into(), "r".into()]
    }
}

#[doc = "Struct to contain the edge information of a wall of an extrude/rotate/loft/sweep."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ComplementaryEdges {
    #[doc = "Every edge that shared one common vertex with the original edge."]
    pub adjacent_ids: Vec<uuid::Uuid>,
    #[doc = "The opposite edge has no common vertices with the original edge. A wall may not have an opposite edge (i.e. a revolve that touches the axis of rotation)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opposite_id: Option<uuid::Uuid>,
}

impl std::fmt::Display for ComplementaryEdges {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ComplementaryEdges {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.adjacent_ids).into(),
            if let Some(opposite_id) = &self.opposite_id {
                format!("{:?}", opposite_id).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["adjacent_ids".into(), "opposite_id".into()]
    }
}

#[doc = "Container that holds a translate, rotate and scale. Defaults to no change, everything stays the same (i.e. the identity function)."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ComponentTransform {
    #[doc = "Rotate component of the transform. The rotation is specified as an axis and an angle (xyz are the components of the axis, w is the angle in degrees)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rotate_angle_axis: Option<TransformByForPoint4D>,
    #[doc = "Rotate component of the transform. The rotation is specified as a roll, pitch, yaw."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rotate_rpy: Option<TransformByForPoint3D>,
    #[doc = "Scale component of the transform."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<TransformByForPoint3D>,
    #[doc = "Translate component of the transform."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<TransformByForPoint3D>,
}

impl std::fmt::Display for ComponentTransform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ComponentTransform {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(rotate_angle_axis) = &self.rotate_angle_axis {
                format!("{:?}", rotate_angle_axis).into()
            } else {
                String::new().into()
            },
            if let Some(rotate_rpy) = &self.rotate_rpy {
                format!("{:?}", rotate_rpy).into()
            } else {
                String::new().into()
            },
            if let Some(scale) = &self.scale {
                format!("{:?}", scale).into()
            } else {
                String::new().into()
            },
            if let Some(translate) = &self.translate {
                format!("{:?}", translate).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "rotate_angle_axis".into(),
            "rotate_rpy".into(),
            "scale".into(),
            "translate".into(),
        ]
    }
}

#[doc = "A conversation composed of many ML prompts."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Conversation {
    #[doc = "The date and time the conversation was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The prompt that started this conversation."]
    pub first_prompt: String,
    #[doc = "The unique identifier for the conversation."]
    pub id: uuid::Uuid,
    #[doc = "The date and time the conversation was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the conversation."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for Conversation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Conversation {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            self.first_prompt.clone().into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "first_prompt".into(),
            "id".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ConversationResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Conversation>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ConversationResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ConversationResultsPage {
    type Item = Conversation;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ConversationResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Describes the file to convert (src) and what it should be converted into (output)."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ConversionParams {
    #[doc = "Describes the output file(s)."]
    pub output_format: OutputFormat3D,
    #[doc = "Describes the input file(s)."]
    pub src_format: InputFormat3D,
}

impl std::fmt::Display for ConversionParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ConversionParams {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.output_format).into(),
            format!("{:?}", self.src_format).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["output_format".into(), "src_format".into()]
    }
}

#[doc = "The resource representing a Coupon."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Coupon {
    #[doc = "Amount (in the `currency` specified) that will be taken off the subtotal of any invoices for this customer."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount_off: Option<f64>,
    #[doc = "Always true for a deleted object."]
    #[serde(default)]
    pub deleted: bool,
    #[doc = "Unique identifier for the object."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Set of key-value pairs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
    #[doc = "Name of the coupon displayed to customers on, for instance invoices, or receipts.\n\nBy default the `id` is shown if `name` is not set."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Percent that will be taken off the subtotal of any invoices for this customer for the duration of the coupon.\n\nFor example, a coupon with percent_off of 50 will make a %s100 invoice %s50 instead."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent_off: Option<f64>,
}

impl std::fmt::Display for Coupon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Coupon {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(amount_off) = &self.amount_off {
                format!("{:?}", amount_off).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.deleted).into(),
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            if let Some(percent_off) = &self.percent_off {
                format!("{:?}", percent_off).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "amount_off".into(),
            "deleted".into(),
            "id".into(),
            "metadata".into(),
            "name".into(),
            "percent_off".into(),
        ]
    }
}

#[doc = "Request to create a shortlink."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateShortlinkRequest {
    #[doc = "The password for the shortlink, if you want to restrict access to it. This can only be set if your subscription allows for it. Otherwise, it will return an error. When you access the link it will be required to enter this password through basic auth. The username will be `{anything}` and the password will be the password you set here."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    #[doc = "If the shortlink should be restricted to the user's organization to view. This only applies to org shortlinks. If you are creating a user shortlink and you are not a member of a team or enterprise and you try to set this to true, it will fail."]
    #[serde(default)]
    pub restrict_to_org: bool,
    #[doc = "The URL to redirect back to."]
    pub url: String,
}

impl std::fmt::Display for CreateShortlinkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CreateShortlinkRequest {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(password) = &self.password {
                format!("{:?}", password).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.restrict_to_org).into(),
            self.url.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["password".into(), "restrict_to_org".into(), "url".into()]
    }
}

#[doc = "Response from creating a shortlink."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateShortlinkResponse {
    #[doc = "The key for this url. This is what you use to update or delete the specific shortlink."]
    pub key: String,
    #[doc = "The shortened url."]
    pub url: String,
}

impl std::fmt::Display for CreateShortlinkResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CreateShortlinkResponse {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.key.clone().into(), self.url.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["key".into(), "url".into()]
    }
}

#[doc = "Supported set of sort modes for scanning by created_at only.\n\nCurrently, we only support scanning in ascending order."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CreatedAtSortMode {
    #[doc = "Sort in increasing order of \"created_at\"."]
    #[serde(rename = "created_at_ascending")]
    #[display("created_at_ascending")]
    CreatedAtAscending,
    #[doc = "Sort in decreasing order of \"created_at\"."]
    #[serde(rename = "created_at_descending")]
    #[display("created_at_descending")]
    CreatedAtDescending,
}

#[doc = "The data for subscribing a user to the newsletter."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CrmData {
    #[doc = "The industry of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cad_industry: Option<String>,
    #[doc = "The user type."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cad_user_type: Option<String>,
    #[doc = "The user count of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number_of_cad_users: Option<String>,
}

impl std::fmt::Display for CrmData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CrmData {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(cad_industry) = &self.cad_industry {
                format!("{:?}", cad_industry).into()
            } else {
                String::new().into()
            },
            if let Some(cad_user_type) = &self.cad_user_type {
                format!("{:?}", cad_user_type).into()
            } else {
                String::new().into()
            },
            if let Some(number_of_cad_users) = &self.number_of_cad_users {
                format!("{:?}", number_of_cad_users).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "cad_industry".into(),
            "cad_user_type".into(),
            "number_of_cad_users".into(),
        ]
    }
}

#[doc = "The response from the `CurveGetControlPoints` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CurveGetControlPoints {
    #[doc = "Control points in the curve."]
    pub control_points: Vec<Point3D>,
}

impl std::fmt::Display for CurveGetControlPoints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CurveGetControlPoints {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.control_points).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["control_points".into()]
    }
}

#[doc = "Endpoints of a curve"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CurveGetEndPoints {
    #[doc = "End"]
    pub end: Point3D,
    #[doc = "Start"]
    pub start: Point3D,
}

impl std::fmt::Display for CurveGetEndPoints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CurveGetEndPoints {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.end).into(),
            format!("{:?}", self.start).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["end".into(), "start".into()]
    }
}

#[doc = "The response from the `CurveGetType` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CurveGetType {
    #[doc = "Curve type"]
    pub curve_type: CurveType,
}

impl std::fmt::Display for CurveGetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CurveGetType {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.curve_type).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["curve_type".into()]
    }
}

#[doc = "The response from the `CurveSetConstraint` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CurveSetConstraint {}

impl std::fmt::Display for CurveSetConstraint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CurveSetConstraint {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The type of Curve (embedded within path)"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CurveType {
    #[serde(rename = "line")]
    #[display("line")]
    Line,
    #[serde(rename = "arc")]
    #[display("arc")]
    Arc,
    #[serde(rename = "nurbs")]
    #[display("nurbs")]
    Nurbs,
}

#[doc = "The resource representing a payment \"Customer\"."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Customer {
    #[doc = "The customer's address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<AddressDetails>,
    #[doc = "Current balance, if any, being stored on the customer in the payments service.\n\nIf negative, the customer has credit to apply to their next invoice. If positive, the customer has an amount owed that will be added to their next invoice. The balance does not refer to any unpaid invoices; it solely takes into account amounts that have yet to be successfully applied to any invoice. This balance is only taken into account as invoices are finalized."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub balance: Option<f64>,
    #[doc = "Time at which the object was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Three-letter ISO code for the currency the customer can be charged in for recurring billing purposes."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
    #[doc = "When the customer's latest invoice is billed by charging automatically, `delinquent` is `true` if the invoice's latest charge failed.\n\nWhen the customer's latest invoice is billed by sending an invoice, `delinquent` is `true` if the invoice isn't paid by its due date.  If an invoice is marked uncollectible by dunning, `delinquent` doesn't get reset to `false`."]
    #[serde(default)]
    pub delinquent: bool,
    #[doc = "The customer's email address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = "Unique identifier for the object."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Set of key-value pairs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
    #[doc = "The customer's full name or business name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The customer's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
}

impl std::fmt::Display for Customer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Customer {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(address) = &self.address {
                format!("{:?}", address).into()
            } else {
                String::new().into()
            },
            if let Some(balance) = &self.balance {
                format!("{:?}", balance).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(currency) = &self.currency {
                format!("{:?}", currency).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.delinquent).into(),
            if let Some(email) = &self.email {
                format!("{:?}", email).into()
            } else {
                String::new().into()
            },
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "address".into(),
            "balance".into(),
            "created_at".into(),
            "currency".into(),
            "delinquent".into(),
            "email".into(),
            "id".into(),
            "metadata".into(),
            "name".into(),
            "phone".into(),
        ]
    }
}

#[doc = "A balance for a customer.\n\nThis holds information about the financial balance for the customer."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CustomerBalance {
    #[doc = "The date and time the balance was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The unique identifier for the balance."]
    pub id: uuid::Uuid,
    #[doc = "The mapping id of the user or org."]
    pub map_id: uuid::Uuid,
    #[doc = "The enterprise price for the Modeling App subscription, if they are on the enterprise plan."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modeling_app_enterprise_price: Option<SubscriptionTierPrice>,
    #[doc = "The number of monthly API credits remaining in the balance. This is the number of credits remaining in the balance.\n\nBoth the monetary value and the number of credits are returned, but they reflect the same value in the database."]
    pub monthly_api_credits_remaining: u64,
    #[doc = "The monetary value of the monthly API credits remaining in the balance. This gets re-upped every month, but if the credits are not used for a month they do not carry over to the next month.\n\nBoth the monetary value and the number of credits are returned, but they reflect the same value in the database."]
    pub monthly_api_credits_remaining_monetary_value: f64,
    #[doc = "The number of stable API credits remaining in the balance. These do not get reset or re-upped every month. This is separate from the monthly credits. Credits will first pull from the monthly credits, then the stable credits. Stable just means that they do not get reset every month. A user will have stable credits if a Zoo employee granted them credits.\n\nBoth the monetary value and the number of credits are returned, but they reflect the same value in the database."]
    pub stable_api_credits_remaining: u64,
    #[doc = "The monetary value of stable API credits remaining in the balance. These do not get reset or re-upped every month. This is separate from the monthly credits. Credits will first pull from the monthly credits, then the stable credits. Stable just means that they do not get reset every month. A user will have stable credits if a Zoo employee granted them credits.\n\nBoth the monetary value and the number of credits are returned, but they reflect the same value in the database."]
    pub stable_api_credits_remaining_monetary_value: f64,
    #[doc = "Details about the subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscription_details: Option<ZooProductSubscriptions>,
    #[doc = "The subscription ID for the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subscription_id: Option<String>,
    #[doc = "This includes any outstanding, draft, or open invoices and any pending invoice items. This does not include any credits the customer has on their account. This amount is only returned if requested from the api."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total_due: Option<f64>,
    #[doc = "The date and time the balance was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for CustomerBalance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for CustomerBalance {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.map_id).into(),
            if let Some(modeling_app_enterprise_price) = &self.modeling_app_enterprise_price {
                format!("{:?}", modeling_app_enterprise_price).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.monthly_api_credits_remaining).into(),
            format!("{:?}", self.monthly_api_credits_remaining_monetary_value).into(),
            format!("{:?}", self.stable_api_credits_remaining).into(),
            format!("{:?}", self.stable_api_credits_remaining_monetary_value).into(),
            if let Some(subscription_details) = &self.subscription_details {
                format!("{:?}", subscription_details).into()
            } else {
                String::new().into()
            },
            if let Some(subscription_id) = &self.subscription_id {
                format!("{:?}", subscription_id).into()
            } else {
                String::new().into()
            },
            if let Some(total_due) = &self.total_due {
                format!("{:?}", total_due).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "id".into(),
            "map_id".into(),
            "modeling_app_enterprise_price".into(),
            "monthly_api_credits_remaining".into(),
            "monthly_api_credits_remaining_monetary_value".into(),
            "stable_api_credits_remaining".into(),
            "stable_api_credits_remaining_monetary_value".into(),
            "subscription_details".into(),
            "subscription_id".into(),
            "total_due".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "What strategy (algorithm) should be used for cutting? Defaults to Automatic."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CutStrategy {
    #[doc = "Basic fillet cut. This has limitations, like the filletted edges can't touch each other. But it's very fast and simple."]
    #[serde(rename = "basic")]
    #[display("basic")]
    Basic,
    #[doc = "More complicated fillet cut. It works for more use-cases, like edges that touch each other. But it's slower than the Basic method."]
    #[serde(rename = "csg")]
    #[display("csg")]
    Csg,
    #[doc = "Tries the Basic method, and if that doesn't work, tries the CSG strategy."]
    #[serde(rename = "automatic")]
    #[display("automatic")]
    Automatic,
}

#[doc = "What kind of cut to do"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum CutType {
    #[doc = "Round off an edge."]
    #[serde(rename = "fillet")]
    #[display("fillet")]
    Fillet,
    #[doc = "Cut away an edge."]
    #[serde(rename = "chamfer")]
    #[display("chamfer")]
    Chamfer,
}

#[doc = "The response from the `DefaultCameraCenterToScene` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraCenterToScene {}

impl std::fmt::Display for DefaultCameraCenterToScene {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraCenterToScene {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `DefaultCameraCenterToSelection` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraCenterToSelection {}

impl std::fmt::Display for DefaultCameraCenterToSelection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraCenterToSelection {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `DefaultCameraFocusOn` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraFocusOn {}

impl std::fmt::Display for DefaultCameraFocusOn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraFocusOn {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `DefaultCameraGetSettings` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraGetSettings {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for DefaultCameraGetSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraGetSettings {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}

#[doc = "The response from the `DefaultCameraGetView` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraGetView {
    #[doc = "Camera view state"]
    pub view: CameraViewState,
}

impl std::fmt::Display for DefaultCameraGetView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraGetView {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.view).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["view".into()]
    }
}

#[doc = "The response from the `DefaultCameraLookAt` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraLookAt {}

impl std::fmt::Display for DefaultCameraLookAt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraLookAt {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `DefaultCameraPerspectiveSettings` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraPerspectiveSettings {}

impl std::fmt::Display for DefaultCameraPerspectiveSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraPerspectiveSettings {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `DefaultCameraSetOrthographic` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraSetOrthographic {}

impl std::fmt::Display for DefaultCameraSetOrthographic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraSetOrthographic {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `DefaultCameraSetPerspective` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraSetPerspective {}

impl std::fmt::Display for DefaultCameraSetPerspective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraSetPerspective {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `DefaultCameraSetView` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraSetView {}

impl std::fmt::Display for DefaultCameraSetView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraSetView {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `DefaultCameraZoom` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DefaultCameraZoom {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for DefaultCameraZoom {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DefaultCameraZoom {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}

#[doc = "The density response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Density {
    #[doc = "The density."]
    pub density: f64,
    #[doc = "The output unit for the density."]
    pub output_unit: UnitDensity,
}

impl std::fmt::Display for Density {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Density {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.density).into(),
            format!("{:?}", self.output_unit).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["density".into(), "output_unit".into()]
    }
}

#[doc = "The DER encoded key pair."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DerEncodedKeyPair {
    #[doc = "The request signing private key (pem file)."]
    pub private_key: base64::Base64Data,
    #[doc = "The request signing public certificate (pem file)."]
    pub public_cert: base64::Base64Data,
}

impl std::fmt::Display for DerEncodedKeyPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DerEncodedKeyPair {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.private_key).into(),
            format!("{:?}", self.public_cert).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["private_key".into(), "public_cert".into()]
    }
}

#[doc = "The form for a device access token request."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeviceAccessTokenRequestForm {
    #[doc = "The client ID."]
    pub client_id: uuid::Uuid,
    #[doc = "The device code."]
    pub device_code: uuid::Uuid,
    #[doc = "The grant type."]
    pub grant_type: Oauth2GrantType,
}

impl std::fmt::Display for DeviceAccessTokenRequestForm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DeviceAccessTokenRequestForm {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.client_id).into(),
            format!("{:?}", self.device_code).into(),
            format!("{:?}", self.grant_type).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "client_id".into(),
            "device_code".into(),
            "grant_type".into(),
        ]
    }
}

#[doc = "The request parameters to confirm the `user_code` for the OAuth 2.0 Device Authorization Grant."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeviceAuthConfirmParams {
    #[doc = "The user code."]
    pub user_code: String,
}

impl std::fmt::Display for DeviceAuthConfirmParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DeviceAuthConfirmParams {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.user_code.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["user_code".into()]
    }
}

#[doc = "The request parameters for the OAuth 2.0 Device Authorization Grant flow."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeviceAuthRequestForm {
    #[doc = "The client ID."]
    pub client_id: uuid::Uuid,
}

impl std::fmt::Display for DeviceAuthRequestForm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DeviceAuthRequestForm {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.client_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["client_id".into()]
    }
}

#[doc = "Specifies the sign of a co-ordinate axis."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Direction {
    #[doc = "Increasing numbers."]
    #[serde(rename = "positive")]
    #[display("positive")]
    Positive,
    #[doc = "Decreasing numbers."]
    #[serde(rename = "negative")]
    #[display("negative")]
    Negative,
}

#[doc = "The response from the `DisableDryRun` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DisableDryRun {}

impl std::fmt::Display for DisableDryRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DisableDryRun {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The resource representing a Discount."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Discount {
    #[doc = "The coupon that applied to create this discount."]
    pub coupon: Coupon,
}

impl std::fmt::Display for Discount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Discount {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.coupon).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["coupon".into()]
    }
}

#[doc = "A discount code for a store."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiscountCode {
    #[doc = "The code for the discount."]
    pub code: String,
    #[doc = "The date the discount code expires."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The percent off for the discount."]
    pub percent_off: u32,
}

impl std::fmt::Display for DiscountCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DiscountCode {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.code.clone().into(),
            if let Some(expires_at) = &self.expires_at {
                format!("{:?}", expires_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.percent_off).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["code".into(), "expires_at".into(), "percent_off".into()]
    }
}

#[doc = "The type of distance Distances can vary depending on the objects used as input."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum DistanceType {
    #[doc = "Euclidean Distance."]
    #[serde(rename = "euclidean")]
    Euclidean {},
    #[doc = "The distance between objects along the specified axis"]
    #[serde(rename = "on_axis")]
    OnAxis {
        #[doc = "Global axis"]
        axis: GlobalAxis,
    },
}

#[doc = "Export storage."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum DxfStorage {
    #[doc = "Plaintext encoding.\n\nThis is the default setting."]
    #[serde(rename = "ascii")]
    #[display("ascii")]
    Ascii,
    #[doc = "Binary encoding."]
    #[serde(rename = "binary")]
    #[display("binary")]
    Binary,
}

#[doc = "A list of faces for a specific edge."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EdgeInfo {
    #[doc = "The UUID of the id."]
    pub edge_id: uuid::Uuid,
    #[doc = "The faces of each edge."]
    pub faces: Vec<uuid::Uuid>,
}

impl std::fmt::Display for EdgeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EdgeInfo {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.edge_id).into(),
            format!("{:?}", self.faces).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edge_id".into(), "faces".into()]
    }
}

#[doc = "The response from the `EdgeLinesVisible` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EdgeLinesVisible {}

impl std::fmt::Display for EdgeLinesVisible {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EdgeLinesVisible {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The body of the form for email authentication."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EmailAuthenticationForm {
    #[doc = "The URL to redirect back to after we have authenticated."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callback_url: Option<String>,
    #[doc = "The user's email."]
    pub email: String,
}

impl std::fmt::Display for EmailAuthenticationForm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EmailAuthenticationForm {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(callback_url) = &self.callback_url {
                format!("{:?}", callback_url).into()
            } else {
                String::new().into()
            },
            self.email.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["callback_url".into(), "email".into()]
    }
}

#[doc = "The response from the `EnableDryRun` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EnableDryRun {}

impl std::fmt::Display for EnableDryRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EnableDryRun {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `EnableSketchMode` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EnableSketchMode {}

impl std::fmt::Display for EnableSketchMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EnableSketchMode {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response of the `EngineUtilEvaluatePath` endpoint"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EngineUtilEvaluatePath {
    #[doc = "The evaluated path curve position"]
    pub pos: Point3D,
}

impl std::fmt::Display for EngineUtilEvaluatePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EngineUtilEvaluatePath {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.pos).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["pos".into()]
    }
}

#[doc = "The price for an enterprise subscription."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum EnterpriseSubscriptionTierPrice {
    #[doc = "A flat price that we publicly list."]
    #[serde(rename = "flat")]
    Flat {
        #[doc = "The interval the price is charged."]
        interval: PlanInterval,
        #[doc = "The price."]
        price: f64,
    },
    #[doc = "A per user price that we publicly list."]
    #[serde(rename = "per_user")]
    PerUser {
        #[doc = "The interval the price is charged."]
        interval: PlanInterval,
        #[doc = "The price."]
        price: f64,
    },
}

#[doc = "The response from the `EntityCircularPattern` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityCircularPattern {
    #[doc = "The Face, edge, and entity ids of the patterned entities."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity_face_edge_ids: Option<Vec<FaceEdgeInfo>>,
}

impl std::fmt::Display for EntityCircularPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityCircularPattern {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(entity_face_edge_ids) = &self.entity_face_edge_ids {
                format!("{:?}", entity_face_edge_ids).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_face_edge_ids".into()]
    }
}

#[doc = "The response from the `EntityClone` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityClone {
    #[doc = "The Face and Edge Ids of the cloned entity."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub face_edge_ids: Option<Vec<FaceEdgeInfo>>,
}

impl std::fmt::Display for EntityClone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityClone {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(face_edge_ids) = &self.face_edge_ids {
            format!("{:?}", face_edge_ids).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["face_edge_ids".into()]
    }
}

#[doc = "The response from the `EntityFade` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityFade {}

impl std::fmt::Display for EntityFade {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityFade {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `EntityGetAllChildUuids` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetAllChildUuids {
    #[doc = "The UUIDs of the child entities."]
    pub entity_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for EntityGetAllChildUuids {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetAllChildUuids {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_ids".into()]
    }
}

#[doc = "The response from the `EntityGetChildUuid` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetChildUuid {
    #[doc = "The UUID of the child entity."]
    pub entity_id: uuid::Uuid,
}

impl std::fmt::Display for EntityGetChildUuid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetChildUuid {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_id".into()]
    }
}

#[doc = "The response from the `EntitiesGetDistance` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetDistance {
    #[doc = "The maximum distance between the input entities."]
    pub max_distance: f64,
    #[doc = "The minimum distance between the input entities."]
    pub min_distance: f64,
}

impl std::fmt::Display for EntityGetDistance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetDistance {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.max_distance).into(),
            format!("{:?}", self.min_distance).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["max_distance".into(), "min_distance".into()]
    }
}

#[doc = "The response from the `EntityGetNumChildren` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetNumChildren {
    #[doc = "The number of children the entity has."]
    pub num: u32,
}

impl std::fmt::Display for EntityGetNumChildren {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetNumChildren {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.num).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["num".into()]
    }
}

#[doc = "The response from the `EntityGetParentId` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetParentId {
    #[doc = "The UUID of the parent entity."]
    pub entity_id: uuid::Uuid,
}

impl std::fmt::Display for EntityGetParentId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetParentId {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_id".into()]
    }
}

#[doc = "The response from the `EntityGetSketchPaths` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityGetSketchPaths {
    #[doc = "The UUIDs of the sketch paths."]
    pub entity_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for EntityGetSketchPaths {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityGetSketchPaths {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_ids".into()]
    }
}

#[doc = "The response from the `EntityLinearPattern` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityLinearPattern {
    #[doc = "The Face, edge, and entity ids of the patterned entities."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity_face_edge_ids: Option<Vec<FaceEdgeInfo>>,
}

impl std::fmt::Display for EntityLinearPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityLinearPattern {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(entity_face_edge_ids) = &self.entity_face_edge_ids {
                format!("{:?}", entity_face_edge_ids).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_face_edge_ids".into()]
    }
}

#[doc = "The response from the `EntityLinearPatternTransform` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityLinearPatternTransform {
    #[doc = "The Face, edge, and entity ids of the patterned entities."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity_face_edge_ids: Option<Vec<FaceEdgeInfo>>,
}

impl std::fmt::Display for EntityLinearPatternTransform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityLinearPatternTransform {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(entity_face_edge_ids) = &self.entity_face_edge_ids {
                format!("{:?}", entity_face_edge_ids).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_face_edge_ids".into()]
    }
}

#[doc = "The response from the `EntityMakeHelix` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityMakeHelix {}

impl std::fmt::Display for EntityMakeHelix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityMakeHelix {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `EntityMakeHelixFromEdge` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityMakeHelixFromEdge {}

impl std::fmt::Display for EntityMakeHelixFromEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityMakeHelixFromEdge {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `EntityMakeHelixFromParams` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityMakeHelixFromParams {}

impl std::fmt::Display for EntityMakeHelixFromParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityMakeHelixFromParams {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `EntityMirror` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityMirror {
    #[doc = "The Face, edge, and entity ids of the patterned entities."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity_face_edge_ids: Option<Vec<FaceEdgeInfo>>,
}

impl std::fmt::Display for EntityMirror {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityMirror {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(entity_face_edge_ids) = &self.entity_face_edge_ids {
                format!("{:?}", entity_face_edge_ids).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_face_edge_ids".into()]
    }
}

#[doc = "The response from the `EntityMirrorAcrossEdge` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntityMirrorAcrossEdge {
    #[doc = "The Face, edge, and entity ids of the patterned entities."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity_face_edge_ids: Option<Vec<FaceEdgeInfo>>,
}

impl std::fmt::Display for EntityMirrorAcrossEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntityMirrorAcrossEdge {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(entity_face_edge_ids) = &self.entity_face_edge_ids {
                format!("{:?}", entity_face_edge_ids).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_face_edge_ids".into()]
    }
}

#[doc = "The response from the `EntitySetOpacity` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct EntitySetOpacity {}

impl std::fmt::Display for EntitySetOpacity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for EntitySetOpacity {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The type of entity"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum EntityType {
    #[serde(rename = "entity")]
    #[display("entity")]
    Entity,
    #[serde(rename = "object")]
    #[display("object")]
    Object,
    #[serde(rename = "path")]
    #[display("path")]
    Path,
    #[serde(rename = "curve")]
    #[display("curve")]
    Curve,
    #[serde(rename = "solid2d")]
    #[display("solid2d")]
    Solid2D,
    #[serde(rename = "solid3d")]
    #[display("solid3d")]
    Solid3D,
    #[serde(rename = "edge")]
    #[display("edge")]
    Edge,
    #[serde(rename = "face")]
    #[display("face")]
    Face,
    #[serde(rename = "plane")]
    #[display("plane")]
    Plane,
    #[serde(rename = "vertex")]
    #[display("vertex")]
    Vertex,
}

#[doc = "Error information from a response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Error {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    pub message: String,
    pub request_id: String,
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Error {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(error_code) = &self.error_code {
                format!("{:?}", error_code).into()
            } else {
                String::new().into()
            },
            self.message.clone().into(),
            self.request_id.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["error_code".into(), "message".into(), "request_id".into()]
    }
}

#[doc = "The type of error sent by the KittyCAD API."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ErrorCode {
    #[doc = "Graphics engine failed to complete request, consider retrying"]
    #[serde(rename = "internal_engine")]
    #[display("internal_engine")]
    InternalEngine,
    #[doc = "API failed to complete request, consider retrying"]
    #[serde(rename = "internal_api")]
    #[display("internal_api")]
    InternalApi,
    #[doc = "User requested something geometrically or graphically impossible. Don't retry this request, as it's inherently impossible. Instead, read the error message and change your request."]
    #[serde(rename = "bad_request")]
    #[display("bad_request")]
    BadRequest,
    #[doc = "Auth token is missing from the request"]
    #[serde(rename = "auth_token_missing")]
    #[display("auth_token_missing")]
    AuthTokenMissing,
    #[doc = "Auth token is invalid in some way (expired, incorrect format, etc)"]
    #[serde(rename = "auth_token_invalid")]
    #[display("auth_token_invalid")]
    AuthTokenInvalid,
    #[doc = "Client sent invalid JSON."]
    #[serde(rename = "invalid_json")]
    #[display("invalid_json")]
    InvalidJson,
    #[doc = "Client sent invalid BSON."]
    #[serde(rename = "invalid_bson")]
    #[display("invalid_bson")]
    InvalidBson,
    #[doc = "Client sent a message which is not accepted over this protocol."]
    #[serde(rename = "wrong_protocol")]
    #[display("wrong_protocol")]
    WrongProtocol,
    #[doc = "Problem sending data between client and KittyCAD API."]
    #[serde(rename = "connection_problem")]
    #[display("connection_problem")]
    ConnectionProblem,
    #[doc = "Client sent a Websocket message type which the KittyCAD API does not handle."]
    #[serde(rename = "message_type_not_accepted")]
    #[display("message_type_not_accepted")]
    MessageTypeNotAccepted,
    #[doc = "Client sent a Websocket message intended for WebRTC but it was configured as a WebRTC connection."]
    #[serde(rename = "message_type_not_accepted_for_web_r_t_c")]
    #[display("message_type_not_accepted_for_web_r_t_c")]
    MessageTypeNotAcceptedForWebRTC,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Type {
    #[serde(rename = "modeling_app_event")]
    #[display("modeling_app_event")]
    ModelingAppEvent,
}

impl std::default::Default for Type {
    fn default() -> Self {
        Type::ModelingAppEvent
    }
}

#[doc = "An event related to modeling app files"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Event {
    #[doc = "Attachment URI for where the attachment is stored."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attachment_uri: Option<String>,
    #[doc = "Time this event was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The specific event type from the modeling app."]
    pub event_type: ModelingAppEventType,
    #[doc = "Time the associated attachment was last compiled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_compiled_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Project descriptino as given by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_description: Option<String>,
    #[doc = "Project name as given by the user."]
    pub project_name: String,
    #[doc = "The source app for this event, uuid that is unique to the app."]
    pub source_id: uuid::Uuid,
    #[serde(rename = "type")]
    pub type_: Type,
    #[doc = "An anonymous user id generated client-side."]
    pub user_id: String,
}

impl std::fmt::Display for Event {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Event {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(attachment_uri) = &self.attachment_uri {
                format!("{:?}", attachment_uri).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.event_type).into(),
            if let Some(last_compiled_at) = &self.last_compiled_at {
                format!("{:?}", last_compiled_at).into()
            } else {
                String::new().into()
            },
            if let Some(project_description) = &self.project_description {
                format!("{:?}", project_description).into()
            } else {
                String::new().into()
            },
            self.project_name.clone().into(),
            format!("{:?}", self.source_id).into(),
            format!("{:?}", self.type_).into(),
            self.user_id.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "attachment_uri".into(),
            "created_at".into(),
            "event_type".into(),
            "last_compiled_at".into(),
            "project_description".into(),
            "project_name".into(),
            "source_id".into(),
            "type_".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The response from the `Export` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Export {
    #[doc = "The files that were exported."]
    pub files: Vec<ExportFile>,
}

impl std::fmt::Display for Export {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Export {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.files).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["files".into()]
    }
}

#[doc = "The response from the `Export2d` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Export2D {
    #[doc = "The files that were exported."]
    pub files: Vec<ExportFile>,
}

impl std::fmt::Display for Export2D {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Export2D {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.files).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["files".into()]
    }
}

#[doc = "The response from the `Export3d` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Export3D {
    #[doc = "The files that were exported."]
    pub files: Vec<ExportFile>,
}

impl std::fmt::Display for Export3D {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Export3D {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.files).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["files".into()]
    }
}

#[doc = "A file to be exported to the client."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExportFile {
    #[doc = "The contents of the file, base64 encoded."]
    pub contents: base64::Base64Data,
    #[doc = "The name of the file."]
    pub name: String,
}

impl std::fmt::Display for ExportFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ExportFile {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.contents).into(),
            self.name.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["contents".into(), "name".into()]
    }
}

#[doc = "The response from the `ExtendPath` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExtendPath {}

impl std::fmt::Display for ExtendPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ExtendPath {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "Extended user information.\n\nThis is mostly used for internal purposes. It returns a mapping of the user's information, including that of our third party services we use for users: Stripe"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExtendedUser {
    #[doc = "If the user should be blocked and the reason why."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block: Option<BlockReason>,
    #[doc = "If we can train on the user's data. If the user is a member of an organization, the organization's setting will override this."]
    #[serde(default)]
    pub can_train_on_data: bool,
    #[doc = "The user's company."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[doc = "The date and time the user was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "If the user is scheduled for deletion"]
    #[serde(default)]
    pub deletion_scheduled: bool,
    #[doc = "The user's Discord handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord: Option<String>,
    #[doc = "The email address of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = "The date and time the email address was verified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email_verified: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The user's first name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[doc = "The user's GitHub handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub github: Option<String>,
    #[doc = "The user's Hubspot ID. This is mostly used for internal mapping."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hubspot_contact_id: Option<String>,
    #[doc = "The unique identifier for the user."]
    pub id: uuid::Uuid,
    #[doc = "The image avatar for the user. This is a URL."]
    pub image: String,
    #[doc = "If the user has finished onboarding."]
    #[serde(default)]
    pub is_onboarded: bool,
    #[doc = "If the user is tied to a service account."]
    #[serde(default)]
    pub is_service_account: bool,
    #[doc = "The user's last name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    #[doc = "The name of the user. This is auto populated at first from the authentication provider (if there was a name). It can be updated by the user by updating their `first_name` and `last_name` fields."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The user's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
    #[doc = "The user's Stripe ID. This is mostly used for internal mapping."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stripe_id: Option<String>,
    #[doc = "The date and time the user was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for ExtendedUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ExtendedUser {
    const LENGTH: usize = 20;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(block) = &self.block {
                format!("{:?}", block).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.can_train_on_data).into(),
            if let Some(company) = &self.company {
                format!("{:?}", company).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.deletion_scheduled).into(),
            if let Some(discord) = &self.discord {
                format!("{:?}", discord).into()
            } else {
                String::new().into()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email).into()
            } else {
                String::new().into()
            },
            if let Some(email_verified) = &self.email_verified {
                format!("{:?}", email_verified).into()
            } else {
                String::new().into()
            },
            if let Some(first_name) = &self.first_name {
                format!("{:?}", first_name).into()
            } else {
                String::new().into()
            },
            if let Some(github) = &self.github {
                format!("{:?}", github).into()
            } else {
                String::new().into()
            },
            if let Some(hubspot_contact_id) = &self.hubspot_contact_id {
                format!("{:?}", hubspot_contact_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            self.image.clone().into(),
            format!("{:?}", self.is_onboarded).into(),
            format!("{:?}", self.is_service_account).into(),
            if let Some(last_name) = &self.last_name {
                format!("{:?}", last_name).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
            if let Some(stripe_id) = &self.stripe_id {
                format!("{:?}", stripe_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "block".into(),
            "can_train_on_data".into(),
            "company".into(),
            "created_at".into(),
            "deletion_scheduled".into(),
            "discord".into(),
            "email".into(),
            "email_verified".into(),
            "first_name".into(),
            "github".into(),
            "hubspot_contact_id".into(),
            "id".into(),
            "image".into(),
            "is_onboarded".into(),
            "is_service_account".into(),
            "last_name".into(),
            "name".into(),
            "phone".into(),
            "stripe_id".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExtendedUserResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<ExtendedUser>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ExtendedUserResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ExtendedUserResultsPage {
    type Item = ExtendedUser;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ExtendedUserResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "The response from the `Extrude` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Extrude {}

impl std::fmt::Display for Extrude {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Extrude {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "Extrusion method determining if the extrusion will be part of the existing object or an entirely new object."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ExtrudeMethod {
    #[doc = "Create a new object that is not connected to the object it is extruded from. This will result in two objects after the operation."]
    #[serde(rename = "new")]
    #[display("new")]
    New,
    #[doc = "This extrusion will be part of object it is extruded from. This will result in one object after the operation."]
    #[serde(rename = "merge")]
    #[display("merge")]
    Merge,
}

#[doc = "IDs for the extruded faces."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExtrudedFaceInfo {
    #[doc = "The face made from the original 2D shape being extruded. If the solid is extruded from a shape which already has an ID (e.g. extruding something which was sketched on a face), this doesn't need to be sent."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bottom: Option<uuid::Uuid>,
    #[doc = "Any intermediate sides between the top and bottom."]
    pub sides: Vec<SideFace>,
    #[doc = "Top face of the extrusion (parallel and further away from the original 2D shape being extruded)."]
    pub top: uuid::Uuid,
}

impl std::fmt::Display for ExtrudedFaceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ExtrudedFaceInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(bottom) = &self.bottom {
                format!("{:?}", bottom).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.sides).into(),
            format!("{:?}", self.top).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["bottom".into(), "sides".into(), "top".into()]
    }
}

#[doc = "Possible types of faces which can be extruded from a 3D solid."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ExtrusionFaceCapType {
    #[doc = "Uncapped."]
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[doc = "Capped on top."]
    #[serde(rename = "top")]
    #[display("top")]
    Top,
    #[doc = "Capped below."]
    #[serde(rename = "bottom")]
    #[display("bottom")]
    Bottom,
    #[doc = "Capped on both ends."]
    #[serde(rename = "both")]
    #[display("both")]
    Both,
}

#[doc = "Extrusion face info struct (useful for maintaining mappings between source path segment ids and extrusion faces)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ExtrusionFaceInfo {
    #[doc = "Whether or not this extrusion face is a top/bottom cap face or not. Note that top/bottom cap faces will not have associated curve IDs."]
    pub cap: ExtrusionFaceCapType,
    #[doc = "Path component (curve) UUID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub curve_id: Option<uuid::Uuid>,
    #[doc = "Face uuid."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub face_id: Option<uuid::Uuid>,
}

impl std::fmt::Display for ExtrusionFaceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ExtrusionFaceInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.cap).into(),
            if let Some(curve_id) = &self.curve_id {
                format!("{:?}", curve_id).into()
            } else {
                String::new().into()
            },
            if let Some(face_id) = &self.face_id {
                format!("{:?}", face_id).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["cap".into(), "curve_id".into(), "face_id".into()]
    }
}

#[doc = "Faces and edges id info (most used in identifying geometry in patterned and mirrored objects)."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FaceEdgeInfo {
    #[doc = "The edges of each object."]
    pub edges: Vec<uuid::Uuid>,
    #[doc = "The faces of each object."]
    pub faces: Vec<uuid::Uuid>,
    #[doc = "The UUID of the object."]
    pub object_id: uuid::Uuid,
}

impl std::fmt::Display for FaceEdgeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FaceEdgeInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.edges).into(),
            format!("{:?}", self.faces).into(),
            format!("{:?}", self.object_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edges".into(), "faces".into(), "object_id".into()]
    }
}

#[doc = "The 3D center of mass on the surface"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FaceGetCenter {
    #[doc = "The 3D position on the surface center of mass"]
    pub pos: Point3D,
}

impl std::fmt::Display for FaceGetCenter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FaceGetCenter {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.pos).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["pos".into()]
    }
}

#[doc = "The gradient (dFdu, dFdv) + normal vector on a brep face"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FaceGetGradient {
    #[doc = "dFdu"]
    pub df_du: Point3D,
    #[doc = "dFdv"]
    pub df_dv: Point3D,
    #[doc = "Normal (||dFdu x dFdv||)"]
    pub normal: Point3D,
}

impl std::fmt::Display for FaceGetGradient {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FaceGetGradient {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.df_du).into(),
            format!("{:?}", self.df_dv).into(),
            format!("{:?}", self.normal).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["df_du".into(), "df_dv".into(), "normal".into()]
    }
}

#[doc = "The 3D position on the surface that was evaluated"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FaceGetPosition {
    #[doc = "The 3D position on the surface that was evaluated"]
    pub pos: Point3D,
}

impl std::fmt::Display for FaceGetPosition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FaceGetPosition {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.pos).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["pos".into()]
    }
}

#[doc = "Surface-local planar axes (if available)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FaceIsPlanar {
    #[doc = "plane's origin"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<Point3D>,
    #[doc = "plane's local x-axis"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x_axis: Option<Point3D>,
    #[doc = "plane's local y-axis"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y_axis: Option<Point3D>,
    #[doc = "plane's local z-axis (normal)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub z_axis: Option<Point3D>,
}

impl std::fmt::Display for FaceIsPlanar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FaceIsPlanar {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(origin) = &self.origin {
                format!("{:?}", origin).into()
            } else {
                String::new().into()
            },
            if let Some(x_axis) = &self.x_axis {
                format!("{:?}", x_axis).into()
            } else {
                String::new().into()
            },
            if let Some(y_axis) = &self.y_axis {
                format!("{:?}", y_axis).into()
            } else {
                String::new().into()
            },
            if let Some(z_axis) = &self.z_axis {
                format!("{:?}", z_axis).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "origin".into(),
            "x_axis".into(),
            "y_axis".into(),
            "z_axis".into(),
        ]
    }
}

#[doc = "Unsuccessful Websocket response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FailureWebSocketResponse {
    #[doc = "The errors that occurred."]
    pub errors: Vec<ApiError>,
    #[doc = "Which request this is a response to. If the request was a modeling command, this is the modeling command ID. If no request ID was sent, this will be null."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<uuid::Uuid>,
    #[doc = "Always false"]
    pub success: bool,
}

impl std::fmt::Display for FailureWebSocketResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FailureWebSocketResponse {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.errors).into(),
            if let Some(request_id) = &self.request_id {
                format!("{:?}", request_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.success).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["errors".into(), "request_id".into(), "success".into()]
    }
}

#[doc = "Describes the storage format of an FBX file."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum FbxStorage {
    #[doc = "ASCII FBX encoding."]
    #[serde(rename = "ascii")]
    #[display("ascii")]
    Ascii,
    #[doc = "Binary FBX encoding."]
    #[serde(rename = "binary")]
    #[display("binary")]
    Binary,
}

#[doc = "A file center of mass result."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileCenterOfMass {
    #[doc = "The resulting center of mass."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub center_of_mass: Option<Point3D>,
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The output unit for the center of mass."]
    pub output_unit: UnitLength,
    #[doc = "The source format of the file."]
    pub src_format: FileImportFormat,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for FileCenterOfMass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileCenterOfMass {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(center_of_mass) = &self.center_of_mass {
                format!("{:?}", center_of_mass).into()
            } else {
                String::new().into()
            },
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.src_format).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "center_of_mass".into(),
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "output_unit".into(),
            "src_format".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A file conversion."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The output format of the file conversion."]
    pub output_format: FileExportFormat,
    #[doc = "The output format options of the file conversion."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output_format_options: Option<OutputFormat3D>,
    #[doc = "The converted files (if multiple file conversion), if completed, base64 encoded. The key of the map is the path of the output file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub outputs: Option<std::collections::HashMap<String, base64::Base64Data>>,
    #[doc = "The source format of the file conversion."]
    pub src_format: FileImportFormat,
    #[doc = "The source format options of the file conversion."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub src_format_options: Option<InputFormat3D>,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for FileConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileConversion {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            format!("{:?}", self.output_format).into(),
            if let Some(output_format_options) = &self.output_format_options {
                format!("{:?}", output_format_options).into()
            } else {
                String::new().into()
            },
            if let Some(outputs) = &self.outputs {
                format!("{:?}", outputs).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.src_format).into(),
            if let Some(src_format_options) = &self.src_format_options {
                format!("{:?}", src_format_options).into()
            } else {
                String::new().into()
            },
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "output_format".into(),
            "output_format_options".into(),
            "outputs".into(),
            "src_format".into(),
            "src_format_options".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A file density result."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileDensity {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The resulting density."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub density: Option<f64>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The material mass as denoted by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub material_mass: Option<f64>,
    #[doc = "The material mass unit."]
    pub material_mass_unit: UnitMass,
    #[doc = "The output unit for the density."]
    pub output_unit: UnitDensity,
    #[doc = "The source format of the file."]
    pub src_format: FileImportFormat,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for FileDensity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileDensity {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(density) = &self.density {
                format!("{:?}", density).into()
            } else {
                String::new().into()
            },
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(material_mass) = &self.material_mass {
                format!("{:?}", material_mass).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.material_mass_unit).into(),
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.src_format).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "density".into(),
            "error".into(),
            "id".into(),
            "material_mass".into(),
            "material_mass_unit".into(),
            "output_unit".into(),
            "src_format".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of output file formats."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum FileExportFormat {
    #[doc = "Autodesk Filmbox (FBX) format. <https://en.wikipedia.org/wiki/FBX>"]
    #[serde(rename = "fbx")]
    #[display("fbx")]
    Fbx,
    #[doc = "Binary glTF 2.0.\n\nThis is a single binary with .glb extension.\n\nThis is better if you want a compressed format as opposed to the human readable glTF that lacks compression."]
    #[serde(rename = "glb")]
    #[display("glb")]
    Glb,
    #[doc = "glTF 2.0. Embedded glTF 2.0 (pretty printed).\n\nSingle JSON file with .gltf extension binary data encoded as base64 data URIs.\n\nThe JSON contents are pretty printed.\n\nIt is human readable, single file, and you can view the diff easily in a git commit."]
    #[serde(rename = "gltf")]
    #[display("gltf")]
    Gltf,
    #[doc = "The OBJ file format. <https://en.wikipedia.org/wiki/Wavefront_.obj_file> It may or may not have an an attached material (mtl // mtllib) within the file, but we interact with it as if it does not."]
    #[serde(rename = "obj")]
    #[display("obj")]
    Obj,
    #[doc = "The PLY file format. <https://en.wikipedia.org/wiki/PLY_(file_format)>"]
    #[serde(rename = "ply")]
    #[display("ply")]
    Ply,
    #[doc = "The STEP file format. <https://en.wikipedia.org/wiki/ISO_10303-21>"]
    #[serde(rename = "step")]
    #[display("step")]
    Step,
    #[doc = "The STL file format. <https://en.wikipedia.org/wiki/STL_(file_format)>"]
    #[serde(rename = "stl")]
    #[display("stl")]
    Stl,
}

#[doc = "The valid types of source file formats."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum FileImportFormat {
    #[doc = "Autodesk Filmbox (FBX) format. <https://en.wikipedia.org/wiki/FBX>"]
    #[serde(rename = "fbx")]
    #[display("fbx")]
    Fbx,
    #[doc = "glTF 2.0."]
    #[serde(rename = "gltf")]
    #[display("gltf")]
    Gltf,
    #[doc = "The OBJ file format. <https://en.wikipedia.org/wiki/Wavefront_.obj_file> It may or may not have an an attached material (mtl // mtllib) within the file, but we interact with it as if it does not."]
    #[serde(rename = "obj")]
    #[display("obj")]
    Obj,
    #[doc = "The PLY file format. <https://en.wikipedia.org/wiki/PLY_(file_format)>"]
    #[serde(rename = "ply")]
    #[display("ply")]
    Ply,
    #[doc = "SolidWorks part (SLDPRT) format."]
    #[serde(rename = "sldprt")]
    #[display("sldprt")]
    Sldprt,
    #[doc = "The STEP file format. <https://en.wikipedia.org/wiki/ISO_10303-21>"]
    #[serde(rename = "step")]
    #[display("step")]
    Step,
    #[doc = "The STL file format. <https://en.wikipedia.org/wiki/STL_(file_format)>"]
    #[serde(rename = "stl")]
    #[display("stl")]
    Stl,
}

#[doc = "A file mass result."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileMass {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The resulting mass."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mass: Option<f64>,
    #[doc = "The material density as denoted by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub material_density: Option<f64>,
    #[doc = "The material density unit."]
    pub material_density_unit: UnitDensity,
    #[doc = "The output unit for the mass."]
    pub output_unit: UnitMass,
    #[doc = "The source format of the file."]
    pub src_format: FileImportFormat,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for FileMass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileMass {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(mass) = &self.mass {
                format!("{:?}", mass).into()
            } else {
                String::new().into()
            },
            if let Some(material_density) = &self.material_density {
                format!("{:?}", material_density).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.material_density_unit).into(),
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.src_format).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "mass".into(),
            "material_density".into(),
            "material_density_unit".into(),
            "output_unit".into(),
            "src_format".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A file surface area result."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileSurfaceArea {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The output unit for the surface area."]
    pub output_unit: UnitArea,
    #[doc = "The source format of the file."]
    pub src_format: FileImportFormat,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The resulting surface area."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub surface_area: Option<f64>,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for FileSurfaceArea {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileSurfaceArea {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.src_format).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            if let Some(surface_area) = &self.surface_area {
                format!("{:?}", surface_area).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "output_unit".into(),
            "src_format".into(),
            "started_at".into(),
            "status".into(),
            "surface_area".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "A file volume result."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FileVolume {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The output unit for the volume."]
    pub output_unit: UnitVolume,
    #[doc = "The source format of the file."]
    pub src_format: FileImportFormat,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
    #[doc = "The resulting volume."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volume: Option<f64>,
}

impl std::fmt::Display for FileVolume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FileVolume {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.src_format).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
            if let Some(volume) = &self.volume {
                format!("{:?}", volume).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "output_unit".into(),
            "src_format".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
            "volume".into(),
        ]
    }
}

#[doc = "The response from the `GetEntityType` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GetEntityType {
    #[doc = "The type of the entity."]
    pub entity_type: EntityType,
}

impl std::fmt::Display for GetEntityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for GetEntityType {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_type).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_type".into()]
    }
}

#[doc = "The response from the `GetNumObjects` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GetNumObjects {
    #[doc = "The number of objects in the scene."]
    pub num_objects: u32,
}

impl std::fmt::Display for GetNumObjects {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for GetNumObjects {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.num_objects).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["num_objects".into()]
    }
}

#[doc = "The plane for sketch mode."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GetSketchModePlane {
    #[doc = "The origin."]
    pub origin: Point3D,
    #[doc = "The x axis."]
    pub x_axis: Point3D,
    #[doc = "The y axis."]
    pub y_axis: Point3D,
    #[doc = "The z axis (normal)."]
    pub z_axis: Point3D,
}

impl std::fmt::Display for GetSketchModePlane {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for GetSketchModePlane {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.origin).into(),
            format!("{:?}", self.x_axis).into(),
            format!("{:?}", self.y_axis).into(),
            format!("{:?}", self.z_axis).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "origin".into(),
            "x_axis".into(),
            "y_axis".into(),
            "z_axis".into(),
        ]
    }
}

#[doc = "The global axes."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum GlobalAxis {
    #[doc = "The X axis"]
    #[serde(rename = "x")]
    #[display("x")]
    X,
    #[doc = "The Y axis"]
    #[serde(rename = "y")]
    #[display("y")]
    Y,
    #[doc = "The Z axis"]
    #[serde(rename = "z")]
    #[display("z")]
    Z,
}

#[doc = "Describes the presentation style of the glTF JSON."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum GltfPresentation {
    #[doc = "Condense the JSON into the smallest possible size."]
    #[serde(rename = "compact")]
    #[display("compact")]
    Compact,
    #[doc = "Expand the JSON into a more human readable format.\n\nThis is the default setting."]
    #[serde(rename = "pretty")]
    #[display("pretty")]
    Pretty,
}

#[doc = "Describes the storage format of a glTF 2.0 scene."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum GltfStorage {
    #[doc = "Binary glTF 2.0.\n\nThis is a single binary with .glb extension."]
    #[serde(rename = "binary")]
    #[display("binary")]
    Binary,
    #[doc = "Standard glTF 2.0.\n\nThis is a JSON file with .gltf extension paired with a separate binary blob file with .bin extension."]
    #[serde(rename = "standard")]
    #[display("standard")]
    Standard,
    #[doc = "Embedded glTF 2.0.\n\nSingle JSON file with .gltf extension binary data encoded as base64 data URIs.\n\nThis is the default setting."]
    #[serde(rename = "embedded")]
    #[display("embedded")]
    Embedded,
}

#[doc = "The response from the `HandleMouseDragEnd` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct HandleMouseDragEnd {}

impl std::fmt::Display for HandleMouseDragEnd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for HandleMouseDragEnd {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `HandleMouseDragMove` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct HandleMouseDragMove {}

impl std::fmt::Display for HandleMouseDragMove {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for HandleMouseDragMove {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `HandleMouseDragStart` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct HandleMouseDragStart {}

impl std::fmt::Display for HandleMouseDragStart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for HandleMouseDragStart {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `HighlightSetEntities` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct HighlightSetEntities {}

impl std::fmt::Display for HighlightSetEntities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for HighlightSetEntities {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `HighlightSetEntity` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct HighlightSetEntity {
    #[doc = "The UUID of the entity that was highlighted."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity_id: Option<uuid::Uuid>,
    #[doc = "If the client sent a sequence ID with its request, the backend sends it back."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sequence: Option<u32>,
}

impl std::fmt::Display for HighlightSetEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for HighlightSetEntity {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(entity_id) = &self.entity_id {
                format!("{:?}", entity_id).into()
            } else {
                String::new().into()
            },
            if let Some(sequence) = &self.sequence {
                format!("{:?}", sequence).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_id".into(), "sequence".into()]
    }
}

#[doc = "Representation of an ICE server used for STUN/TURN Used to initiate WebRTC connections based on <https://developer.mozilla.org/en-US/docs/Web/API/RTCIceServer>"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IceServer {
    #[doc = "Credentials for a given TURN server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credential: Option<String>,
    #[doc = "URLs for a given STUN/TURN server. IceServer urls can either be a string or an array of strings But, we choose to always convert to an array of strings for consistency"]
    pub urls: Vec<String>,
    #[doc = "Username for a given TURN server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

impl std::fmt::Display for IceServer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IceServer {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(credential) = &self.credential {
                format!("{:?}", credential).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.urls).into(),
            if let Some(username) = &self.username {
                format!("{:?}", username).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["credential".into(), "urls".into(), "username".into()]
    }
}

#[doc = "The source of an identity provider metadata descriptor."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum IdpMetadataSource {
    #[doc = "A URL to the identity provider metadata descriptor."]
    #[serde(rename = "url")]
    Url {
        #[doc = "The URL of the identity provider metadata descriptor."]
        url: String,
    },
    #[doc = "A base64 encoded XML document containing the identity provider metadata descriptor."]
    #[serde(rename = "base64_encoded_xml")]
    Base64EncodedXml {
        #[doc = "The base64 encoded XML document containing the identity provider metadata descriptor."]
        data: base64::Base64Data,
    },
}

#[doc = "Enum containing the variety of image formats snapshots may be exported to."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ImageFormat {
    #[doc = ".png format"]
    #[serde(rename = "png")]
    #[display("png")]
    Png,
    #[doc = ".jpeg format"]
    #[serde(rename = "jpeg")]
    #[display("jpeg")]
    Jpeg,
}

#[doc = "File to import into the current model. If you are sending binary data for a file, be sure to send the WebSocketRequest as binary/bson, not text/json."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ImportFile {
    #[doc = "The raw bytes of the file"]
    #[serde(
        serialize_with = "serde_bytes::serialize",
        deserialize_with = "serde_bytes::deserialize"
    )]
    pub data: Vec<u8>,
    #[doc = "The file's full path, including file extension."]
    pub path: String,
}

impl std::fmt::Display for ImportFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ImportFile {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.data).into(), self.path.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["data".into(), "path".into()]
    }
}

#[doc = "Data from importing the files"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ImportFiles {
    #[doc = "ID of the imported 3D models within the scene."]
    pub object_id: uuid::Uuid,
}

impl std::fmt::Display for ImportFiles {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ImportFiles {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.object_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["object_id".into()]
    }
}

#[doc = "Data from importing the files"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ImportedGeometry {
    #[doc = "ID of the imported 3D models within the scene."]
    pub id: uuid::Uuid,
    #[doc = "The original file paths that held the geometry."]
    pub value: Vec<String>,
}

impl std::fmt::Display for ImportedGeometry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ImportedGeometry {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.id).into(),
            format!("{:?}", self.value).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["id".into(), "value".into()]
    }
}

#[doc = "Input format specifier."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum InputFormat3D {
    #[doc = "Autodesk Filmbox (FBX) format."]
    #[serde(rename = "fbx")]
    Fbx {},
    #[doc = "Binary glTF 2.0. We refer to this as glTF since that is how our customers refer to it, but this can also import binary glTF (glb)."]
    #[serde(rename = "gltf")]
    Gltf {},
    #[doc = "Wavefront OBJ format."]
    #[serde(rename = "obj")]
    Obj {
        #[doc = "Co-ordinate system of input data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "The units of the input data.\n\nThis is very important for correct scaling and when calculating physics properties like mass, etc.\n\nDefaults to millimeters."]
        units: UnitLength,
    },
    #[doc = "The PLY Polygon File Format."]
    #[serde(rename = "ply")]
    Ply {
        #[doc = "Co-ordinate system of input data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "The units of the input data.\n\nThis is very important for correct scaling and when calculating physics properties like mass, etc.\n\nDefaults to millimeters."]
        units: UnitLength,
    },
    #[doc = "SolidWorks part (SLDPRT) format."]
    #[serde(rename = "sldprt")]
    Sldprt {
        #[doc = "Splits all closed faces into two open faces.\n\nDefaults to `false` but is implicitly `true` when importing into the engine."]
        #[serde(default)]
        split_closed_faces: bool,
    },
    #[doc = "ISO 10303-21 (STEP) format."]
    #[serde(rename = "step")]
    Step {
        #[doc = "Splits all closed faces into two open faces.\n\nDefaults to `false` but is implicitly `true` when importing into the engine."]
        #[serde(default)]
        split_closed_faces: bool,
    },
    #[doc = "*ST**ereo**L**ithography format."]
    #[serde(rename = "stl")]
    Stl {
        #[doc = "Co-ordinate system of input data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "The units of the input data.\n\nThis is very important for correct scaling and when calculating physics properties like mass, etc.\n\nDefaults to millimeters."]
        units: UnitLength,
    },
}

#[doc = "The form for a public inquiry submission."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InquiryForm {
    #[doc = "The company name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[doc = "The email address of the user."]
    pub email: String,
    #[doc = "The first name of the user."]
    pub first_name: String,
    #[doc = "The industry of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub industry: Option<String>,
    #[doc = "The type of inquiry."]
    pub inquiry_type: InquiryType,
    #[doc = "The last name of the user."]
    pub last_name: String,
    #[doc = "The message content."]
    pub message: String,
    #[doc = "The phone number of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: Option<String>,
}

impl std::fmt::Display for InquiryForm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for InquiryForm {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(company) = &self.company {
                format!("{:?}", company).into()
            } else {
                String::new().into()
            },
            self.email.clone().into(),
            self.first_name.clone().into(),
            if let Some(industry) = &self.industry {
                format!("{:?}", industry).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.inquiry_type).into(),
            self.last_name.clone().into(),
            self.message.clone().into(),
            if let Some(phone) = &self.phone {
                format!("{:?}", phone).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "company".into(),
            "email".into(),
            "first_name".into(),
            "industry".into(),
            "inquiry_type".into(),
            "last_name".into(),
            "message".into(),
            "phone".into(),
        ]
    }
}

#[doc = "The type of inquiry."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum InquiryType {
    #[doc = "General inquiry about the service or product."]
    #[serde(rename = "general_inquiry")]
    #[display("general_inquiry")]
    GeneralInquiry,
    #[doc = "Questions related to sales or purchasing."]
    #[serde(rename = "sales_question")]
    #[display("sales_question")]
    SalesQuestion,
    #[doc = "Inquiry from a developer, typically technical in nature."]
    #[serde(rename = "developer_inquiry")]
    #[display("developer_inquiry")]
    DeveloperInquiry,
    #[doc = "Opportunity for partnership or collaboration."]
    #[serde(rename = "partnership_opportunity")]
    #[display("partnership_opportunity")]
    PartnershipOpportunity,
    #[doc = "Other inquiries related to sales that do not fit predefined categories."]
    #[serde(rename = "other_sales_inquiry")]
    #[display("other_sales_inquiry")]
    OtherSalesInquiry,
    #[doc = "Request for technical support or troubleshooting."]
    #[serde(rename = "technical_support")]
    #[display("technical_support")]
    TechnicalSupport,
    #[doc = "Questions or requests related to account management."]
    #[serde(rename = "account_management")]
    #[display("account_management")]
    AccountManagement,
    #[doc = "Other support-related inquiries that do not fit predefined categories."]
    #[serde(rename = "other_support_inquiry")]
    #[display("other_support_inquiry")]
    OtherSupportInquiry,
}

#[doc = "An invoice."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Invoice {
    #[doc = "Final amount due at this time for this invoice.\n\nIf the invoice's total is smaller than the minimum charge amount, for example, or if there is account credit that can be applied to the invoice, the `amount_due` may be 0. If there is a positive `starting_balance` for the invoice (the customer owes money), the `amount_due` will also take that into account. The charge that gets generated for the invoice will be for the amount specified in `amount_due`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount_due: Option<f64>,
    #[doc = "The amount, in USD, that was paid."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount_paid: Option<f64>,
    #[doc = "The amount remaining, in USD, that is due."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount_remaining: Option<f64>,
    #[doc = "Number of payment attempts made for this invoice, from the perspective of the payment retry schedule.\n\nAny payment attempt counts as the first attempt, and subsequently only automatic retries increment the attempt count. In other words, manual payment attempts after the first attempt do not affect the retry schedule."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attempt_count: Option<u64>,
    #[doc = "Whether an attempt has been made to pay the invoice.\n\nAn invoice is not attempted until 1 hour after the `invoice.created` webhook, for example, so you might not want to display that invoice as unpaid to your users."]
    #[serde(default)]
    pub attempted: bool,
    #[doc = "Time at which the object was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
    #[doc = "The email address for the customer. Until the invoice is finalized, this field will equal customer.email. Once the invoice is finalized, this field will no longer be updated."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub customer_email: Option<String>,
    #[doc = "Customer ID. The unique identifier for the customer this invoice belongs to. This is the customer ID in the payments service, not our database customer ID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub customer_id: Option<String>,
    #[doc = "Default payment method."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_payment_method: Option<String>,
    #[doc = "Description of the invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The discounts applied to the invoice. This is an array of discount objects."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discounts: Option<Vec<Discount>>,
    #[doc = "Unique identifier for the object."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The individual line items that make up the invoice.\n\n`lines` is sorted as follows: invoice items in reverse chronological order, followed by the subscription, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lines: Option<Vec<InvoiceLineItem>>,
    #[doc = "Set of key-value pairs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
    #[doc = "A unique, identifying string that appears on emails sent to the customer for this invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<String>,
    #[doc = "Whether payment was successfully collected for this invoice.\n\nAn invoice can be paid (most commonly) with a charge or with credit from the customer's account balance."]
    #[serde(default)]
    pub paid: bool,
    #[doc = "The link to download the PDF for the invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pdf: Option<String>,
    #[doc = "This is the transaction number that appears on email receipts sent for this invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub receipt_number: Option<String>,
    #[doc = "Extra information about an invoice for the customer's credit card statement."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statement_descriptor: Option<String>,
    #[doc = "The status of the invoice, one of `draft`, `open`, `paid`, `uncollectible`, or `void`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<InvoiceStatus>,
    #[doc = "Total of all subscriptions, invoice items, and prorations on the invoice before any invoice level discount or tax is applied.\n\nItem discounts are already incorporated."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subtotal: Option<f64>,
    #[doc = "The amount of tax on this invoice.\n\nThis is the sum of all the tax amounts on this invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tax: Option<f64>,
    #[doc = "Total after discounts and taxes."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total: Option<f64>,
    #[doc = "The URL for the hosted invoice page, which allows customers to view and pay an invoice."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

impl std::fmt::Display for Invoice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Invoice {
    const LENGTH: usize = 25;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(amount_due) = &self.amount_due {
                format!("{:?}", amount_due).into()
            } else {
                String::new().into()
            },
            if let Some(amount_paid) = &self.amount_paid {
                format!("{:?}", amount_paid).into()
            } else {
                String::new().into()
            },
            if let Some(amount_remaining) = &self.amount_remaining {
                format!("{:?}", amount_remaining).into()
            } else {
                String::new().into()
            },
            if let Some(attempt_count) = &self.attempt_count {
                format!("{:?}", attempt_count).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.attempted).into(),
            format!("{:?}", self.created_at).into(),
            if let Some(currency) = &self.currency {
                format!("{:?}", currency).into()
            } else {
                String::new().into()
            },
            if let Some(customer_email) = &self.customer_email {
                format!("{:?}", customer_email).into()
            } else {
                String::new().into()
            },
            if let Some(customer_id) = &self.customer_id {
                format!("{:?}", customer_id).into()
            } else {
                String::new().into()
            },
            if let Some(default_payment_method) = &self.default_payment_method {
                format!("{:?}", default_payment_method).into()
            } else {
                String::new().into()
            },
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            if let Some(discounts) = &self.discounts {
                format!("{:?}", discounts).into()
            } else {
                String::new().into()
            },
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(lines) = &self.lines {
                format!("{:?}", lines).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
            if let Some(number) = &self.number {
                format!("{:?}", number).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.paid).into(),
            if let Some(pdf) = &self.pdf {
                format!("{:?}", pdf).into()
            } else {
                String::new().into()
            },
            if let Some(receipt_number) = &self.receipt_number {
                format!("{:?}", receipt_number).into()
            } else {
                String::new().into()
            },
            if let Some(statement_descriptor) = &self.statement_descriptor {
                format!("{:?}", statement_descriptor).into()
            } else {
                String::new().into()
            },
            if let Some(status) = &self.status {
                format!("{:?}", status).into()
            } else {
                String::new().into()
            },
            if let Some(subtotal) = &self.subtotal {
                format!("{:?}", subtotal).into()
            } else {
                String::new().into()
            },
            if let Some(tax) = &self.tax {
                format!("{:?}", tax).into()
            } else {
                String::new().into()
            },
            if let Some(total) = &self.total {
                format!("{:?}", total).into()
            } else {
                String::new().into()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "amount_due".into(),
            "amount_paid".into(),
            "amount_remaining".into(),
            "attempt_count".into(),
            "attempted".into(),
            "created_at".into(),
            "currency".into(),
            "customer_email".into(),
            "customer_id".into(),
            "default_payment_method".into(),
            "description".into(),
            "discounts".into(),
            "id".into(),
            "lines".into(),
            "metadata".into(),
            "number".into(),
            "paid".into(),
            "pdf".into(),
            "receipt_number".into(),
            "statement_descriptor".into(),
            "status".into(),
            "subtotal".into(),
            "tax".into(),
            "total".into(),
            "url".into(),
        ]
    }
}

#[doc = "An invoice line item."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InvoiceLineItem {
    #[doc = "The amount, in USD."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount: Option<f64>,
    #[doc = "Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
    #[doc = "The description."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "Unique identifier for the object."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The ID of the invoice item associated with this line item if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub invoice_item: Option<String>,
    #[doc = "Set of key-value pairs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
}

impl std::fmt::Display for InvoiceLineItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for InvoiceLineItem {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(amount) = &self.amount {
                format!("{:?}", amount).into()
            } else {
                String::new().into()
            },
            if let Some(currency) = &self.currency {
                format!("{:?}", currency).into()
            } else {
                String::new().into()
            },
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(invoice_item) = &self.invoice_item {
                format!("{:?}", invoice_item).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "amount".into(),
            "currency".into(),
            "description".into(),
            "id".into(),
            "invoice_item".into(),
            "metadata".into(),
        ]
    }
}

#[doc = "An enum representing the possible values of an `Invoice`'s `status` field."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum InvoiceStatus {
    #[doc = "Draft."]
    #[serde(rename = "draft")]
    #[display("draft")]
    Draft,
    #[doc = "Open."]
    #[serde(rename = "open")]
    #[display("open")]
    Open,
    #[doc = "Paid."]
    #[serde(rename = "paid")]
    #[display("paid")]
    Paid,
    #[doc = "Uncollectible."]
    #[serde(rename = "uncollectible")]
    #[display("uncollectible")]
    Uncollectible,
    #[doc = "Void."]
    #[serde(rename = "void")]
    #[display("void")]
    Void,
}

#[doc = "Information about an ip address. Represents geographical and network-related information."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IpAddrInfo {
    #[doc = "Autonomous System Number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub asn: Option<i64>,
    #[doc = "City name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub city: Option<String>,
    #[doc = "Continent code (e.g., \"EU\" for Europe)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub continent_code: Option<String>,
    #[doc = "Country name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
    #[doc = "Two-letter country code (e.g., \"NL\" for Netherlands)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub country_code: Option<String>,
    #[doc = "Three-letter country code (e.g., \"NLD\" for Netherlands)."]
    #[serde(
        rename = "country_code3",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub country_code_3: Option<String>,
    #[doc = "IP address of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<std::net::IpAddr>,
    #[doc = "Flag indicating whether the country is in the European Union."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_in_european_union: Option<bool>,
    #[doc = "Geographic latitude."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latitude: Option<f64>,
    #[doc = "Geographic longitude."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub longitude: Option<f64>,
    #[doc = "Time offset in seconds from UTC."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    #[doc = "Organization name (e.g., \"RIPE NCC\")."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    #[doc = "Postal code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    #[doc = "Name of the region (e.g., \"North Holland\")."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "Region code (e.g., \"NH\" for North Holland)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region_code: Option<String>,
    #[doc = "Timezone (e.g., \"Europe/Amsterdam\")."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
}

impl std::fmt::Display for IpAddrInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IpAddrInfo {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(asn) = &self.asn {
                format!("{:?}", asn).into()
            } else {
                String::new().into()
            },
            if let Some(city) = &self.city {
                format!("{:?}", city).into()
            } else {
                String::new().into()
            },
            if let Some(continent_code) = &self.continent_code {
                format!("{:?}", continent_code).into()
            } else {
                String::new().into()
            },
            if let Some(country) = &self.country {
                format!("{:?}", country).into()
            } else {
                String::new().into()
            },
            if let Some(country_code) = &self.country_code {
                format!("{:?}", country_code).into()
            } else {
                String::new().into()
            },
            if let Some(country_code_3) = &self.country_code_3 {
                format!("{:?}", country_code_3).into()
            } else {
                String::new().into()
            },
            if let Some(ip) = &self.ip {
                format!("{:?}", ip).into()
            } else {
                String::new().into()
            },
            if let Some(is_in_european_union) = &self.is_in_european_union {
                format!("{:?}", is_in_european_union).into()
            } else {
                String::new().into()
            },
            if let Some(latitude) = &self.latitude {
                format!("{:?}", latitude).into()
            } else {
                String::new().into()
            },
            if let Some(longitude) = &self.longitude {
                format!("{:?}", longitude).into()
            } else {
                String::new().into()
            },
            if let Some(offset) = &self.offset {
                format!("{:?}", offset).into()
            } else {
                String::new().into()
            },
            if let Some(organization) = &self.organization {
                format!("{:?}", organization).into()
            } else {
                String::new().into()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{:?}", postal_code).into()
            } else {
                String::new().into()
            },
            if let Some(region) = &self.region {
                format!("{:?}", region).into()
            } else {
                String::new().into()
            },
            if let Some(region_code) = &self.region_code {
                format!("{:?}", region_code).into()
            } else {
                String::new().into()
            },
            if let Some(timezone) = &self.timezone {
                format!("{:?}", timezone).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "asn".into(),
            "city".into(),
            "continent_code".into(),
            "country".into(),
            "country_code".into(),
            "country_code_3".into(),
            "ip".into(),
            "is_in_european_union".into(),
            "latitude".into(),
            "longitude".into(),
            "offset".into(),
            "organization".into(),
            "postal_code".into(),
            "region".into(),
            "region_code".into(),
            "timezone".into(),
        ]
    }
}

#[doc = "Extra params for the completions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct KclCodeCompletionParams {
    #[doc = "The language of the code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    #[doc = "The next indent of the code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_indent: Option<u8>,
    #[doc = "The prompt tokens for the completions."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prompt_tokens: Option<u32>,
    #[doc = "The suffix tokens for the completions."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suffix_tokens: Option<u32>,
    #[doc = "If we should trim by indentation."]
    #[serde(default)]
    pub trim_by_indentation: bool,
}

impl std::fmt::Display for KclCodeCompletionParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for KclCodeCompletionParams {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(language) = &self.language {
                format!("{:?}", language).into()
            } else {
                String::new().into()
            },
            if let Some(next_indent) = &self.next_indent {
                format!("{:?}", next_indent).into()
            } else {
                String::new().into()
            },
            if let Some(prompt_tokens) = &self.prompt_tokens {
                format!("{:?}", prompt_tokens).into()
            } else {
                String::new().into()
            },
            if let Some(suffix_tokens) = &self.suffix_tokens {
                format!("{:?}", suffix_tokens).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.trim_by_indentation).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "language".into(),
            "next_indent".into(),
            "prompt_tokens".into(),
            "suffix_tokens".into(),
            "trim_by_indentation".into(),
        ]
    }
}

#[doc = "A request to generate KCL code completions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct KclCodeCompletionRequest {
    #[doc = "Extra parameters for the completions."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra: Option<KclCodeCompletionParams>,
    #[doc = "The maximum number of tokens that can be generated for the completions. The total length of input tokens and generated tokens is limited by the models context length."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_tokens: Option<u16>,
    #[doc = "How many completion choices to generate for each input message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub n: Option<u8>,
    #[doc = "For GitHub copilot this is the `{org}/{repo}`. This does not do anything yet. But we wanted the same API as GitHub Copilot. It might be used in the future."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nwo: Option<String>,
    #[doc = "The prompt for the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prompt: Option<String>,
    #[doc = "Up to 4 sequences where the API will stop generating further tokens."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stop: Option<Vec<String>>,
    #[doc = "If set, partial message deltas will be sent, like in ChatGPT or OpenAPI. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message."]
    #[serde(default)]
    pub stream: bool,
    #[doc = "The suffix for the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suffix: Option<String>,
    #[doc = "The temperature for the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f64>,
    #[doc = "The top p for the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub top_p: Option<f64>,
}

impl std::fmt::Display for KclCodeCompletionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for KclCodeCompletionRequest {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(extra) = &self.extra {
                format!("{:?}", extra).into()
            } else {
                String::new().into()
            },
            if let Some(max_tokens) = &self.max_tokens {
                format!("{:?}", max_tokens).into()
            } else {
                String::new().into()
            },
            if let Some(n) = &self.n {
                format!("{:?}", n).into()
            } else {
                String::new().into()
            },
            if let Some(nwo) = &self.nwo {
                format!("{:?}", nwo).into()
            } else {
                String::new().into()
            },
            if let Some(prompt) = &self.prompt {
                format!("{:?}", prompt).into()
            } else {
                String::new().into()
            },
            if let Some(stop) = &self.stop {
                format!("{:?}", stop).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.stream).into(),
            if let Some(suffix) = &self.suffix {
                format!("{:?}", suffix).into()
            } else {
                String::new().into()
            },
            if let Some(temperature) = &self.temperature {
                format!("{:?}", temperature).into()
            } else {
                String::new().into()
            },
            if let Some(top_p) = &self.top_p {
                format!("{:?}", top_p).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "extra".into(),
            "max_tokens".into(),
            "n".into(),
            "nwo".into(),
            "prompt".into(),
            "stop".into(),
            "stream".into(),
            "suffix".into(),
            "temperature".into(),
            "top_p".into(),
        ]
    }
}

#[doc = "A response with KCL code completions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct KclCodeCompletionResponse {
    #[doc = "The completions."]
    pub completions: Vec<String>,
}

impl std::fmt::Display for KclCodeCompletionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for KclCodeCompletionResponse {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.completions).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["completions".into()]
    }
}

#[doc = "The response containing the KCL code."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct KclModel {
    #[doc = "The KCL code."]
    pub code: String,
}

impl std::fmt::Display for KclModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for KclModel {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.code.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["code".into()]
    }
}

#[doc = "The response from the `Loft` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Loft {
    #[doc = "The UUID of the newly created solid loft."]
    pub solid_id: uuid::Uuid,
}

impl std::fmt::Display for Loft {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Loft {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.solid_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["solid_id".into()]
    }
}

#[doc = "The response from the `MakeAxesGizmo` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MakeAxesGizmo {}

impl std::fmt::Display for MakeAxesGizmo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MakeAxesGizmo {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `MakeOffsetPath` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MakeOffsetPath {
    #[doc = "If the offset path splits into multiple paths, this will contain the UUIDs of the new paths. If the offset path remains as a single path, this will be empty, and the resulting ID of the (single) new path will be the ID of the `MakeOffsetPath` command."]
    pub entity_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for MakeOffsetPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MakeOffsetPath {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_ids".into()]
    }
}

#[doc = "The response from the `MakePlane` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MakePlane {}

impl std::fmt::Display for MakePlane {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MakePlane {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The mass response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Mass {
    #[doc = "The mass."]
    pub mass: f64,
    #[doc = "The output unit for the mass."]
    pub output_unit: UnitMass,
}

impl std::fmt::Display for Mass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Mass {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.mass).into(),
            format!("{:?}", self.output_unit).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["mass".into(), "output_unit".into()]
    }
}

#[doc = "The Request Method (VERB)\n\nThis type also contains constants for a number of common HTTP methods such as GET, POST, etc.\n\nCurrently includes 8 variants representing the 8 methods defined in [RFC 7230](https://tools.ietf.org/html/rfc7231#section-4.1), plus PATCH, and an Extension variant for all extensions."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Method {
    #[doc = "The `OPTIONS` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.2.1)."]
    #[serde(rename = "OPTIONS")]
    #[display("OPTIONS")]
    Options,
    #[doc = "The `GET` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1)."]
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[doc = "The `POST` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1)."]
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[doc = "The `PUT` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1)."]
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[doc = "The `DELETE` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.5)."]
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
    #[doc = "The `HEAD` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.2)."]
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[doc = "The `TRACE` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3)."]
    #[serde(rename = "TRACE")]
    #[display("TRACE")]
    Trace,
    #[doc = "The `CONNECT` method as defined in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.6)."]
    #[serde(rename = "CONNECT")]
    #[display("CONNECT")]
    Connect,
    #[doc = "The `PATCH` method as defined in [RFC 5789](https://tools.ietf.org/html/rfc5789)."]
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[doc = "A catch all."]
    #[serde(rename = "EXTENSION")]
    #[display("EXTENSION")]
    Extension,
}

#[doc = "The types of messages that can be sent by the client to the server."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum MlCopilotClientMessage {
    #[doc = "Authentication header request."]
    #[serde(rename = "headers")]
    Headers {
        #[doc = "The authentication header."]
        headers: std::collections::HashMap<String, String>,
    },
    #[doc = "The user message, which contains the content of the user's input."]
    #[serde(rename = "user")]
    User {
        #[doc = "The content of the user's message."]
        content: String,
        #[doc = "The current files in the project, if any. This can be used to provide context for the AI. This should be sent in binary format, if the files are not text files, like an imported binary file."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        current_files: Option<std::collections::HashMap<String, Vec<u8>>>,
        #[doc = "The project name, if any. This can be used to associate the message with a specific project."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        project_name: Option<String>,
        #[doc = "The source ranges the user suggested to change. If empty, the content (prompt) will be used and is required."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        source_ranges: Option<Vec<SourceRangePrompt>>,
    },
    #[doc = "The system message, which can be used to set the context or instructions for the AI."]
    #[serde(rename = "system")]
    System {
        #[doc = "The content of the system message."]
        command: MlCopilotSystemCommand,
    },
}

#[doc = "The types of messages that can be sent by the server to the client."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum MlCopilotServerMessage {
    #[doc = "Delta of the response, e.g. a chunk of text/tokens."]
    #[serde(rename = "delta")]
    Delta {
        #[doc = "The delta text, which is a part of the response that is being streamed."]
        delta: String,
    },
    #[doc = "Completed tool call result."]
    #[serde(rename = "tool_output")]
    ToolOutput {
        #[doc = "The result of the tool call."]
        result: MlToolResult,
    },
    #[doc = "Error sent by server."]
    #[serde(rename = "error")]
    Error {
        #[doc = "The error message."]
        detail: String,
    },
    #[doc = "Log / banner text."]
    #[serde(rename = "info")]
    Info {
        #[doc = "The informational text."]
        text: String,
    },
    #[doc = "Assistant reasoning / chain-of-thought (if you expose it)."]
    #[serde(rename = "reasoning")]
    Reasoning {
        #[doc = "The reasoning text, which can be used to explain the AI's thought process."]
        text: String,
    },
    #[doc = "Marks the end of a streamed answer."]
    #[serde(rename = "end_of_stream")]
    EndOfStream {
        #[doc = "The whole response text, which is the final output of the AI. This is only relevant if in copilot mode, where the AI is expected to return the whole response at once."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        whole_response: Option<String>,
    },
}

#[doc = "The type of system command that can be sent to the ML Copilot."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum MlCopilotSystemCommand {
    #[doc = "Reset the conversation state, by creating a new state."]
    #[serde(rename = "new")]
    #[display("new")]
    New,
    #[doc = "Disconnect the client, which can be used to end the session."]
    #[serde(rename = "bye")]
    #[display("bye")]
    Bye,
}

#[doc = "Human feedback on an ML response."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum MlFeedback {
    #[doc = "Thumbs up."]
    #[serde(rename = "thumbs_up")]
    #[display("thumbs_up")]
    ThumbsUp,
    #[doc = "Thumbs down."]
    #[serde(rename = "thumbs_down")]
    #[display("thumbs_down")]
    ThumbsDown,
    #[doc = "Accepted."]
    #[serde(rename = "accepted")]
    #[display("accepted")]
    Accepted,
    #[doc = "Rejected."]
    #[serde(rename = "rejected")]
    #[display("rejected")]
    Rejected,
}

#[doc = "A ML prompt."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MlPrompt {
    #[doc = "When the prompt was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The id for the conversation related to this prompt."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conversation_id: Option<uuid::Uuid>,
    #[doc = "The date and time the ML prompt was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error message if the prompt failed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "Feedback from the user, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub feedback: Option<MlFeedback>,
    #[doc = "The unique identifier for the ML prompt."]
    pub id: uuid::Uuid,
    #[doc = "The KCL version being used."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kcl_version: Option<String>,
    #[doc = "The metadata for the prompt."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<MlPromptMetadata>,
    #[doc = "The version of the model."]
    pub model_version: String,
    #[doc = "The output file. In the case of TextToCad this is a link to a file in a GCP bucket."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output_file: Option<String>,
    #[doc = "The name of the project, if any. This allows us to group prompts together that come from the same project and user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_name: Option<String>,
    #[doc = "The prompt."]
    pub prompt: String,
    #[doc = "When the prompt was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the prompt."]
    pub status: ApiCallStatus,
    #[doc = "The type of prompt."]
    #[serde(rename = "type")]
    pub type_: MlPromptType,
    #[doc = "The date and time the ML prompt was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the ML prompt."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for MlPrompt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MlPrompt {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            if let Some(conversation_id) = &self.conversation_id {
                format!("{:?}", conversation_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            if let Some(feedback) = &self.feedback {
                format!("{:?}", feedback).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(kcl_version) = &self.kcl_version {
                format!("{:?}", kcl_version).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
            self.model_version.clone().into(),
            if let Some(output_file) = &self.output_file {
                format!("{:?}", output_file).into()
            } else {
                String::new().into()
            },
            if let Some(project_name) = &self.project_name {
                format!("{:?}", project_name).into()
            } else {
                String::new().into()
            },
            self.prompt.clone().into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.type_).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "conversation_id".into(),
            "created_at".into(),
            "error".into(),
            "feedback".into(),
            "id".into(),
            "kcl_version".into(),
            "metadata".into(),
            "model_version".into(),
            "output_file".into(),
            "project_name".into(),
            "prompt".into(),
            "started_at".into(),
            "status".into(),
            "type_".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "Metadata for a ML prompt."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MlPromptMetadata {
    #[doc = "Code for the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[doc = "The original source code for the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub original_source_code: Option<String>,
    #[doc = "The source ranges the user suggested to change."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source_ranges: Option<Vec<SourceRangePrompt>>,
}

impl std::fmt::Display for MlPromptMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MlPromptMetadata {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(code) = &self.code {
                format!("{:?}", code).into()
            } else {
                String::new().into()
            },
            if let Some(original_source_code) = &self.original_source_code {
                format!("{:?}", original_source_code).into()
            } else {
                String::new().into()
            },
            if let Some(source_ranges) = &self.source_ranges {
                format!("{:?}", source_ranges).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "code".into(),
            "original_source_code".into(),
            "source_ranges".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MlPromptResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<MlPrompt>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for MlPromptResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for MlPromptResultsPage {
    type Item = MlPrompt;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MlPromptResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "A type of ML prompt."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum MlPromptType {
    #[doc = "Text to CAD."]
    #[serde(rename = "text_to_cad")]
    #[display("text_to_cad")]
    TextToCad,
    #[doc = "Text to KCL."]
    #[serde(rename = "text_to_kcl")]
    #[display("text_to_kcl")]
    TextToKcl,
    #[doc = "Text to KCL iteration."]
    #[serde(rename = "text_to_kcl_iteration")]
    #[display("text_to_kcl_iteration")]
    TextToKclIteration,
    #[doc = "Text to KCL iteration with multiple files."]
    #[serde(rename = "text_to_kcl_multi_file_iteration")]
    #[display("text_to_kcl_multi_file_iteration")]
    TextToKclMultiFileIteration,
}

#[doc = "Responses from tools."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum MlToolResult {
    #[doc = "Response from the `TextToCad` tool."]
    #[serde(rename = "text_to_cad")]
    TextToCad {
        #[doc = "Any error that occurred during the tool execution."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "The output files. Returns a map of the file name to the file contents. The file contents are not encoded since kcl files are not binary."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        outputs: Option<std::collections::HashMap<String, String>>,
        #[doc = "The name of the project, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        project_name: Option<String>,
        #[doc = "The status code of the tool execution."]
        status_code: i32,
    },
    #[doc = "Response from the `EditKclCode` tool."]
    #[serde(rename = "edit_kcl_code")]
    EditKclCode {
        #[doc = "Any error that occurred during the tool execution."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        error: Option<String>,
        #[doc = "The output files. Returns a map of the file name to the file contents. The file contents are not encoded since kcl files are not binary."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        outputs: Option<std::collections::HashMap<String, String>>,
        #[doc = "The name of the project, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        project_name: Option<String>,
        #[doc = "The status code of the tool execution."]
        status_code: i32,
    },
    #[doc = "Mechanical knowledge base response."]
    #[serde(rename = "mechanical_knowledge_base")]
    MechanicalKnowledgeBase {
        #[doc = "The response from the mechanical knowledge base."]
        response: String,
    },
}

#[doc = "Type for modeling-app events"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ModelingAppEventType {
    #[doc = "This event is sent before the modeling app or project is closed. The attachment should contain the contents of the most recent successful compile."]
    #[serde(rename = "successful_compile_before_close")]
    #[display("successful_compile_before_close")]
    SuccessfulCompileBeforeClose,
}

impl std::default::Default for ModelingAppEventType {
    fn default() -> Self {
        ModelingAppEventType::SuccessfulCompileBeforeClose
    }
}

#[doc = "The subscription tiers we offer for the Modeling App to individuals."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ModelingAppIndividualSubscriptionTier {
    #[doc = "The free tier."]
    #[serde(rename = "free")]
    #[display("free")]
    Free,
    #[doc = "The plus tier."]
    #[serde(rename = "plus")]
    #[display("plus")]
    Plus,
    #[doc = "The pro tier."]
    #[serde(rename = "pro")]
    #[display("pro")]
    Pro,
}

#[doc = "The subscription tiers we offer for the Modeling App to organizations."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ModelingAppOrganizationSubscriptionTier {
    #[doc = "The team tier."]
    #[serde(rename = "team")]
    #[display("team")]
    Team,
    #[doc = "The enterprise tier."]
    #[serde(rename = "enterprise")]
    #[display("enterprise")]
    Enterprise,
}

#[doc = "The options for sharable links through the modeling app."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ModelingAppShareLinks {
    #[doc = "Public."]
    #[serde(rename = "public")]
    #[display("public")]
    Public,
    #[doc = "Password protected."]
    #[serde(rename = "password_protected")]
    #[display("password_protected")]
    PasswordProtected,
    #[doc = "Organization only. Links can be made only available to members of the organization."]
    #[serde(rename = "organization_only")]
    #[display("organization_only")]
    OrganizationOnly,
}

#[doc = "A subscription tier we offer for the Modeling App."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ModelingAppSubscriptionTier {
    #[doc = "Annual discount. The percentage off the monthly price if the user pays annually."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annual_discount: Option<f64>,
    #[doc = "A description of the tier."]
    pub description: String,
    #[doc = "The Zoo API endpoints that are included when through an approved zoo tool."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints_included: Option<Vec<ApiEndpoint>>,
    #[doc = "Features that are included in the subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub features: Option<Vec<SubscriptionTierFeature>>,
    #[doc = "The amount of pay-as-you-go API credits the individual or org gets outside the modeling app per month. This re-ups on the 1st of each month. This is equivalent to the monetary value divided by the price of an API credit."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monthly_pay_as_you_go_api_credits: Option<u64>,
    #[doc = "The monetary value of pay-as-you-go API credits the individual or org gets outside the modeling app per month. This re-ups on the 1st of each month."]
    pub monthly_pay_as_you_go_api_credits_monetary_value: f64,
    #[doc = "The name of the tier."]
    pub name: ModelingAppSubscriptionTierName,
    #[doc = "The price of an API credit (meaning 1 credit = 1 minute of API usage)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pay_as_you_go_api_credit_price: Option<f64>,
    #[doc = "The price of the tier per month. If this is for an individual, this is the price they pay. If this is for an organization, this is the price the organization pays per member in the org. This is in USD."]
    pub price: SubscriptionTierPrice,
    #[doc = "The options for sharable links through the modeling app."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub share_links: Option<Vec<ModelingAppShareLinks>>,
    #[doc = "The support tier the subscription provides."]
    pub support_tier: SupportTier,
    #[doc = "The behavior of the users data (can it be used for training, etc)."]
    pub training_data_behavior: SubscriptionTrainingDataBehavior,
    #[doc = "If the tier is offered for an individual or an org."]
    #[serde(rename = "type")]
    pub type_: SubscriptionTierType,
    #[doc = "The Zoo tools that you can call unlimited times with this tier."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zoo_tools_included: Option<Vec<ZooTool>>,
}

impl std::fmt::Display for ModelingAppSubscriptionTier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ModelingAppSubscriptionTier {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(annual_discount) = &self.annual_discount {
                format!("{:?}", annual_discount).into()
            } else {
                String::new().into()
            },
            self.description.clone().into(),
            if let Some(endpoints_included) = &self.endpoints_included {
                format!("{:?}", endpoints_included).into()
            } else {
                String::new().into()
            },
            if let Some(features) = &self.features {
                format!("{:?}", features).into()
            } else {
                String::new().into()
            },
            if let Some(monthly_pay_as_you_go_api_credits) = &self.monthly_pay_as_you_go_api_credits
            {
                format!("{:?}", monthly_pay_as_you_go_api_credits).into()
            } else {
                String::new().into()
            },
            format!(
                "{:?}",
                self.monthly_pay_as_you_go_api_credits_monetary_value
            )
            .into(),
            format!("{:?}", self.name).into(),
            if let Some(pay_as_you_go_api_credit_price) = &self.pay_as_you_go_api_credit_price {
                format!("{:?}", pay_as_you_go_api_credit_price).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.price).into(),
            if let Some(share_links) = &self.share_links {
                format!("{:?}", share_links).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.support_tier).into(),
            format!("{:?}", self.training_data_behavior).into(),
            format!("{:?}", self.type_).into(),
            if let Some(zoo_tools_included) = &self.zoo_tools_included {
                format!("{:?}", zoo_tools_included).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "annual_discount".into(),
            "description".into(),
            "endpoints_included".into(),
            "features".into(),
            "monthly_pay_as_you_go_api_credits".into(),
            "monthly_pay_as_you_go_api_credits_monetary_value".into(),
            "name".into(),
            "pay_as_you_go_api_credit_price".into(),
            "price".into(),
            "share_links".into(),
            "support_tier".into(),
            "training_data_behavior".into(),
            "type_".into(),
            "zoo_tools_included".into(),
        ]
    }
}

#[doc = "An enum representing a Modeling App subscription tier name."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ModelingAppSubscriptionTierName {
    #[doc = "The free tier."]
    #[serde(rename = "free")]
    #[display("free")]
    Free,
    #[doc = "The plus tier."]
    #[serde(rename = "plus")]
    #[display("plus")]
    Plus,
    #[doc = "The pro tier."]
    #[serde(rename = "pro")]
    #[display("pro")]
    Pro,
    #[doc = "The team tier."]
    #[serde(rename = "team")]
    #[display("team")]
    Team,
    #[doc = "The enterprise tier."]
    #[serde(rename = "enterprise")]
    #[display("enterprise")]
    Enterprise,
}

#[doc = "Commands that the KittyCAD engine can execute."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum ModelingCmd {
    #[doc = "Evaluates the position of a path in one shot (engine utility for kcl executor)"]
    #[serde(rename = "engine_util_evaluate_path")]
    EngineUtilEvaluatePath {
        #[doc = "The path in json form (the serialized result of the kcl Sketch/Path object"]
        path_json: String,
        #[doc = "The evaluation parameter (path curve parameter in the normalized domain [0, 1])"]
        t: f64,
    },
    #[doc = "Start a new path."]
    #[serde(rename = "start_path")]
    StartPath {},
    #[doc = "Move the path's \"pen\". If you're in sketch mode, these coordinates are in the local coordinate system, not the world's coordinate system. For example, say you're sketching on the plane {x: (1,0,0), y: (0,1,0), origin: (0, 0, 50)}. In other words, the plane 50 units above the default XY plane. Then, moving the pen to (1, 1, 0) with this command uses local coordinates. So, it would move the pen to (1, 1, 50) in global coordinates."]
    #[serde(rename = "move_path_pen")]
    MovePathPen {
        #[doc = "The ID of the command which created the path."]
        path: uuid::Uuid,
        #[doc = "Where the path's pen should be."]
        to: Point3D,
    },
    #[doc = "Extend a path by adding a new segment which starts at the path's \"pen\". If no \"pen\" location has been set before (via `MovePen`), then the pen is at the origin."]
    #[serde(rename = "extend_path")]
    ExtendPath {
        #[doc = "The ID of the command which created the path."]
        path: uuid::Uuid,
        #[doc = "Segment to append to the path. This segment will implicitly begin at the current \"pen\" location."]
        segment: PathSegment,
    },
    #[doc = "Command for extruding a solid 2d."]
    #[serde(rename = "extrude")]
    Extrude {
        #[doc = "How far off the plane to extrude"]
        distance: f64,
        #[doc = "Should the extrusion create a new object or be part of the existing object."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extrude_method: Option<ExtrudeMethod>,
        #[doc = "Which IDs should the new faces have? If this isn't given, the engine will generate IDs."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        faces: Option<ExtrudedFaceInfo>,
        #[doc = "Should the extrusion also extrude in the opposite direction? If so, this specifies its distance."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        opposite: Option<String>,
        #[doc = "Which sketch to extrude. Must be a closed 2D solid."]
        target: uuid::Uuid,
    },
    #[doc = "Command for twist extruding a solid 2d."]
    #[serde(rename = "twist_extrude")]
    TwistExtrude {
        #[doc = "Angle step interval (converted to whole number degrees and bounded between 4 and 90)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        angle_step_size: Option<Angle>,
        #[doc = "Center to twist about (relative to 2D sketch)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        center_2d: Option<Point2D>,
        #[doc = "How far off the plane to extrude"]
        distance: f64,
        #[doc = "Which IDs should the new faces have? If this isn't given, the engine will generate IDs."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        faces: Option<ExtrudedFaceInfo>,
        #[doc = "Which sketch to extrude. Must be a closed 2D solid."]
        target: uuid::Uuid,
        #[doc = "The twisted surface loft tolerance"]
        tolerance: f64,
        #[doc = "Total rotation of the section"]
        total_rotation_angle: Angle,
    },
    #[doc = "Extrude the object along a path."]
    #[serde(rename = "sweep")]
    Sweep {
        #[doc = "What is this sweep relative to?"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        relative_to: Option<RelativeTo>,
        #[doc = "If true, the sweep will be broken up into sub-sweeps (extrusions, revolves, sweeps) based on the trajectory path components."]
        sectional: bool,
        #[doc = "Which sketch to sweep. Must be a closed 2D solid."]
        target: uuid::Uuid,
        #[doc = "The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero)."]
        tolerance: f64,
        #[doc = "Path along which to sweep."]
        trajectory: uuid::Uuid,
    },
    #[doc = "Command for revolving a solid 2d."]
    #[serde(rename = "revolve")]
    Revolve {
        #[doc = "The signed angle of revolution (in degrees, must be <= 360 in either direction)"]
        angle: Angle,
        #[doc = "The axis of the extrusion (taken from the origin)"]
        axis: Point3D,
        #[doc = "If true, the axis is interpreted within the 2D space of the solid 2D's plane"]
        axis_is_2d: bool,
        #[doc = "Should the revolution also revolve in the opposite direction along the given axis? If so, this specifies its angle."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        opposite: Option<String>,
        #[doc = "The origin of the extrusion axis"]
        origin: Point3D,
        #[doc = "Which sketch to revolve. Must be a closed 2D solid."]
        target: uuid::Uuid,
        #[doc = "The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero)."]
        tolerance: f64,
    },
    #[doc = "Command for shelling a solid3d face"]
    #[serde(rename = "solid3d_shell_face")]
    Solid3DShellFace {
        #[doc = "Which faces to remove, leaving only the shell."]
        face_ids: Vec<uuid::Uuid>,
        #[doc = "If true, the Solid3D is made hollow instead of removing the selected faces"]
        #[serde(default)]
        hollow: bool,
        #[doc = "Which Solid3D is being shelled."]
        object_id: uuid::Uuid,
        #[doc = "How thick the shell should be. Smaller values mean a thinner shell."]
        shell_thickness: f64,
    },
    #[doc = "Command for revolving a solid 2d about a brep edge"]
    #[serde(rename = "revolve_about_edge")]
    RevolveAboutEdge {
        #[doc = "The signed angle of revolution (in degrees, must be <= 360 in either direction)"]
        angle: Angle,
        #[doc = "The edge to use as the axis of revolution, must be linear and lie in the plane of the solid"]
        edge_id: uuid::Uuid,
        #[doc = "Should the revolution also revolve in the opposite direction along the given axis? If so, this specifies its angle."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        opposite: Option<String>,
        #[doc = "Which sketch to revolve. Must be a closed 2D solid."]
        target: uuid::Uuid,
        #[doc = "The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero)."]
        tolerance: f64,
    },
    #[doc = "Command for lofting sections to create a solid"]
    #[serde(rename = "loft")]
    Loft {
        #[doc = "This can be set to override the automatically determined topological base curve, which is usually the first section encountered."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        base_curve_index: Option<u32>,
        #[doc = "Attempt to approximate rational curves (such as arcs) using a bezier. This will remove banding around interpolations between arcs and non-arcs.  It may produce errors in other scenarios Over time, this field won't be necessary."]
        bez_approximate_rational: bool,
        #[doc = "The closed section curves to create a lofted solid from. Currently, these must be Solid2Ds"]
        section_ids: Vec<uuid::Uuid>,
        #[doc = "Tolerance"]
        tolerance: f64,
        #[doc = "Degree of the interpolation. Must be greater than zero. For example, use 2 for quadratic, or 3 for cubic interpolation in the V direction."]
        v_degree: u32,
    },
    #[doc = "Closes a path, converting it to a 2D solid."]
    #[serde(rename = "close_path")]
    ClosePath {
        #[doc = "Which path to close."]
        path_id: uuid::Uuid,
    },
    #[doc = "Camera drag started."]
    #[serde(rename = "camera_drag_start")]
    CameraDragStart {
        #[doc = "The type of camera drag interaction."]
        interaction: CameraDragInteractionType,
        #[doc = "The initial mouse position."]
        window: Point2D,
    },
    #[doc = "Camera drag continued."]
    #[serde(rename = "camera_drag_move")]
    CameraDragMove {
        #[doc = "The type of camera drag interaction."]
        interaction: CameraDragInteractionType,
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sequence: Option<u32>,
        #[doc = "The current mouse position."]
        window: Point2D,
    },
    #[doc = "Camera drag ended"]
    #[serde(rename = "camera_drag_end")]
    CameraDragEnd {
        #[doc = "The type of camera drag interaction."]
        interaction: CameraDragInteractionType,
        #[doc = "The final mouse position."]
        window: Point2D,
    },
    #[doc = "Gets the default camera's camera settings"]
    #[serde(rename = "default_camera_get_settings")]
    DefaultCameraGetSettings {},
    #[doc = "Gets the default camera's view state"]
    #[serde(rename = "default_camera_get_view")]
    DefaultCameraGetView {},
    #[doc = "Sets the default camera's view state"]
    #[serde(rename = "default_camera_set_view")]
    DefaultCameraSetView {
        #[doc = "Camera view state"]
        view: CameraViewState,
    },
    #[doc = "Change what the default camera is looking at."]
    #[serde(rename = "default_camera_look_at")]
    DefaultCameraLookAt {
        #[doc = "What the camera is looking at. Center of the camera's field of vision"]
        center: Point3D,
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sequence: Option<u32>,
        #[doc = "Which way is \"up\", from the camera's point of view."]
        up: Point3D,
        #[doc = "Where the camera is positioned"]
        vantage: Point3D,
    },
    #[doc = "Change what the default camera is looking at."]
    #[serde(rename = "default_camera_perspective_settings")]
    DefaultCameraPerspectiveSettings {
        #[doc = "What the camera is looking at. Center of the camera's field of vision"]
        center: Point3D,
        #[doc = "The field of view angle in the y direction, in degrees."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        fov_y: Option<f64>,
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sequence: Option<u32>,
        #[doc = "Which way is \"up\", from the camera's point of view."]
        up: Point3D,
        #[doc = "Where the camera is positioned"]
        vantage: Point3D,
        #[doc = "The distance to the far clipping plane."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        z_far: Option<f64>,
        #[doc = "The distance to the near clipping plane."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        z_near: Option<f64>,
    },
    #[doc = "Adjust zoom of the default camera."]
    #[serde(rename = "default_camera_zoom")]
    DefaultCameraZoom {
        #[doc = "Move the camera forward along the vector it's looking at, by this magnitudedefaultCameraZoom. Basically, how much should the camera move forward by."]
        magnitude: f64,
    },
    #[doc = "Export a sketch to a file."]
    #[serde(rename = "export2d")]
    Export2D {
        #[doc = "IDs of the entities to be exported."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The file format to export to."]
        format: OutputFormat2D,
    },
    #[doc = "Export the scene to a file."]
    #[serde(rename = "export3d")]
    Export3D {
        #[doc = "IDs of the entities to be exported. If this is empty, then all entities are exported."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The file format to export to."]
        format: OutputFormat3D,
    },
    #[doc = "Export the scene to a file."]
    #[serde(rename = "export")]
    Export {
        #[doc = "IDs of the entities to be exported. If this is empty, then all entities are exported."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The file format to export to."]
        format: OutputFormat3D,
    },
    #[doc = "What is this entity's parent?"]
    #[serde(rename = "entity_get_parent_id")]
    EntityGetParentId {
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "How many children does the entity have?"]
    #[serde(rename = "entity_get_num_children")]
    EntityGetNumChildren {
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "What is the UUID of this entity's n-th child?"]
    #[serde(rename = "entity_get_child_uuid")]
    EntityGetChildUuid {
        #[doc = "Index into the entity's list of children."]
        child_index: u32,
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "What are all UUIDs of this entity's children?"]
    #[serde(rename = "entity_get_all_child_uuids")]
    EntityGetAllChildUuids {
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "What are all UUIDs of all the paths sketched on top of this entity?"]
    #[serde(rename = "entity_get_sketch_paths")]
    EntityGetSketchPaths {
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "What is the distance between these two entities?"]
    #[serde(rename = "entity_get_distance")]
    EntityGetDistance {
        #[doc = "Type of distance to be measured."]
        distance_type: DistanceType,
        #[doc = "ID of the first entity being queried."]
        #[serde(rename = "entity_id1")]
        entity_id_1: uuid::Uuid,
        #[doc = "ID of the second entity being queried."]
        #[serde(rename = "entity_id2")]
        entity_id_2: uuid::Uuid,
    },
    #[doc = "Create a pattern using this entity by specifying the transform for each desired repetition. Transformations are performed in the following order (first applied to last applied): scale, rotate, translate."]
    #[serde(rename = "entity_clone")]
    EntityClone {
        #[doc = "ID of the entity being cloned."]
        entity_id: uuid::Uuid,
    },
    #[doc = "Create a pattern using this entity by specifying the transform for each desired repetition. Transformations are performed in the following order (first applied to last applied): scale, rotate, translate."]
    #[serde(rename = "entity_linear_pattern_transform")]
    EntityLinearPatternTransform {
        #[doc = "ID of the entity being copied."]
        entity_id: uuid::Uuid,
        #[doc = "How to transform each repeated solid. The 0th transform will create the first copy of the entity. The total number of (optional) repetitions equals the size of this list."]
        #[serde(default)]
        transform: Vec<Transform>,
        #[doc = "Alternatively, you could set this key instead. If you want to use multiple transforms per item. If this is non-empty then the `transform` key must be empty, and vice-versa."]
        #[serde(default)]
        transforms: Vec<Vec<Transform>>,
    },
    #[doc = "Create a linear pattern using this entity."]
    #[serde(rename = "entity_linear_pattern")]
    EntityLinearPattern {
        #[doc = "Axis along which to make the copies. For Solid2d patterns, the z component is ignored."]
        axis: Point3D,
        #[doc = "ID of the entity being copied."]
        entity_id: uuid::Uuid,
        #[doc = "Number of repetitions to make."]
        num_repetitions: u32,
        #[doc = "Spacing between repetitions."]
        spacing: f64,
    },
    #[doc = "Create a circular pattern using this entity."]
    #[serde(rename = "entity_circular_pattern")]
    EntityCircularPattern {
        #[doc = "Arc angle (in degrees) to place repetitions along."]
        arc_degrees: f64,
        #[doc = "Axis around which to make the copies. For Solid2d patterns, this is ignored."]
        axis: Point3D,
        #[doc = "Point around which to make the copies. For Solid2d patterns, the z component is ignored."]
        center: Point3D,
        #[doc = "ID of the entity being copied."]
        entity_id: uuid::Uuid,
        #[doc = "Number of repetitions to make."]
        num_repetitions: u32,
        #[doc = "Whether or not to rotate the objects as they are copied."]
        rotate_duplicates: bool,
    },
    #[doc = "Create a helix using the input cylinder and other specified parameters."]
    #[serde(rename = "entity_make_helix")]
    EntityMakeHelix {
        #[doc = "ID of the cylinder."]
        cylinder_id: uuid::Uuid,
        #[doc = "Is the helix rotation clockwise?"]
        is_clockwise: bool,
        #[doc = "Length of the helix."]
        length: f64,
        #[doc = "Number of revolutions."]
        revolutions: f64,
        #[doc = "Start angle."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        start_angle: Option<Angle>,
    },
    #[doc = "Create a helix using the specified parameters."]
    #[serde(rename = "entity_make_helix_from_params")]
    EntityMakeHelixFromParams {
        #[doc = "Axis of the helix. The helix will be created around and in the direction of this axis."]
        axis: Point3D,
        #[doc = "Center of the helix at the base of the helix."]
        center: Point3D,
        #[doc = "Is the helix rotation clockwise?"]
        is_clockwise: bool,
        #[doc = "Length of the helix."]
        length: f64,
        #[doc = "Radius of the helix."]
        radius: f64,
        #[doc = "Number of revolutions."]
        revolutions: f64,
        #[doc = "Start angle."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        start_angle: Option<Angle>,
    },
    #[doc = "Create a helix using the specified parameters."]
    #[serde(rename = "entity_make_helix_from_edge")]
    EntityMakeHelixFromEdge {
        #[doc = "Edge about which to make the helix."]
        edge_id: uuid::Uuid,
        #[doc = "Is the helix rotation clockwise?"]
        is_clockwise: bool,
        #[doc = "Length of the helix. If None, the length of the edge will be used instead."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        length: Option<f64>,
        #[doc = "Radius of the helix."]
        radius: f64,
        #[doc = "Number of revolutions."]
        revolutions: f64,
        #[doc = "Start angle."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        start_angle: Option<Angle>,
    },
    #[doc = "Mirror the input entities over the specified axis. (Currently only supports sketches)"]
    #[serde(rename = "entity_mirror")]
    EntityMirror {
        #[doc = "Axis to use as mirror."]
        axis: Point3D,
        #[doc = "ID of the mirror entities."]
        ids: Vec<uuid::Uuid>,
        #[doc = "Point through which the mirror axis passes."]
        point: Point3D,
    },
    #[doc = "Mirror the input entities over the specified edge. (Currently only supports sketches)"]
    #[serde(rename = "entity_mirror_across_edge")]
    EntityMirrorAcrossEdge {
        #[doc = "The edge to use as the mirror axis, must be linear and lie in the plane of the solid"]
        edge_id: uuid::Uuid,
        #[doc = "ID of the mirror entities."]
        ids: Vec<uuid::Uuid>,
    },
    #[doc = "Modifies the selection by simulating a \"mouse click\" at the given x,y window coordinate Returns ID of whatever was selected."]
    #[serde(rename = "select_with_point")]
    SelectWithPoint {
        #[doc = "Where in the window was selected"]
        selected_at_window: Point2D,
        #[doc = "What entity was selected?"]
        selection_type: SceneSelectionType,
    },
    #[doc = "Adds one or more entities (by UUID) to the selection."]
    #[serde(rename = "select_add")]
    SelectAdd {
        #[doc = "Which entities to select"]
        entities: Vec<uuid::Uuid>,
    },
    #[doc = "Removes one or more entities (by UUID) from the selection."]
    #[serde(rename = "select_remove")]
    SelectRemove {
        #[doc = "Which entities to unselect"]
        entities: Vec<uuid::Uuid>,
    },
    #[doc = "Removes all of the Objects in the scene"]
    #[serde(rename = "scene_clear_all")]
    SceneClearAll {},
    #[doc = "Replaces current selection with these entities (by UUID)."]
    #[serde(rename = "select_replace")]
    SelectReplace {
        #[doc = "Which entities to select"]
        entities: Vec<uuid::Uuid>,
    },
    #[doc = "Changes the current highlighted entity to whichever one is at the given window coordinate. If there's no entity at this location, clears the highlight."]
    #[serde(rename = "highlight_set_entity")]
    HighlightSetEntity {
        #[doc = "Coordinates of the window being clicked"]
        selected_at_window: Point2D,
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sequence: Option<u32>,
    },
    #[doc = "Changes the current highlighted entity to these entities."]
    #[serde(rename = "highlight_set_entities")]
    HighlightSetEntities {
        #[doc = "Highlight these entities."]
        entities: Vec<uuid::Uuid>,
    },
    #[doc = "Create a new annotation"]
    #[serde(rename = "new_annotation")]
    NewAnnotation {
        #[doc = "What type of annotation to create."]
        annotation_type: AnnotationType,
        #[doc = "If true, any existing drawables within the obj will be replaced (the object will be reset)"]
        clobber: bool,
        #[doc = "What should the annotation contain?"]
        options: AnnotationOptions,
    },
    #[doc = "Update an annotation"]
    #[serde(rename = "update_annotation")]
    UpdateAnnotation {
        #[doc = "Which annotation to update"]
        annotation_id: uuid::Uuid,
        #[doc = "If any of these fields are set, they will overwrite the previous options for the annotation."]
        options: AnnotationOptions,
    },
    #[doc = "Changes visibility of scene-wide edge lines on brep solids"]
    #[serde(rename = "edge_lines_visible")]
    EdgeLinesVisible {
        #[doc = "Whether or not the edge lines should be hidden."]
        hidden: bool,
    },
    #[doc = "Hide or show an object"]
    #[serde(rename = "object_visible")]
    ObjectVisible {
        #[doc = "Whether or not the object should be hidden."]
        hidden: bool,
        #[doc = "Which object to change"]
        object_id: uuid::Uuid,
    },
    #[doc = "Bring an object to the front of the scene"]
    #[serde(rename = "object_bring_to_front")]
    ObjectBringToFront {
        #[doc = "Which object to change"]
        object_id: uuid::Uuid,
    },
    #[doc = "Set the material properties of an object"]
    #[serde(rename = "object_set_material_params_pbr")]
    ObjectSetMaterialParamsPbr {
        #[doc = "Ambient Occlusion of the new material"]
        ambient_occlusion: f64,
        #[doc = "Color of the new material"]
        color: Color,
        #[doc = "Metalness of the new material"]
        metalness: f64,
        #[doc = "Which object to change"]
        object_id: uuid::Uuid,
        #[doc = "Roughness of the new material"]
        roughness: f64,
    },
    #[doc = "What type of entity is this?"]
    #[serde(rename = "get_entity_type")]
    GetEntityType {
        #[doc = "ID of the entity being queried."]
        entity_id: uuid::Uuid,
    },
    #[doc = "Gets all faces which use the given edge."]
    #[serde(rename = "solid3d_get_all_edge_faces")]
    Solid3DGetAllEdgeFaces {
        #[doc = "Which edge you want the faces of."]
        edge_id: uuid::Uuid,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Add a hole to a Solid2d object before extruding it."]
    #[serde(rename = "solid2d_add_hole")]
    Solid2DAddHole {
        #[doc = "The id of the path to use as the inner profile (hole)."]
        hole_id: uuid::Uuid,
        #[doc = "Which object to add the hole to."]
        object_id: uuid::Uuid,
    },
    #[doc = "Gets all edges which are opposite the given edge, across all possible faces."]
    #[serde(rename = "solid3d_get_all_opposite_edges")]
    Solid3DGetAllOppositeEdges {
        #[doc = "If given, only faces parallel to this vector will be considered."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        along_vector: Option<Point3D>,
        #[doc = "Which edge you want the opposites of."]
        edge_id: uuid::Uuid,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Gets the edge opposite the given edge, along the given face."]
    #[serde(rename = "solid3d_get_opposite_edge")]
    Solid3DGetOppositeEdge {
        #[doc = "Which edge you want the opposite of."]
        edge_id: uuid::Uuid,
        #[doc = "Which face is used to figure out the opposite edge?"]
        face_id: uuid::Uuid,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Gets the next adjacent edge for the given edge, along the given face."]
    #[serde(rename = "solid3d_get_next_adjacent_edge")]
    Solid3DGetNextAdjacentEdge {
        #[doc = "Which edge you want the opposite of."]
        edge_id: uuid::Uuid,
        #[doc = "Which face is used to figure out the opposite edge?"]
        face_id: uuid::Uuid,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Gets the previous adjacent edge for the given edge, along the given face."]
    #[serde(rename = "solid3d_get_prev_adjacent_edge")]
    Solid3DGetPrevAdjacentEdge {
        #[doc = "Which edge you want the opposite of."]
        edge_id: uuid::Uuid,
        #[doc = "Which face is used to figure out the opposite edge?"]
        face_id: uuid::Uuid,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Gets the shared edge between these two faces if it exists"]
    #[serde(rename = "solid3d_get_common_edge")]
    Solid3DGetCommonEdge {
        #[doc = "The faces being queried"]
        face_ids: Vec<uuid::Uuid>,
        #[doc = "Which object is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Fillets the given edge with the specified radius."]
    #[serde(rename = "solid3d_fillet_edge")]
    Solid3DFilletEdge {
        #[doc = "How to apply the cut."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        cut_type: Option<CutType>,
        #[doc = "Which edge you want to fillet."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        edge_id: Option<uuid::Uuid>,
        #[doc = "Which edges you want to fillet."]
        #[serde(default)]
        edge_ids: Vec<uuid::Uuid>,
        #[doc = "What IDs should the resulting faces have? If you've only passed one edge ID, its ID will be the command ID used to send this command, and this field should be empty. If you've passed `n` IDs (to fillet `n` edges), then this should be length `n-1`, and the first edge will use the command ID used to send this command."]
        #[serde(default)]
        extra_face_ids: Vec<uuid::Uuid>,
        #[doc = "Which object is being filletted."]
        object_id: uuid::Uuid,
        #[doc = "The radius of the fillet. Measured in length (using the same units that the current sketch uses). Must be positive (i.e. greater than zero)."]
        radius: f64,
        #[doc = "Which cutting algorithm to use."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        strategy: Option<CutStrategy>,
        #[doc = "The maximum acceptable surface gap computed between the filleted surfaces. Must be positive (i.e. greater than zero)."]
        tolerance: f64,
    },
    #[doc = "Determines whether a brep face is planar and returns its surface-local planar axes if so"]
    #[serde(rename = "face_is_planar")]
    FaceIsPlanar {
        #[doc = "Which face is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Determines a position on a brep face evaluated by parameters u,v"]
    #[serde(rename = "face_get_position")]
    FaceGetPosition {
        #[doc = "Which face is being queried."]
        object_id: uuid::Uuid,
        #[doc = "The 2D parameter-space u,v position to evaluate the surface at"]
        uv: Point2D,
    },
    #[doc = "Obtains the surface \"center of mass\""]
    #[serde(rename = "face_get_center")]
    FaceGetCenter {
        #[doc = "Which face is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Determines the gradient (dFdu, dFdv) + normal vector on a brep face evaluated by parameters u,v"]
    #[serde(rename = "face_get_gradient")]
    FaceGetGradient {
        #[doc = "Which face is being queried."]
        object_id: uuid::Uuid,
        #[doc = "The 2D parameter-space u,v position to evaluate the surface at"]
        uv: Point2D,
    },
    #[doc = "Send object to front or back."]
    #[serde(rename = "send_object")]
    SendObject {
        #[doc = "Bring to front = true, send to back = false."]
        front: bool,
        #[doc = "Which object is being changed."]
        object_id: uuid::Uuid,
    },
    #[doc = "Set opacity of the entity."]
    #[serde(rename = "entity_set_opacity")]
    EntitySetOpacity {
        #[doc = "Which entity is being changed."]
        entity_id: uuid::Uuid,
        #[doc = "How transparent should it be? 0 or lower is totally transparent. 1 or greater is totally opaque."]
        opacity: f64,
    },
    #[doc = "Fade entity in or out."]
    #[serde(rename = "entity_fade")]
    EntityFade {
        #[doc = "How many seconds the animation should take."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        duration_seconds: Option<f64>,
        #[doc = "Which entity is being changed."]
        entity_id: uuid::Uuid,
        #[doc = "Fade in = true, fade out = false."]
        fade_in: bool,
    },
    #[doc = "Make a new plane"]
    #[serde(rename = "make_plane")]
    MakePlane {
        #[doc = "If true, any existing drawables within the obj will be replaced (the object will be reset)"]
        clobber: bool,
        #[doc = "If true, the plane will be created but hidden initially."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hide: Option<bool>,
        #[doc = "Origin of the plane"]
        origin: Point3D,
        #[doc = "What should the plane's span/extent? When rendered visually, this is both the width and height along X and Y axis respectively."]
        size: f64,
        #[doc = "What should the plane's X axis be?"]
        x_axis: Point3D,
        #[doc = "What should the plane's Y axis be?"]
        y_axis: Point3D,
    },
    #[doc = "Set the color of a plane."]
    #[serde(rename = "plane_set_color")]
    PlaneSetColor {
        #[doc = "What color it should be."]
        color: Color,
        #[doc = "Which plane is being changed."]
        plane_id: uuid::Uuid,
    },
    #[doc = "Set the current tool."]
    #[serde(rename = "set_tool")]
    SetTool {
        #[doc = "What tool should be active."]
        tool: SceneToolType,
    },
    #[doc = "Send a mouse move event"]
    #[serde(rename = "mouse_move")]
    MouseMove {
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sequence: Option<u32>,
        #[doc = "Where the mouse is"]
        window: Point2D,
    },
    #[doc = "Send a mouse click event Updates modified/selected entities."]
    #[serde(rename = "mouse_click")]
    MouseClick {
        #[doc = "Where the mouse is"]
        window: Point2D,
    },
    #[doc = "Disable sketch mode. If you are sketching on a face, be sure to not disable sketch mode until you have extruded. Otherwise, your object will not be fused with the face."]
    #[serde(rename = "sketch_mode_disable")]
    SketchModeDisable {},
    #[doc = "Get the plane for sketch mode."]
    #[serde(rename = "get_sketch_mode_plane")]
    GetSketchModePlane {},
    #[doc = "Get the plane for sketch mode."]
    #[serde(rename = "curve_set_constraint")]
    CurveSetConstraint {
        #[doc = "Which constraint to apply."]
        constraint_bound: PathComponentConstraintBound,
        #[doc = "What part of the curve should be constrained."]
        constraint_type: PathComponentConstraintType,
        #[doc = "Which curve to constrain."]
        object_id: uuid::Uuid,
    },
    #[doc = "Sketch on some entity (e.g. a plane, a face)."]
    #[serde(rename = "enable_sketch_mode")]
    EnableSketchMode {
        #[doc = "Should the camera move at all?"]
        adjust_camera: bool,
        #[doc = "Should we animate or snap for the camera transition?"]
        animated: bool,
        #[doc = "Which entity to sketch on."]
        entity_id: uuid::Uuid,
        #[doc = "Should the camera use orthographic projection? In other words, should an object's size in the rendered image stay constant regardless of its distance from the camera."]
        ortho: bool,
        #[doc = "If provided, ensures that the normal of the sketch plane must be aligned with this supplied normal (otherwise the camera position will be used to infer the normal to point towards the viewer)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        planar_normal: Option<Point3D>,
    },
    #[doc = "Sets whether or not changes to the scene or its objects will be done as a \"dry run\" In a dry run, successful commands won't actually change the model. This is useful for catching errors before actually making the change."]
    #[serde(rename = "enable_dry_run")]
    EnableDryRun {},
    #[doc = "Sets whether or not changes to the scene or its objects will be done as a \"dry run\" In a dry run, successful commands won't actually change the model. This is useful for catching errors before actually making the change."]
    #[serde(rename = "disable_dry_run")]
    DisableDryRun {},
    #[doc = "Set the background color of the scene."]
    #[serde(rename = "set_background_color")]
    SetBackgroundColor {
        #[doc = "The color to set the background to."]
        color: Color,
    },
    #[doc = "Set the properties of the tool lines for the scene."]
    #[serde(rename = "set_current_tool_properties")]
    SetCurrentToolProperties {
        #[doc = "The color to set the tool line to."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        color: Option<Color>,
    },
    #[doc = "Set the default system properties used when a specific property isn't set."]
    #[serde(rename = "set_default_system_properties")]
    SetDefaultSystemProperties {
        #[doc = "The default system color."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        color: Option<Color>,
    },
    #[doc = "Get type of the given curve."]
    #[serde(rename = "curve_get_type")]
    CurveGetType {
        #[doc = "Which curve to query."]
        curve_id: uuid::Uuid,
    },
    #[doc = "Get control points of the given curve."]
    #[serde(rename = "curve_get_control_points")]
    CurveGetControlPoints {
        #[doc = "Which curve to query."]
        curve_id: uuid::Uuid,
    },
    #[doc = "Project an entity on to a plane."]
    #[serde(rename = "project_entity_to_plane")]
    ProjectEntityToPlane {
        #[doc = "Which entity to project (vertex or edge)."]
        entity_id: uuid::Uuid,
        #[doc = "Which plane to project entity_id onto."]
        plane_id: uuid::Uuid,
        #[doc = "If true: the projected points are returned in the plane_id's coordinate system, else: the projected points are returned in the world coordinate system."]
        use_plane_coords: bool,
    },
    #[doc = "Project a list of points on to a plane."]
    #[serde(rename = "project_points_to_plane")]
    ProjectPointsToPlane {
        #[doc = "The id of the plane used for the projection."]
        plane_id: uuid::Uuid,
        #[doc = "The list of points that will be projected."]
        points: Vec<Point3D>,
        #[doc = "If true: the projected points are returned in the plane_id's coordinate sysetm. else: the projected points are returned in the world coordinate system."]
        use_plane_coords: bool,
    },
    #[doc = "Take a snapshot of the current view."]
    #[serde(rename = "take_snapshot")]
    TakeSnapshot {
        #[doc = "What image format to return."]
        format: ImageFormat,
    },
    #[doc = "Add a gizmo showing the axes."]
    #[serde(rename = "make_axes_gizmo")]
    MakeAxesGizmo {
        #[doc = "If true, any existing drawables within the obj will be replaced (the object will be reset)"]
        clobber: bool,
        #[doc = "If true, axes gizmo will be placed in the corner of the screen. If false, it will be placed at the origin of the scene."]
        gizmo_mode: bool,
    },
    #[doc = "Query the given path."]
    #[serde(rename = "path_get_info")]
    PathGetInfo {
        #[doc = "Which path to query"]
        path_id: uuid::Uuid,
    },
    #[doc = "Obtain curve ids for vertex ids"]
    #[serde(rename = "path_get_curve_uuids_for_vertices")]
    PathGetCurveUuidsForVertices {
        #[doc = "Which path to query"]
        path_id: uuid::Uuid,
        #[doc = "IDs of the vertices for which to obtain curve ids from"]
        vertex_ids: Vec<uuid::Uuid>,
    },
    #[doc = "Obtain curve id by index"]
    #[serde(rename = "path_get_curve_uuid")]
    PathGetCurveUuid {
        #[doc = "IDs of the vertices for which to obtain curve ids from"]
        index: u32,
        #[doc = "Which path to query"]
        path_id: uuid::Uuid,
    },
    #[doc = "Obtain vertex ids for a path"]
    #[serde(rename = "path_get_vertex_uuids")]
    PathGetVertexUuids {
        #[doc = "Which path to query"]
        path_id: uuid::Uuid,
    },
    #[doc = "Obtain the sketch target id (if the path was drawn in sketchmode) for a path"]
    #[serde(rename = "path_get_sketch_target_uuid")]
    PathGetSketchTargetUuid {
        #[doc = "Which path to query"]
        path_id: uuid::Uuid,
    },
    #[doc = "Start dragging the mouse."]
    #[serde(rename = "handle_mouse_drag_start")]
    HandleMouseDragStart {
        #[doc = "The mouse position."]
        window: Point2D,
    },
    #[doc = "Continue dragging the mouse."]
    #[serde(rename = "handle_mouse_drag_move")]
    HandleMouseDragMove {
        #[doc = "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sequence: Option<u32>,
        #[doc = "The mouse position."]
        window: Point2D,
    },
    #[doc = "Stop dragging the mouse."]
    #[serde(rename = "handle_mouse_drag_end")]
    HandleMouseDragEnd {
        #[doc = "The mouse position."]
        window: Point2D,
    },
    #[doc = "Remove scene objects."]
    #[serde(rename = "remove_scene_objects")]
    RemoveSceneObjects {
        #[doc = "Objects to remove."]
        object_ids: Vec<uuid::Uuid>,
    },
    #[doc = "Utility method. Performs both a ray cast and projection to plane-local coordinates. Returns the plane coordinates for the given window coordinates."]
    #[serde(rename = "plane_intersect_and_project")]
    PlaneIntersectAndProject {
        #[doc = "The plane you're intersecting against."]
        plane_id: uuid::Uuid,
        #[doc = "Window coordinates where the ray cast should be aimed."]
        window: Point2D,
    },
    #[doc = "Find the start and end of a curve."]
    #[serde(rename = "curve_get_end_points")]
    CurveGetEndPoints {
        #[doc = "ID of the curve being queried."]
        curve_id: uuid::Uuid,
    },
    #[doc = "Reconfigure the stream."]
    #[serde(rename = "reconfigure_stream")]
    ReconfigureStream {
        #[doc = "Video feed's constant bitrate (CBR)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bitrate: Option<u32>,
        #[doc = "Frames per second."]
        fps: u32,
        #[doc = "Height of the stream."]
        height: u32,
        #[doc = "Width of the stream."]
        width: u32,
    },
    #[doc = "Import files to the current model."]
    #[serde(rename = "import_files")]
    ImportFiles {
        #[doc = "Files to import."]
        files: Vec<ImportFile>,
        #[doc = "Input file format."]
        format: InputFormat3D,
    },
    #[doc = "Set the units of the scene. For all following commands, the units will be interpreted as the given units. Any previously executed commands will not be affected or have their units changed. They will remain in the units they were originally executed in."]
    #[serde(rename = "set_scene_units")]
    SetSceneUnits {
        #[doc = "Which units the scene uses."]
        unit: UnitLength,
    },
    #[doc = "Get the mass of entities in the scene or the default scene."]
    #[serde(rename = "mass")]
    Mass {
        #[doc = "IDs of the entities to get the mass of. If this is empty, then the default scene is included in the mass."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The material density."]
        material_density: f64,
        #[doc = "The material density unit."]
        material_density_unit: UnitDensity,
        #[doc = "The output unit for the mass."]
        output_unit: UnitMass,
    },
    #[doc = "Get the density of entities in the scene or the default scene."]
    #[serde(rename = "density")]
    Density {
        #[doc = "IDs of the entities to get the density of. If this is empty, then the default scene is included in the density."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The material mass."]
        material_mass: f64,
        #[doc = "The material mass unit."]
        material_mass_unit: UnitMass,
        #[doc = "The output unit for the density."]
        output_unit: UnitDensity,
    },
    #[doc = "Get the volume of entities in the scene or the default scene."]
    #[serde(rename = "volume")]
    Volume {
        #[doc = "IDs of the entities to get the volume of. If this is empty, then the default scene is included in the volume."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The output unit for the volume."]
        output_unit: UnitVolume,
    },
    #[doc = "Get the center of mass of entities in the scene or the default scene."]
    #[serde(rename = "center_of_mass")]
    CenterOfMass {
        #[doc = "IDs of the entities to get the center of mass of. If this is empty, then the default scene is included in the center of mass."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The output unit for the center of mass."]
        output_unit: UnitLength,
    },
    #[doc = "Get the surface area of entities in the scene or the default scene."]
    #[serde(rename = "surface_area")]
    SurfaceArea {
        #[doc = "IDs of the entities to get the surface area of. If this is empty, then the default scene is included in the surface area."]
        entity_ids: Vec<uuid::Uuid>,
        #[doc = "The output unit for the surface area."]
        output_unit: UnitArea,
    },
    #[doc = "Focus the default camera upon an object in the scene."]
    #[serde(rename = "default_camera_focus_on")]
    DefaultCameraFocusOn {
        #[doc = "UUID of object to focus on."]
        uuid: uuid::Uuid,
    },
    #[doc = "When you select some entity with the current tool, what should happen to the entity?"]
    #[serde(rename = "set_selection_type")]
    SetSelectionType {
        #[doc = "What type of selection should occur when you select something?"]
        selection_type: SceneSelectionType,
    },
    #[doc = "What kind of entities can be selected?"]
    #[serde(rename = "set_selection_filter")]
    SetSelectionFilter {
        #[doc = "If vector is empty, clear all filters. If vector is non-empty, only the given entity types will be selectable."]
        filter: Vec<EntityType>,
    },
    #[doc = "Use orthographic projection."]
    #[serde(rename = "default_camera_set_orthographic")]
    DefaultCameraSetOrthographic {},
    #[doc = "Use perspective projection."]
    #[serde(rename = "default_camera_set_perspective")]
    DefaultCameraSetPerspective {
        #[doc = "If this is not given, use the same parameters as last time the perspective camera was used."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        parameters: Option<PerspectiveCameraParameters>,
    },
    #[doc = "Updates the camera to center to the center of the current selection (or the origin if nothing is selected)"]
    #[serde(rename = "default_camera_center_to_selection")]
    DefaultCameraCenterToSelection {
        #[doc = "Dictates whether or not the camera position should be adjusted during this operation If no movement is requested, the camera will orbit around the new center from its current position"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        camera_movement: Option<CameraMovement>,
    },
    #[doc = "Updates the camera to center to the center of the current scene's bounds"]
    #[serde(rename = "default_camera_center_to_scene")]
    DefaultCameraCenterToScene {
        #[doc = "Dictates whether or not the camera position should be adjusted during this operation If no movement is requested, the camera will orbit around the new center from its current position"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        camera_movement: Option<CameraMovement>,
    },
    #[doc = "Fit the view to the specified object(s)."]
    #[serde(rename = "zoom_to_fit")]
    ZoomToFit {
        #[doc = "Whether or not to animate the camera movement."]
        #[serde(default)]
        animated: bool,
        #[doc = "Which objects to fit camera to; if empty, fit to all non-default objects. Defaults to empty vector."]
        #[serde(default)]
        object_ids: Vec<uuid::Uuid>,
        #[doc = "How much to pad the view frame by, as a fraction of the object(s) bounding box size. Negative padding will crop the view of the object proportionally. e.g. padding = 0.2 means the view will span 120% of the object(s) bounding box, and padding = -0.2 means the view will span 80% of the object(s) bounding box."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<f64>,
    },
    #[doc = "Looks along the normal of the specified face (if it is planar!), and fits the view to it."]
    #[serde(rename = "orient_to_face")]
    OrientToFace {
        #[doc = "Whether or not to animate the camera movement. (Animation is currently not supported.)"]
        #[serde(default)]
        animated: bool,
        #[doc = "Which face to orient camera to. If the face is not planar, no action will occur."]
        face_id: uuid::Uuid,
        #[doc = "How much to pad the view frame by, as a fraction of the face bounding box size. Negative padding will crop the view of the face proportionally. e.g. padding = 0.2 means the view will span 120% of the face bounding box, and padding = -0.2 means the view will span 80% of the face bounding box."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<f64>,
    },
    #[doc = "Fit the view to the scene with an isometric view."]
    #[serde(rename = "view_isometric")]
    ViewIsometric {
        #[doc = "How much to pad the view frame by, as a fraction of the object(s) bounding box size. Negative padding will crop the view of the object proportionally. e.g. padding = 0.2 means the view will span 120% of the object(s) bounding box, and padding = -0.2 means the view will span 80% of the object(s) bounding box."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<f64>,
    },
    #[doc = "Get a concise description of all of an extrusion's faces."]
    #[serde(rename = "solid3d_get_extrusion_face_info")]
    Solid3DGetExtrusionFaceInfo {
        #[doc = "Any edge that lies on the extrusion base path."]
        edge_id: uuid::Uuid,
        #[doc = "The Solid3d object whose extrusion is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Get a concise description of all of solids edges."]
    #[serde(rename = "solid3d_get_adjacency_info")]
    Solid3DGetAdjacencyInfo {
        #[doc = "Any edge that lies on the extrusion base path."]
        edge_id: uuid::Uuid,
        #[doc = "The Solid3d object whose info is being queried."]
        object_id: uuid::Uuid,
    },
    #[doc = "Clear the selection"]
    #[serde(rename = "select_clear")]
    SelectClear {},
    #[doc = "Find all IDs of selected entities"]
    #[serde(rename = "select_get")]
    SelectGet {},
    #[doc = "Get the number of objects in the scene"]
    #[serde(rename = "get_num_objects")]
    GetNumObjects {},
    #[doc = "Set the transform of an object."]
    #[serde(rename = "set_object_transform")]
    SetObjectTransform {
        #[doc = "Id of the object whose transform is to be set."]
        object_id: uuid::Uuid,
        #[doc = "List of transforms to be applied to the object."]
        transforms: Vec<ComponentTransform>,
    },
    #[doc = "Create a new solid from combining other smaller solids. In other words, every part of the input solids will be included in the output solid."]
    #[serde(rename = "boolean_union")]
    BooleanUnion {
        #[doc = "Which solids to union together. Cannot be empty."]
        solid_ids: Vec<uuid::Uuid>,
        #[doc = "The maximum acceptable surface gap computed between the joined solids. Must be positive (i.e. greater than zero)."]
        tolerance: f64,
    },
    #[doc = "Create a new solid from intersecting several other solids. In other words, the part of the input solids where they all overlap will be the output solid."]
    #[serde(rename = "boolean_intersection")]
    BooleanIntersection {
        #[doc = "Which solids to intersect together"]
        solid_ids: Vec<uuid::Uuid>,
        #[doc = "The maximum acceptable surface gap computed between the joined solids. Must be positive (i.e. greater than zero)."]
        tolerance: f64,
    },
    #[doc = "Create a new solid from subtracting several other solids. The 'target' is what will be cut from. The 'tool' is what will be cut out from 'target'."]
    #[serde(rename = "boolean_subtract")]
    BooleanSubtract {
        #[doc = "Geometry to cut out from."]
        target_ids: Vec<uuid::Uuid>,
        #[doc = "The maximum acceptable surface gap computed between the target and the solids cut out from it. Must be positive (i.e. greater than zero)."]
        tolerance: f64,
        #[doc = "Will be cut out from the 'target'."]
        tool_ids: Vec<uuid::Uuid>,
    },
    #[doc = "Make a new path by offsetting an object by a given distance. The new path's ID will be the ID of this command."]
    #[serde(rename = "make_offset_path")]
    MakeOffsetPath {
        #[doc = "If the object is a solid, this is the ID of the face to base the offset on. If given, and `object_id` refers to a solid, then this face on the solid will be offset. If given but `object_id` doesn't refer to a solid, responds with an error. If not given, then `object_id` itself will be offset directly."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        face_id: Option<uuid::Uuid>,
        #[doc = "The object that will be offset (can be a path, sketch, or a solid)"]
        object_id: uuid::Uuid,
        #[doc = "The distance to offset the path (positive for outset, negative for inset)"]
        offset: f64,
    },
    #[doc = "Add a hole to a closed path by offsetting it a uniform distance inward."]
    #[serde(rename = "add_hole_from_offset")]
    AddHoleFromOffset {
        #[doc = "The closed path to add a hole to."]
        object_id: uuid::Uuid,
        #[doc = "The distance to offset the path (positive for outset, negative for inset)"]
        offset: f64,
    },
    #[doc = "Align the grid with a plane or a planar face."]
    #[serde(rename = "set_grid_reference_plane")]
    SetGridReferencePlane {
        #[doc = "The grid to be moved."]
        grid_id: uuid::Uuid,
        #[doc = "The plane or face that the grid will be aligned to. If a face, it must be planar to succeed."]
        reference_id: uuid::Uuid,
    },
    #[doc = "Set the scale of the grid lines in the video feed."]
    #[serde(rename = "set_grid_scale")]
    SetGridScale {
        #[doc = "Which units the `value` field uses."]
        units: UnitLength,
        #[doc = "Distance between grid lines represents this much distance."]
        value: f64,
    },
    #[doc = "Set the grid lines to auto scale. The grid will get larger the further you zoom out, and smaller the more you zoom in."]
    #[serde(rename = "set_grid_auto_scale")]
    SetGridAutoScale {},
}

#[doc = "A graphics command submitted to the KittyCAD engine via the Modeling API."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ModelingCmdReq {
    #[doc = "Which command to submit to the Kittycad engine."]
    pub cmd: ModelingCmd,
    #[doc = "ID of command being submitted."]
    pub cmd_id: uuid::Uuid,
}

impl std::fmt::Display for ModelingCmdReq {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ModelingCmdReq {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.cmd).into(),
            format!("{:?}", self.cmd_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["cmd".into(), "cmd_id".into()]
    }
}

#[doc = "Successful Websocket response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ModelingSessionData {
    #[doc = "ID of the API call this modeling session is using. Useful for tracing and debugging."]
    pub api_call_id: String,
}

impl std::fmt::Display for ModelingSessionData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ModelingSessionData {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.api_call_id.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["api_call_id".into()]
    }
}

#[doc = "The response from the `MouseClick` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MouseClick {
    #[doc = "Entities that are modified."]
    pub entities_modified: Vec<uuid::Uuid>,
    #[doc = "Entities that are selected."]
    pub entities_selected: Vec<uuid::Uuid>,
}

impl std::fmt::Display for MouseClick {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MouseClick {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.entities_modified).into(),
            format!("{:?}", self.entities_selected).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entities_modified".into(), "entities_selected".into()]
    }
}

#[doc = "The response from the `MouseMove` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MouseMove {}

impl std::fmt::Display for MouseMove {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MouseMove {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `MovePathPen` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct MovePathPen {}

impl std::fmt::Display for MovePathPen {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for MovePathPen {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `NewAnnotation` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NewAnnotation {}

impl std::fmt::Display for NewAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for NewAnnotation {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "Information about an OAuth 2.0 client."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Oauth2ClientInfo {
    #[doc = "Value used for [CSRF](https://tools.ietf.org/html/rfc6749#section-10.12) protection via the `state` parameter."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csrf_token: Option<String>,
    #[doc = "Nonce required for OIDC flows."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oidc_nonce: Option<String>,
    #[doc = "Code Verifier used for [PKCE]((https://tools.ietf.org/html/rfc7636)) protection via the `code_verifier` parameter. The value must have a minimum length of 43 characters and a maximum length of 128 characters.  Each character must be ASCII alphanumeric or one of the characters \"-\" / \".\" / \"_\" / \"~\"."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pkce_code_verifier: Option<String>,
    #[doc = "The URL for consent."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

impl std::fmt::Display for Oauth2ClientInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Oauth2ClientInfo {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(csrf_token) = &self.csrf_token {
                format!("{:?}", csrf_token).into()
            } else {
                String::new().into()
            },
            if let Some(oidc_nonce) = &self.oidc_nonce {
                format!("{:?}", oidc_nonce).into()
            } else {
                String::new().into()
            },
            if let Some(pkce_code_verifier) = &self.pkce_code_verifier {
                format!("{:?}", pkce_code_verifier).into()
            } else {
                String::new().into()
            },
            if let Some(url) = &self.url {
                format!("{:?}", url).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "csrf_token".into(),
            "oidc_nonce".into(),
            "pkce_code_verifier".into(),
            "url".into(),
        ]
    }
}

#[doc = "An OAuth 2.0 Grant Type. These are documented here: <https://oauth.net/2/grant-types/>."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Oauth2GrantType {
    #[doc = "An OAuth 2.0 Device Authorization Grant."]
    #[serde(rename = "urn:ietf:params:oauth:grant-type:device_code")]
    #[display("urn:ietf:params:oauth:grant-type:device_code")]
    UrnIetfParamsOauthGrantTypeDeviceCode,
}

impl std::default::Default for Oauth2GrantType {
    fn default() -> Self {
        Oauth2GrantType::UrnIetfParamsOauthGrantTypeDeviceCode
    }
}

#[doc = "The response from the `ObjectBringToFront` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ObjectBringToFront {}

impl std::fmt::Display for ObjectBringToFront {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ObjectBringToFront {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `ObjectSetMaterialParamsPbr` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ObjectSetMaterialParamsPbr {}

impl std::fmt::Display for ObjectSetMaterialParamsPbr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ObjectSetMaterialParamsPbr {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `ObjectVisible` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ObjectVisible {}

impl std::fmt::Display for ObjectVisible {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ObjectVisible {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "A successful response from a modeling command. This can be one of several types of responses, depending on the command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum OkModelingCmdResponse {
    #[doc = "An empty response, used for any command that does not explicitly have a response defined here."]
    #[serde(rename = "empty")]
    Empty {},
    #[serde(rename = "engine_util_evaluate_path")]
    EngineUtilEvaluatePath {
        #[doc = "The response of the `EngineUtilEvaluatePath` endpoint"]
        data: EngineUtilEvaluatePath,
    },
    #[serde(rename = "start_path")]
    StartPath {
        #[doc = "The response from the `StartPath` endpoint."]
        data: StartPath,
    },
    #[serde(rename = "move_path_pen")]
    MovePathPen {
        #[doc = "The response from the `MovePathPen` endpoint."]
        data: MovePathPen,
    },
    #[serde(rename = "extend_path")]
    ExtendPath {
        #[doc = "The response from the `ExtendPath` endpoint."]
        data: ExtendPath,
    },
    #[serde(rename = "extrude")]
    Extrude {
        #[doc = "The response from the `Extrude` endpoint."]
        data: Extrude,
    },
    #[serde(rename = "twist_extrude")]
    TwistExtrude {
        #[doc = "The response from the `TwistExtrude` endpoint."]
        data: TwistExtrude,
    },
    #[serde(rename = "sweep")]
    Sweep {
        #[doc = "The response from the `Sweep` endpoint."]
        data: Sweep,
    },
    #[serde(rename = "revolve")]
    Revolve {
        #[doc = "The response from the `Revolve` endpoint."]
        data: Revolve,
    },
    #[serde(rename = "solid3d_shell_face")]
    Solid3DShellFace {
        #[doc = "The response from the `Solid3dShellFace` endpoint."]
        data: Solid3DShellFace,
    },
    #[serde(rename = "revolve_about_edge")]
    RevolveAboutEdge {
        #[doc = "The response from the `RevolveAboutEdge` endpoint."]
        data: RevolveAboutEdge,
    },
    #[serde(rename = "camera_drag_start")]
    CameraDragStart {
        #[doc = "The response from the `CameraDragStart` endpoint."]
        data: CameraDragStart,
    },
    #[serde(rename = "default_camera_look_at")]
    DefaultCameraLookAt {
        #[doc = "The response from the `DefaultCameraLookAt` endpoint."]
        data: DefaultCameraLookAt,
    },
    #[serde(rename = "default_camera_perspective_settings")]
    DefaultCameraPerspectiveSettings {
        #[doc = "The response from the `DefaultCameraPerspectiveSettings` endpoint."]
        data: DefaultCameraPerspectiveSettings,
    },
    #[serde(rename = "select_add")]
    SelectAdd {
        #[doc = "The response from the `SelectAdd` endpoint."]
        data: SelectAdd,
    },
    #[serde(rename = "select_remove")]
    SelectRemove {
        #[doc = "The response from the `SelectRemove` endpoint."]
        data: SelectRemove,
    },
    #[serde(rename = "scene_clear_all")]
    SceneClearAll {
        #[doc = "The response from the `SceneClearAll` endpoint."]
        data: SceneClearAll,
    },
    #[serde(rename = "select_replace")]
    SelectReplace {
        #[doc = "The response from the `SelectReplace` endpoint."]
        data: SelectReplace,
    },
    #[serde(rename = "highlight_set_entities")]
    HighlightSetEntities {
        #[doc = "The response from the `HighlightSetEntities` endpoint."]
        data: HighlightSetEntities,
    },
    #[serde(rename = "new_annotation")]
    NewAnnotation {
        #[doc = "The response from the `NewAnnotation` endpoint."]
        data: NewAnnotation,
    },
    #[serde(rename = "update_annotation")]
    UpdateAnnotation {
        #[doc = "The response from the `UpdateAnnotation` endpoint."]
        data: UpdateAnnotation,
    },
    #[serde(rename = "edge_lines_visible")]
    EdgeLinesVisible {
        #[doc = "The response from the `EdgeLinesVisible` endpoint."]
        data: EdgeLinesVisible,
    },
    #[serde(rename = "object_visible")]
    ObjectVisible {
        #[doc = "The response from the `ObjectVisible` endpoint."]
        data: ObjectVisible,
    },
    #[serde(rename = "object_bring_to_front")]
    ObjectBringToFront {
        #[doc = "The response from the `ObjectBringToFront` endpoint."]
        data: ObjectBringToFront,
    },
    #[serde(rename = "object_set_material_params_pbr")]
    ObjectSetMaterialParamsPbr {
        #[doc = "The response from the `ObjectSetMaterialParamsPbr` endpoint."]
        data: ObjectSetMaterialParamsPbr,
    },
    #[serde(rename = "solid2d_add_hole")]
    Solid2DAddHole {
        #[doc = "The response from the `Solid2dAddHole` endpoint."]
        data: Solid2DAddHole,
    },
    #[serde(rename = "solid3d_fillet_edge")]
    Solid3DFilletEdge {
        #[doc = "The response from the `Solid3dFilletEdge` endpoint."]
        data: Solid3DFilletEdge,
    },
    #[serde(rename = "send_object")]
    SendObject {
        #[doc = "The response from the `SendObject` endpoint."]
        data: SendObject,
    },
    #[serde(rename = "entity_set_opacity")]
    EntitySetOpacity {
        #[doc = "The response from the `EntitySetOpacity` endpoint."]
        data: EntitySetOpacity,
    },
    #[serde(rename = "entity_fade")]
    EntityFade {
        #[doc = "The response from the `EntityFade` endpoint."]
        data: EntityFade,
    },
    #[serde(rename = "make_plane")]
    MakePlane {
        #[doc = "The response from the `MakePlane` endpoint."]
        data: MakePlane,
    },
    #[serde(rename = "plane_set_color")]
    PlaneSetColor {
        #[doc = "The response from the `PlaneSetColor` endpoint."]
        data: PlaneSetColor,
    },
    #[serde(rename = "set_tool")]
    SetTool {
        #[doc = "The response from the `SetTool` endpoint."]
        data: SetTool,
    },
    #[serde(rename = "mouse_move")]
    MouseMove {
        #[doc = "The response from the `MouseMove` endpoint."]
        data: MouseMove,
    },
    #[serde(rename = "sketch_mode_disable")]
    SketchModeDisable {
        #[doc = "The response from the `SketchModeDisable` endpoint."]
        data: SketchModeDisable,
    },
    #[serde(rename = "enable_dry_run")]
    EnableDryRun {
        #[doc = "The response from the `EnableDryRun` endpoint."]
        data: EnableDryRun,
    },
    #[serde(rename = "disable_dry_run")]
    DisableDryRun {
        #[doc = "The response from the `DisableDryRun` endpoint."]
        data: DisableDryRun,
    },
    #[serde(rename = "curve_set_constraint")]
    CurveSetConstraint {
        #[doc = "The response from the `CurveSetConstraint` endpoint."]
        data: CurveSetConstraint,
    },
    #[serde(rename = "enable_sketch_mode")]
    EnableSketchMode {
        #[doc = "The response from the `EnableSketchMode` endpoint."]
        data: EnableSketchMode,
    },
    #[serde(rename = "set_background_color")]
    SetBackgroundColor {
        #[doc = "The response from the `SetBackgroundColor` endpoint."]
        data: SetBackgroundColor,
    },
    #[serde(rename = "set_current_tool_properties")]
    SetCurrentToolProperties {
        #[doc = "The response from the `SetCurrentToolProperties` endpoint."]
        data: SetCurrentToolProperties,
    },
    #[serde(rename = "set_default_system_properties")]
    SetDefaultSystemProperties {
        #[doc = "The response from the `SetDefaultSystemProperties` endpoint."]
        data: SetDefaultSystemProperties,
    },
    #[serde(rename = "make_axes_gizmo")]
    MakeAxesGizmo {
        #[doc = "The response from the `MakeAxesGizmo` endpoint."]
        data: MakeAxesGizmo,
    },
    #[serde(rename = "handle_mouse_drag_start")]
    HandleMouseDragStart {
        #[doc = "The response from the `HandleMouseDragStart` endpoint."]
        data: HandleMouseDragStart,
    },
    #[serde(rename = "handle_mouse_drag_move")]
    HandleMouseDragMove {
        #[doc = "The response from the `HandleMouseDragMove` endpoint."]
        data: HandleMouseDragMove,
    },
    #[serde(rename = "handle_mouse_drag_end")]
    HandleMouseDragEnd {
        #[doc = "The response from the `HandleMouseDragEnd` endpoint."]
        data: HandleMouseDragEnd,
    },
    #[serde(rename = "remove_scene_objects")]
    RemoveSceneObjects {
        #[doc = "The response from the `RemoveSceneObjects` endpoint."]
        data: RemoveSceneObjects,
    },
    #[serde(rename = "reconfigure_stream")]
    ReconfigureStream {
        #[doc = "The response from the `ReconfigureStream` endpoint."]
        data: ReconfigureStream,
    },
    #[serde(rename = "set_scene_units")]
    SetSceneUnits {
        #[doc = "The response from the `SetSceneUnits` endpoint."]
        data: SetSceneUnits,
    },
    #[serde(rename = "set_selection_type")]
    SetSelectionType {
        #[doc = "The response from the `SetSelectionType` endpoint."]
        data: SetSelectionType,
    },
    #[serde(rename = "set_selection_filter")]
    SetSelectionFilter {
        #[doc = "The response from the `SetSelectionFilter` endpoint."]
        data: SetSelectionFilter,
    },
    #[serde(rename = "default_camera_set_orthographic")]
    DefaultCameraSetOrthographic {
        #[doc = "The response from the `DefaultCameraSetOrthographic` endpoint."]
        data: DefaultCameraSetOrthographic,
    },
    #[serde(rename = "default_camera_set_perspective")]
    DefaultCameraSetPerspective {
        #[doc = "The response from the `DefaultCameraSetPerspective` endpoint."]
        data: DefaultCameraSetPerspective,
    },
    #[serde(rename = "default_camera_center_to_selection")]
    DefaultCameraCenterToSelection {
        #[doc = "The response from the `DefaultCameraCenterToSelection` endpoint."]
        data: DefaultCameraCenterToSelection,
    },
    #[serde(rename = "default_camera_center_to_scene")]
    DefaultCameraCenterToScene {
        #[doc = "The response from the `DefaultCameraCenterToScene` endpoint."]
        data: DefaultCameraCenterToScene,
    },
    #[serde(rename = "select_clear")]
    SelectClear {
        #[doc = "The response from the `SelectClear` endpoint."]
        data: SelectClear,
    },
    #[serde(rename = "export2d")]
    Export2D {
        #[doc = "The response from the `Export2d` endpoint."]
        data: Export2D,
    },
    #[serde(rename = "export3d")]
    Export3D {
        #[doc = "The response from the `Export3d` endpoint."]
        data: Export3D,
    },
    #[serde(rename = "export")]
    Export {
        #[doc = "The response from the `Export` endpoint."]
        data: Export,
    },
    #[serde(rename = "select_with_point")]
    SelectWithPoint {
        #[doc = "The response from the `SelectWithPoint` command."]
        data: SelectWithPoint,
    },
    #[serde(rename = "highlight_set_entity")]
    HighlightSetEntity {
        #[doc = "The response from the `HighlightSetEntity` command."]
        data: HighlightSetEntity,
    },
    #[serde(rename = "entity_get_child_uuid")]
    EntityGetChildUuid {
        #[doc = "The response from the `EntityGetChildUuid` command."]
        data: EntityGetChildUuid,
    },
    #[serde(rename = "entity_get_num_children")]
    EntityGetNumChildren {
        #[doc = "The response from the `EntityGetNumChildren` command."]
        data: EntityGetNumChildren,
    },
    #[serde(rename = "entity_get_parent_id")]
    EntityGetParentId {
        #[doc = "The response from the `EntityGetParentId` command."]
        data: EntityGetParentId,
    },
    #[serde(rename = "entity_get_all_child_uuids")]
    EntityGetAllChildUuids {
        #[doc = "The response from the `EntityGetAllChildUuids` command."]
        data: EntityGetAllChildUuids,
    },
    #[serde(rename = "entity_get_sketch_paths")]
    EntityGetSketchPaths {
        #[doc = "The response from the `EntityGetSketchPaths` command."]
        data: EntityGetSketchPaths,
    },
    #[serde(rename = "loft")]
    Loft {
        #[doc = "The response from the `Loft` command."]
        data: Loft,
    },
    #[serde(rename = "close_path")]
    ClosePath {
        #[doc = "The response from the `ClosePath` command."]
        data: ClosePath,
    },
    #[serde(rename = "camera_drag_move")]
    CameraDragMove {
        #[doc = "The response from the `CameraDragMove` command. Note this is an \"unreliable\" channel message, so this data may need more data like a \"sequence\""]
        data: CameraDragMove,
    },
    #[serde(rename = "camera_drag_end")]
    CameraDragEnd {
        #[doc = "The response from the `CameraDragEnd` command."]
        data: CameraDragEnd,
    },
    #[serde(rename = "default_camera_get_settings")]
    DefaultCameraGetSettings {
        #[doc = "The response from the `DefaultCameraGetSettings` command."]
        data: DefaultCameraGetSettings,
    },
    #[serde(rename = "default_camera_get_view")]
    DefaultCameraGetView {
        #[doc = "The response from the `DefaultCameraGetView` command."]
        data: DefaultCameraGetView,
    },
    #[serde(rename = "default_camera_set_view")]
    DefaultCameraSetView {
        #[doc = "The response from the `DefaultCameraSetView` command."]
        data: DefaultCameraSetView,
    },
    #[serde(rename = "default_camera_zoom")]
    DefaultCameraZoom {
        #[doc = "The response from the `DefaultCameraZoom` command."]
        data: DefaultCameraZoom,
    },
    #[serde(rename = "zoom_to_fit")]
    ZoomToFit {
        #[doc = "The response from the `ZoomToFit` command."]
        data: ZoomToFit,
    },
    #[serde(rename = "orient_to_face")]
    OrientToFace {
        #[doc = "The response from the `OrientToFace` command."]
        data: OrientToFace,
    },
    #[serde(rename = "view_isometric")]
    ViewIsometric {
        #[doc = "The response from the `ViewIsometric` command."]
        data: ViewIsometric,
    },
    #[serde(rename = "get_num_objects")]
    GetNumObjects {
        #[doc = "The response from the `GetNumObjects` command."]
        data: GetNumObjects,
    },
    #[serde(rename = "make_offset_path")]
    MakeOffsetPath {
        #[doc = "The response from the `MakeOffsetPath` command."]
        data: MakeOffsetPath,
    },
    #[serde(rename = "set_object_transform")]
    SetObjectTransform {
        #[doc = "The response from the `SetObjectTransform` command."]
        data: SetObjectTransform,
    },
    #[serde(rename = "add_hole_from_offset")]
    AddHoleFromOffset {
        #[doc = "The response from the `AddHoleFromOffset` command."]
        data: AddHoleFromOffset,
    },
    #[serde(rename = "default_camera_focus_on")]
    DefaultCameraFocusOn {
        #[doc = "The response from the `DefaultCameraFocusOn` command."]
        data: DefaultCameraFocusOn,
    },
    #[serde(rename = "select_get")]
    SelectGet {
        #[doc = "The response from the `SelectGet` command."]
        data: SelectGet,
    },
    #[serde(rename = "solid3d_get_adjacency_info")]
    Solid3DGetAdjacencyInfo {
        #[doc = "Extrusion face info struct (useful for maintaining mappings between source path segment ids and extrusion faces) This includes the opposite and adjacent faces and edges."]
        data: Solid3DGetAdjacencyInfo,
    },
    #[serde(rename = "solid3d_get_all_edge_faces")]
    Solid3DGetAllEdgeFaces {
        #[doc = "The response from the `Solid3dGetAllEdgeFaces` command."]
        data: Solid3DGetAllEdgeFaces,
    },
    #[serde(rename = "solid3d_get_all_opposite_edges")]
    Solid3DGetAllOppositeEdges {
        #[doc = "The response from the `Solid3dGetAllOppositeEdges` command."]
        data: Solid3DGetAllOppositeEdges,
    },
    #[serde(rename = "solid3d_get_opposite_edge")]
    Solid3DGetOppositeEdge {
        #[doc = "The response from the `Solid3dGetOppositeEdge` command."]
        data: Solid3DGetOppositeEdge,
    },
    #[serde(rename = "solid3d_get_next_adjacent_edge")]
    Solid3DGetNextAdjacentEdge {
        #[doc = "The response from the `Solid3dGetNextAdjacentEdge` command."]
        data: Solid3DGetNextAdjacentEdge,
    },
    #[serde(rename = "solid3d_get_prev_adjacent_edge")]
    Solid3DGetPrevAdjacentEdge {
        #[doc = "The response from the `Solid3dGetPrevAdjacentEdge` command."]
        data: Solid3DGetPrevAdjacentEdge,
    },
    #[serde(rename = "solid3d_get_common_edge")]
    Solid3DGetCommonEdge {
        #[doc = "The response from the `Solid3DGetCommonEdge` command."]
        data: Solid3DGetCommonEdge,
    },
    #[serde(rename = "get_entity_type")]
    GetEntityType {
        #[doc = "The response from the `GetEntityType` command."]
        data: GetEntityType,
    },
    #[serde(rename = "curve_get_control_points")]
    CurveGetControlPoints {
        #[doc = "The response from the `CurveGetControlPoints` command."]
        data: CurveGetControlPoints,
    },
    #[serde(rename = "project_entity_to_plane")]
    ProjectEntityToPlane {
        #[doc = "The response from the `ProjectEntityToPlane` command."]
        data: ProjectEntityToPlane,
    },
    #[serde(rename = "project_points_to_plane")]
    ProjectPointsToPlane {
        #[doc = "The response from the `ProjectPointsToPlane` command."]
        data: ProjectPointsToPlane,
    },
    #[serde(rename = "curve_get_type")]
    CurveGetType {
        #[doc = "The response from the `CurveGetType` command."]
        data: CurveGetType,
    },
    #[serde(rename = "mouse_click")]
    MouseClick {
        #[doc = "The response from the `MouseClick` command."]
        data: MouseClick,
    },
    #[serde(rename = "take_snapshot")]
    TakeSnapshot {
        #[doc = "The response from the `TakeSnapshot` command."]
        data: TakeSnapshot,
    },
    #[serde(rename = "path_get_info")]
    PathGetInfo {
        #[doc = "The response from the `PathGetInfo` command."]
        data: PathGetInfo,
    },
    #[serde(rename = "path_segment_info")]
    PathSegmentInfo {
        #[doc = "Info about a path segment"]
        data: PathSegmentInfo,
    },
    #[serde(rename = "path_get_curve_uuids_for_vertices")]
    PathGetCurveUuidsForVertices {
        #[doc = "The response from the `PathGetCurveUuidsForVertices` command."]
        data: PathGetCurveUuidsForVertices,
    },
    #[serde(rename = "path_get_curve_uuid")]
    PathGetCurveUuid {
        #[doc = "The response from the `PathGetCurveUuid` command."]
        data: PathGetCurveUuid,
    },
    #[serde(rename = "path_get_vertex_uuids")]
    PathGetVertexUuids {
        #[doc = "The response from the `PathGetVertexUuids` command."]
        data: PathGetVertexUuids,
    },
    #[serde(rename = "path_get_sketch_target_uuid")]
    PathGetSketchTargetUuid {
        #[doc = "The response from the `PathGetSketchTargetUuid` command."]
        data: PathGetSketchTargetUuid,
    },
    #[serde(rename = "curve_get_end_points")]
    CurveGetEndPoints {
        #[doc = "Endpoints of a curve"]
        data: CurveGetEndPoints,
    },
    #[serde(rename = "face_is_planar")]
    FaceIsPlanar {
        #[doc = "Surface-local planar axes (if available)"]
        data: FaceIsPlanar,
    },
    #[serde(rename = "face_get_position")]
    FaceGetPosition {
        #[doc = "The 3D position on the surface that was evaluated"]
        data: FaceGetPosition,
    },
    #[serde(rename = "face_get_center")]
    FaceGetCenter {
        #[doc = "The 3D center of mass on the surface"]
        data: FaceGetCenter,
    },
    #[serde(rename = "face_get_gradient")]
    FaceGetGradient {
        #[doc = "The gradient (dFdu, dFdv) + normal vector on a brep face"]
        data: FaceGetGradient,
    },
    #[serde(rename = "plane_intersect_and_project")]
    PlaneIntersectAndProject {
        #[doc = "Corresponding coordinates of given window coordinates, intersected on given plane."]
        data: PlaneIntersectAndProject,
    },
    #[serde(rename = "import_files")]
    ImportFiles {
        #[doc = "Data from importing the files"]
        data: ImportFiles,
    },
    #[serde(rename = "imported_geometry")]
    ImportedGeometry {
        #[doc = "Data from importing the files"]
        data: ImportedGeometry,
    },
    #[serde(rename = "mass")]
    Mass {
        #[doc = "The mass response."]
        data: Mass,
    },
    #[serde(rename = "volume")]
    Volume {
        #[doc = "The volume response."]
        data: Volume,
    },
    #[serde(rename = "density")]
    Density {
        #[doc = "The density response."]
        data: Density,
    },
    #[serde(rename = "surface_area")]
    SurfaceArea {
        #[doc = "The surface area response."]
        data: SurfaceArea,
    },
    #[serde(rename = "center_of_mass")]
    CenterOfMass {
        #[doc = "The center of mass response."]
        data: CenterOfMass,
    },
    #[serde(rename = "get_sketch_mode_plane")]
    GetSketchModePlane {
        #[doc = "The plane for sketch mode."]
        data: GetSketchModePlane,
    },
    #[serde(rename = "entity_get_distance")]
    EntityGetDistance {
        #[doc = "The response from the `EntitiesGetDistance` command."]
        data: EntityGetDistance,
    },
    #[serde(rename = "face_edge_info")]
    FaceEdgeInfo {
        #[doc = "Faces and edges id info (most used in identifying geometry in patterned and mirrored objects)."]
        data: FaceEdgeInfo,
    },
    #[serde(rename = "edge_info")]
    EdgeInfo {
        #[doc = "A list of faces for a specific edge."]
        data: EdgeInfo,
    },
    #[serde(rename = "entity_clone")]
    EntityClone {
        #[doc = "The response from the `EntityClone` command."]
        data: EntityClone,
    },
    #[serde(rename = "entity_linear_pattern_transform")]
    EntityLinearPatternTransform {
        #[doc = "The response from the `EntityLinearPatternTransform` command."]
        data: EntityLinearPatternTransform,
    },
    #[serde(rename = "entity_linear_pattern")]
    EntityLinearPattern {
        #[doc = "The response from the `EntityLinearPattern` command."]
        data: EntityLinearPattern,
    },
    #[serde(rename = "entity_circular_pattern")]
    EntityCircularPattern {
        #[doc = "The response from the `EntityCircularPattern` command."]
        data: EntityCircularPattern,
    },
    #[serde(rename = "entity_mirror")]
    EntityMirror {
        #[doc = "The response from the `EntityMirror` endpoint."]
        data: EntityMirror,
    },
    #[serde(rename = "entity_mirror_across_edge")]
    EntityMirrorAcrossEdge {
        #[doc = "The response from the `EntityMirrorAcrossEdge` endpoint."]
        data: EntityMirrorAcrossEdge,
    },
    #[serde(rename = "entity_make_helix")]
    EntityMakeHelix {
        #[doc = "The response from the `EntityMakeHelix` endpoint."]
        data: EntityMakeHelix,
    },
    #[serde(rename = "entity_make_helix_from_params")]
    EntityMakeHelixFromParams {
        #[doc = "The response from the `EntityMakeHelixFromParams` endpoint."]
        data: EntityMakeHelixFromParams,
    },
    #[serde(rename = "entity_make_helix_from_edge")]
    EntityMakeHelixFromEdge {
        #[doc = "The response from the `EntityMakeHelixFromEdge` endpoint."]
        data: EntityMakeHelixFromEdge,
    },
    #[serde(rename = "solid3d_get_extrusion_face_info")]
    Solid3DGetExtrusionFaceInfo {
        #[doc = "Extrusion face info struct (useful for maintaining mappings between source path segment ids and extrusion faces)"]
        data: Solid3DGetExtrusionFaceInfo,
    },
    #[serde(rename = "extrusion_face_info")]
    ExtrusionFaceInfo {
        #[doc = "Extrusion face info struct (useful for maintaining mappings between source path segment ids and extrusion faces)"]
        data: ExtrusionFaceInfo,
    },
    #[serde(rename = "complementary_edges")]
    ComplementaryEdges {
        #[doc = "Struct to contain the edge information of a wall of an extrude/rotate/loft/sweep."]
        data: ComplementaryEdges,
    },
    #[serde(rename = "adjacency_info")]
    AdjacencyInfo {
        #[doc = "Edge info struct (useful for maintaining mappings between edges and faces and adjacent/opposite edges)."]
        data: AdjacencyInfo,
    },
    #[serde(rename = "set_grid_reference_plane")]
    SetGridReferencePlane {
        #[doc = "The response from the 'SetGridReferencePlane'."]
        data: SetGridReferencePlane,
    },
    #[serde(rename = "boolean_union")]
    BooleanUnion {
        #[doc = "The response from the 'BooleanUnion'."]
        data: BooleanUnion,
    },
    #[serde(rename = "boolean_intersection")]
    BooleanIntersection {
        #[doc = "The response from the 'BooleanIntersection'."]
        data: BooleanIntersection,
    },
    #[serde(rename = "boolean_subtract")]
    BooleanSubtract {
        #[doc = "The response from the 'BooleanSubtract'."]
        data: BooleanSubtract,
    },
    #[serde(rename = "set_grid_scale")]
    SetGridScale {
        #[doc = "The response from the 'SetGridScale'."]
        data: SetGridScale,
    },
    #[serde(rename = "set_grid_auto_scale")]
    SetGridAutoScale {
        #[doc = "The response from the 'SetGridScale'."]
        data: SetGridAutoScale,
    },
}

#[doc = "The websocket messages this server sends."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type", content = "data")]
pub enum OkWebSocketResponseData {
    #[doc = "Information about the ICE servers."]
    #[serde(rename = "ice_server_info")]
    IceServerInfo {
        #[doc = "Information about the ICE servers."]
        ice_servers: Vec<IceServer>,
    },
    #[doc = "The trickle ICE candidate response."]
    #[serde(rename = "trickle_ice")]
    TrickleIce {
        #[doc = "Information about the ICE candidate."]
        candidate: RtcIceCandidateInit,
    },
    #[doc = "The SDP answer response."]
    #[serde(rename = "sdp_answer")]
    SdpAnswer {
        #[doc = "The session description."]
        answer: RtcSessionDescription,
    },
    #[doc = "The modeling command response."]
    #[serde(rename = "modeling")]
    Modeling {
        #[doc = "The result of the command."]
        modeling_response: OkModelingCmdResponse,
    },
    #[doc = "Response to a ModelingBatch."]
    #[serde(rename = "modeling_batch")]
    ModelingBatch {
        #[doc = "For each request in the batch, maps its ID to the request's outcome."]
        responses: std::collections::HashMap<String, BatchResponse>,
    },
    #[doc = "The exported files."]
    #[serde(rename = "export")]
    Export {
        #[doc = "The exported files"]
        files: Vec<RawFile>,
    },
    #[doc = "Request a collection of metrics, to include WebRTC."]
    #[serde(rename = "metrics_request")]
    MetricsRequest {},
    #[doc = "Data about the Modeling Session (application-level)."]
    #[serde(rename = "modeling_session_data")]
    ModelingSessionData {
        #[doc = "Data about the Modeling Session (application-level)."]
        session: ModelingSessionData,
    },
    #[doc = "Pong response to a Ping message."]
    #[serde(rename = "pong")]
    Pong {},
    #[doc = "Information about the connected instance"]
    #[serde(rename = "debug")]
    Debug {
        #[doc = "Instance name. This may or may not mean something."]
        name: String,
    },
}

#[doc = "An organization."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Org {
    #[doc = "If we should allow all future users who are created with email addresses from this domain to join the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_users_in_domain_to_auto_join: Option<bool>,
    #[doc = "The billing email address of the org."]
    pub billing_email: String,
    #[doc = "The date and time the billing email address was verified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub billing_email_verified: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "If the org should be blocked and the reason why."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block: Option<BlockReason>,
    #[doc = "If we can train on the orgs's data. This value overrides any individual user's `can_train_on_data` value if they are a member of the org."]
    #[serde(default)]
    pub can_train_on_data: bool,
    #[doc = "The date and time the org was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The org's domain."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    #[doc = "The unique identifier for the org."]
    pub id: uuid::Uuid,
    #[doc = "The image for the org. This is a URL."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[doc = "The name of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The org's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
    #[doc = "The org's stripe id."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stripe_id: Option<String>,
    #[doc = "The date and time the org was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Org {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Org {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(allow_users_in_domain_to_auto_join) =
                &self.allow_users_in_domain_to_auto_join
            {
                format!("{:?}", allow_users_in_domain_to_auto_join).into()
            } else {
                String::new().into()
            },
            self.billing_email.clone().into(),
            if let Some(billing_email_verified) = &self.billing_email_verified {
                format!("{:?}", billing_email_verified).into()
            } else {
                String::new().into()
            },
            if let Some(block) = &self.block {
                format!("{:?}", block).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.can_train_on_data).into(),
            format!("{:?}", self.created_at).into(),
            if let Some(domain) = &self.domain {
                format!("{:?}", domain).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(image) = &self.image {
                format!("{:?}", image).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
            if let Some(stripe_id) = &self.stripe_id {
                format!("{:?}", stripe_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "allow_users_in_domain_to_auto_join".into(),
            "billing_email".into(),
            "billing_email_verified".into(),
            "block".into(),
            "can_train_on_data".into(),
            "created_at".into(),
            "domain".into(),
            "id".into(),
            "image".into(),
            "name".into(),
            "phone".into(),
            "stripe_id".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "The user-modifiable parts of an organization."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgDetails {
    #[doc = "If we should allow all future users who are created with email addresses from this domain to join the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_users_in_domain_to_auto_join: Option<bool>,
    #[doc = "The billing email address of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub billing_email: Option<String>,
    #[doc = "The org's domain."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    #[doc = "The image for the org. This is a URL."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[doc = "The name of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The org's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
}

impl std::fmt::Display for OrgDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrgDetails {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(allow_users_in_domain_to_auto_join) =
                &self.allow_users_in_domain_to_auto_join
            {
                format!("{:?}", allow_users_in_domain_to_auto_join).into()
            } else {
                String::new().into()
            },
            if let Some(billing_email) = &self.billing_email {
                format!("{:?}", billing_email).into()
            } else {
                String::new().into()
            },
            if let Some(domain) = &self.domain {
                format!("{:?}", domain).into()
            } else {
                String::new().into()
            },
            if let Some(image) = &self.image {
                format!("{:?}", image).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "allow_users_in_domain_to_auto_join".into(),
            "billing_email".into(),
            "domain".into(),
            "image".into(),
            "name".into(),
            "phone".into(),
        ]
    }
}

#[doc = "A member of an organization."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgMember {
    #[doc = "The user's company."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[doc = "The date and time the user was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user's Discord handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord: Option<String>,
    #[doc = "The email address of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = "The date and time the email address was verified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email_verified: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The user's first name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[doc = "The user's GitHub handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub github: Option<String>,
    #[doc = "The unique identifier for the user."]
    pub id: uuid::Uuid,
    #[doc = "The image avatar for the user. This is a URL."]
    pub image: String,
    #[doc = "The user's last name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    #[doc = "The name of the user. This is auto populated at first from the authentication provider (if there was a name). It can be updated by the user by updating their `first_name` and `last_name` fields."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The user's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
    #[doc = "The user's role in the org."]
    pub role: OrgRole,
    #[doc = "The date and time the user was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for OrgMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrgMember {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(company) = &self.company {
                format!("{:?}", company).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(discord) = &self.discord {
                format!("{:?}", discord).into()
            } else {
                String::new().into()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email).into()
            } else {
                String::new().into()
            },
            if let Some(email_verified) = &self.email_verified {
                format!("{:?}", email_verified).into()
            } else {
                String::new().into()
            },
            if let Some(first_name) = &self.first_name {
                format!("{:?}", first_name).into()
            } else {
                String::new().into()
            },
            if let Some(github) = &self.github {
                format!("{:?}", github).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            self.image.clone().into(),
            if let Some(last_name) = &self.last_name {
                format!("{:?}", last_name).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
            format!("{:?}", self.role).into(),
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "company".into(),
            "created_at".into(),
            "discord".into(),
            "email".into(),
            "email_verified".into(),
            "first_name".into(),
            "github".into(),
            "id".into(),
            "image".into(),
            "last_name".into(),
            "name".into(),
            "phone".into(),
            "role".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgMemberResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<OrgMember>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for OrgMemberResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for OrgMemberResultsPage {
    type Item = OrgMember;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrgMemberResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrgResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Org>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for OrgResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for OrgResultsPage {
    type Item = Org;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrgResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "The roles in an organization."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum OrgRole {
    #[doc = "Admins can do anything in the org."]
    #[serde(rename = "admin")]
    #[display("admin")]
    Admin,
    #[doc = "Members of an org can not modify an org, but they belong in the org."]
    #[serde(rename = "member")]
    #[display("member")]
    Member,
    #[doc = "A service account role."]
    #[serde(rename = "service_account")]
    #[display("service_account")]
    ServiceAccount,
}

#[doc = "The response from the `OrientToFace` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrientToFace {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for OrientToFace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrientToFace {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}

#[doc = "The type of origin"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum OriginType {
    #[doc = "Local Origin (center of object bounding box)."]
    #[serde(rename = "local")]
    Local {},
    #[doc = "Global Origin (0, 0, 0)."]
    #[serde(rename = "global")]
    Global {},
    #[doc = "Custom Origin (user specified point)."]
    #[serde(rename = "custom")]
    Custom {
        #[doc = "Custom origin point."]
        origin: Point3D,
    },
}

#[doc = "Output file contents.\n\n<details><summary>JSON schema</summary>\n\n```json { \"description\": \"Output file contents.\", \"type\": \"object\", \"properties\": { \"contents\": { \"description\": \"The contents of the file. This is base64 encoded so we can ensure it is UTF-8 for JSON.\", \"type\": \"string\" }, \"name\": { \"description\": \"The name of the file.\", \"default\": \"\", \"type\": \"string\" } } } ``` </details>"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OutputFile {
    #[doc = "The contents of the file. This is base64 encoded so we can ensure it is UTF-8 for JSON."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<String>,
    #[doc = "The name of the file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for OutputFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OutputFile {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(contents) = &self.contents {
                format!("{:?}", contents).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["contents".into(), "name".into()]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum OutputFormat2DType {
    #[serde(rename = "dxf")]
    #[display("dxf")]
    Dxf,
}

impl std::default::Default for OutputFormat2DType {
    fn default() -> Self {
        OutputFormat2DType::Dxf
    }
}

#[doc = "AutoCAD drawing interchange format."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OutputFormat2D {
    #[doc = "Export storage."]
    pub storage: DxfStorage,
    #[serde(rename = "type")]
    pub type_: OutputFormat2DType,
}

impl std::fmt::Display for OutputFormat2D {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OutputFormat2D {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.storage).into(),
            format!("{:?}", self.type_).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["storage".into(), "type_".into()]
    }
}

#[doc = "Output 3D format specifier."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum OutputFormat3D {
    #[doc = "Autodesk Filmbox (FBX) format."]
    #[serde(rename = "fbx")]
    Fbx {
        #[doc = "Timestamp override."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        created: Option<chrono::DateTime<chrono::Utc>>,
        #[doc = "Specifies which kind of FBX will be exported."]
        storage: FbxStorage,
    },
    #[doc = "glTF 2.0. We refer to this as glTF since that is how our customers refer to it, although by default it will be in binary format and thus technically (glb). If you prefer ASCII output, you can set that option for the export."]
    #[serde(rename = "gltf")]
    Gltf {
        #[doc = "Specifies how the JSON will be presented."]
        presentation: GltfPresentation,
        #[doc = "Specifies which kind of glTF 2.0 will be exported."]
        storage: GltfStorage,
    },
    #[doc = "Wavefront OBJ format."]
    #[serde(rename = "obj")]
    Obj {
        #[doc = "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "Export length unit.\n\nDefaults to millimeters."]
        units: UnitLength,
    },
    #[doc = "The PLY Polygon File Format."]
    #[serde(rename = "ply")]
    Ply {
        #[doc = "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "Export selection."]
        selection: Selection,
        #[doc = "The storage for the output PLY file."]
        storage: PlyStorage,
        #[doc = "Export length unit.\n\nDefaults to millimeters."]
        units: UnitLength,
    },
    #[doc = "ISO 10303-21 (STEP) format."]
    #[serde(rename = "step")]
    Step {
        #[doc = "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "Timestamp override."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        created: Option<chrono::DateTime<chrono::Utc>>,
    },
    #[doc = "*ST**ereo**L**ithography format."]
    #[serde(rename = "stl")]
    Stl {
        #[doc = "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html"]
        coords: System,
        #[doc = "Export selection."]
        selection: Selection,
        #[doc = "Export storage."]
        storage: StlStorage,
        #[doc = "Export length unit.\n\nDefaults to millimeters."]
        units: UnitLength,
    },
}

#[doc = "The path component command type (within a Path)"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PathCommand {
    #[serde(rename = "move_to")]
    #[display("move_to")]
    MoveTo,
    #[serde(rename = "line_to")]
    #[display("line_to")]
    LineTo,
    #[serde(rename = "bez_curve_to")]
    #[display("bez_curve_to")]
    BezCurveTo,
    #[serde(rename = "nurbs_curve_to")]
    #[display("nurbs_curve_to")]
    NurbsCurveTo,
    #[serde(rename = "add_arc")]
    #[display("add_arc")]
    AddArc,
}

#[doc = "The path component constraint bounds type"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PathComponentConstraintBound {
    #[serde(rename = "unconstrained")]
    #[display("unconstrained")]
    Unconstrained,
    #[serde(rename = "partially_constrained")]
    #[display("partially_constrained")]
    PartiallyConstrained,
    #[serde(rename = "fully_constrained")]
    #[display("fully_constrained")]
    FullyConstrained,
}

#[doc = "The path component constraint type"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PathComponentConstraintType {
    #[serde(rename = "unconstrained")]
    #[display("unconstrained")]
    Unconstrained,
    #[serde(rename = "vertical")]
    #[display("vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    #[display("horizontal")]
    Horizontal,
    #[serde(rename = "equal_length")]
    #[display("equal_length")]
    EqualLength,
    #[serde(rename = "parallel")]
    #[display("parallel")]
    Parallel,
    #[serde(rename = "angle_between")]
    #[display("angle_between")]
    AngleBetween,
}

#[doc = "The response from the `PathGetCurveUuid` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PathGetCurveUuid {
    #[doc = "The UUID of the curve entity."]
    pub curve_id: uuid::Uuid,
}

impl std::fmt::Display for PathGetCurveUuid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PathGetCurveUuid {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.curve_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["curve_id".into()]
    }
}

#[doc = "The response from the `PathGetCurveUuidsForVertices` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PathGetCurveUuidsForVertices {
    #[doc = "The UUIDs of the curve entities."]
    pub curve_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for PathGetCurveUuidsForVertices {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PathGetCurveUuidsForVertices {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.curve_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["curve_ids".into()]
    }
}

#[doc = "The response from the `PathGetInfo` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PathGetInfo {
    #[doc = "All segments in the path, in the order they were added."]
    pub segments: Vec<PathSegmentInfo>,
}

impl std::fmt::Display for PathGetInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PathGetInfo {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.segments).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["segments".into()]
    }
}

#[doc = "The response from the `PathGetSketchTargetUuid` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PathGetSketchTargetUuid {
    #[doc = "The UUID of the sketch target."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target_id: Option<uuid::Uuid>,
}

impl std::fmt::Display for PathGetSketchTargetUuid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PathGetSketchTargetUuid {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(target_id) = &self.target_id {
            format!("{:?}", target_id).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["target_id".into()]
    }
}

#[doc = "The response from the `PathGetVertexUuids` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PathGetVertexUuids {
    #[doc = "The UUIDs of the vertex entities."]
    pub vertex_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for PathGetVertexUuids {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PathGetVertexUuids {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.vertex_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["vertex_ids".into()]
    }
}

#[doc = "A segment of a path. Paths are composed of many segments."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum PathSegment {
    #[doc = "A straight line segment. Goes from the current path \"pen\" to the given endpoint."]
    #[serde(rename = "line")]
    Line {
        #[doc = "End point of the line."]
        end: Point3D,
        #[doc = "Whether or not this line is a relative offset"]
        relative: bool,
    },
    #[doc = "A circular arc segment. Arcs can be drawn clockwise when start > end."]
    #[serde(rename = "arc")]
    Arc {
        #[doc = "Center of the circle"]
        center: Point2D,
        #[doc = "End of the arc along circle's perimeter."]
        end: Angle,
        #[doc = "Radius of the circle"]
        radius: f64,
        #[doc = "Whether or not this arc is a relative offset"]
        relative: bool,
        #[doc = "Start of the arc along circle's perimeter."]
        start: Angle,
    },
    #[doc = "A cubic bezier curve segment. Start at the end of the current line, go through control point 1 and 2, then end at a given point."]
    #[serde(rename = "bezier")]
    Bezier {
        #[doc = "First control point."]
        #[serde(rename = "control1")]
        control_1: Point3D,
        #[doc = "Second control point."]
        #[serde(rename = "control2")]
        control_2: Point3D,
        #[doc = "Final control point."]
        end: Point3D,
        #[doc = "Whether or not this bezier is a relative offset"]
        relative: bool,
    },
    #[doc = "Adds a tangent arc from current pen position with the given radius and angle."]
    #[serde(rename = "tangential_arc")]
    TangentialArc {
        #[doc = "Offset of the arc. Negative values will arc clockwise."]
        offset: Angle,
        #[doc = "Radius of the arc. Not to be confused with Raiders of the Lost Ark."]
        radius: f64,
    },
    #[doc = "Adds a tangent arc from current pen position to the new position. Arcs will choose a clockwise or counter-clockwise direction based on the arc end position."]
    #[serde(rename = "tangential_arc_to")]
    TangentialArcTo {
        #[doc = "0 will be interpreted as none/null."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        angle_snap_increment: Option<Angle>,
        #[doc = "Where the arc should end. Must lie in the same plane as the current path pen position. Must not be colinear with current path pen position."]
        to: Point3D,
    },
    #[doc = "Adds an arc from the current position that goes through the given interior point and ends at the given end position"]
    #[serde(rename = "arc_to")]
    ArcTo {
        #[doc = "End point of the arc."]
        end: Point3D,
        #[doc = "Interior point of the arc."]
        interior: Point3D,
        #[doc = "Whether or not interior and end are relative to the previous path position"]
        relative: bool,
    },
    #[doc = "Adds a circular involute from the current position that goes through the given end_radius and is rotated around the current point by angle."]
    #[serde(rename = "circular_involute")]
    CircularInvolute {
        #[doc = "The angle to rotate the involute by. A value of zero will produce a curve with a tangent along the x-axis at the start point of the curve."]
        angle: Angle,
        #[doc = "The involute is described between two circles, end_radius is the radius of the outer circle."]
        end_radius: f64,
        #[doc = "If reverse is true, the segment will start from the end of the involute, otherwise it will start from that start."]
        reverse: bool,
        #[doc = "The involute is described between two circles, start_radius is the radius of the inner circle."]
        start_radius: f64,
    },
    #[doc = "Adds an elliptical arc segment."]
    #[serde(rename = "ellipse")]
    Ellipse {
        #[doc = "The center point of the ellipse."]
        center: Point2D,
        #[doc = "End of the path along the perimeter of the ellipse."]
        end_angle: Angle,
        #[doc = "Major radius of the ellipse (along the x axis)."]
        major_radius: f64,
        #[doc = "Minor radius of the ellipse (along the y axis)."]
        minor_radius: f64,
        #[doc = "Start of the path along the perimeter of the ellipse."]
        start_angle: Angle,
    },
    #[doc = "Adds a generic conic section specified by the end point, interior point and tangents at the start and end of the section."]
    #[serde(rename = "conic_to")]
    ConicTo {
        #[doc = "End point of the conic."]
        end: Point2D,
        #[doc = "Tangent at the end of the conic."]
        end_tangent: Point2D,
        #[doc = "Interior point that lies on the conic."]
        interior: Point2D,
        #[doc = "Whether or not the interior and end points are relative to the previous path position."]
        relative: bool,
        #[doc = "Tangent at the start of the conic."]
        start_tangent: Point2D,
    },
}

#[doc = "Info about a path segment"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PathSegmentInfo {
    #[doc = "What is the path segment?"]
    pub command: PathCommand,
    #[doc = "Which command created this path? This field is absent if the path command is not actually creating a path segment, e.g. moving the pen doesn't create a path segment."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command_id: Option<uuid::Uuid>,
    #[doc = "Whether or not this segment is a relative offset"]
    pub relative: bool,
}

impl std::fmt::Display for PathSegmentInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PathSegmentInfo {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.command).into(),
            if let Some(command_id) = &self.command_id {
                format!("{:?}", command_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.relative).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["command".into(), "command_id".into(), "relative".into()]
    }
}

#[doc = "A payment intent response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PaymentIntent {
    #[doc = "The client secret is used for client-side retrieval using a publishable key. The client secret can be used to complete payment setup from your frontend. It should not be stored, logged, or exposed to anyone other than the customer. Make sure that you have TLS enabled on any page that includes the client secret."]
    pub client_secret: String,
}

impl std::fmt::Display for PaymentIntent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PaymentIntent {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.client_secret.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["client_secret".into()]
    }
}

#[doc = "A payment method."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PaymentMethod {
    #[doc = "The billing info for the payment method."]
    pub billing_info: BillingInfo,
    #[doc = "The card, if it is one. For our purposes, this is the only type of payment method that we support."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub card: Option<CardDetails>,
    #[doc = "Time at which the object was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "Unique identifier for the object."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Set of key-value pairs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
    #[doc = "The type of payment method."]
    #[serde(rename = "type")]
    pub type_: PaymentMethodType,
}

impl std::fmt::Display for PaymentMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PaymentMethod {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.billing_info).into(),
            if let Some(card) = &self.card {
                format!("{:?}", card).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(metadata) = &self.metadata {
                format!("{:?}", metadata).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.type_).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "billing_info".into(),
            "card".into(),
            "created_at".into(),
            "id".into(),
            "metadata".into(),
            "type_".into(),
        ]
    }
}

#[doc = "Card checks."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PaymentMethodCardChecks {
    #[doc = "If a address line1 was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`."]
    #[serde(
        rename = "address_line1_check",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub address_line_1_check: Option<String>,
    #[doc = "If a address postal code was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_postal_code_check: Option<String>,
    #[doc = "If a CVC was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cvc_check: Option<String>,
}

impl std::fmt::Display for PaymentMethodCardChecks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PaymentMethodCardChecks {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(address_line_1_check) = &self.address_line_1_check {
                format!("{:?}", address_line_1_check).into()
            } else {
                String::new().into()
            },
            if let Some(address_postal_code_check) = &self.address_postal_code_check {
                format!("{:?}", address_postal_code_check).into()
            } else {
                String::new().into()
            },
            if let Some(cvc_check) = &self.cvc_check {
                format!("{:?}", cvc_check).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "address_line_1_check".into(),
            "address_postal_code_check".into(),
            "cvc_check".into(),
        ]
    }
}

#[doc = "An enum representing the possible values of an `PaymentMethod`'s `type` field."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PaymentMethodType {
    #[doc = "A card payment method."]
    #[serde(rename = "card")]
    #[display("card")]
    Card,
}

impl std::default::Default for PaymentMethodType {
    fn default() -> Self {
        PaymentMethodType::Card
    }
}

#[doc = "Defines a perspective view."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PerspectiveCameraParameters {
    #[doc = "Camera frustum vertical field of view."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fov_y: Option<f64>,
    #[doc = "Camera frustum far plane."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub z_far: Option<f64>,
    #[doc = "Camera frustum near plane."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub z_near: Option<f64>,
}

impl std::fmt::Display for PerspectiveCameraParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PerspectiveCameraParameters {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(fov_y) = &self.fov_y {
                format!("{:?}", fov_y).into()
            } else {
                String::new().into()
            },
            if let Some(z_far) = &self.z_far {
                format!("{:?}", z_far).into()
            } else {
                String::new().into()
            },
            if let Some(z_near) = &self.z_near {
                format!("{:?}", z_near).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["fov_y".into(), "z_far".into(), "z_near".into()]
    }
}

#[doc = "A plan's interval."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PlanInterval {
    #[doc = "Day."]
    #[serde(rename = "day")]
    #[display("day")]
    Day,
    #[doc = "Month."]
    #[serde(rename = "month")]
    #[display("month")]
    Month,
    #[doc = "Week."]
    #[serde(rename = "week")]
    #[display("week")]
    Week,
    #[doc = "Year."]
    #[serde(rename = "year")]
    #[display("year")]
    Year,
}

#[doc = "Corresponding coordinates of given window coordinates, intersected on given plane."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PlaneIntersectAndProject {
    #[doc = "Corresponding coordinates of given window coordinates, intersected on given plane."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plane_coordinates: Option<Point2D>,
}

impl std::fmt::Display for PlaneIntersectAndProject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PlaneIntersectAndProject {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(plane_coordinates) = &self.plane_coordinates {
            format!("{:?}", plane_coordinates).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["plane_coordinates".into()]
    }
}

#[doc = "The response from the `PlaneSetColor` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PlaneSetColor {}

impl std::fmt::Display for PlaneSetColor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PlaneSetColor {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The storage for the output PLY file."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PlyStorage {
    #[doc = "Write numbers in their ascii representation (e.g. -13, 6.28, etc.). Properties are separated by spaces and elements are separated by line breaks."]
    #[serde(rename = "ascii")]
    #[display("ascii")]
    Ascii,
    #[doc = "Encode payload as binary using little endian."]
    #[serde(rename = "binary_little_endian")]
    #[display("binary_little_endian")]
    BinaryLittleEndian,
    #[doc = "Encode payload as binary using big endian."]
    #[serde(rename = "binary_big_endian")]
    #[display("binary_big_endian")]
    BinaryBigEndian,
}

#[doc = "A point in 2D space"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Point2D {
    pub x: f64,
    pub y: f64,
}

impl std::fmt::Display for Point2D {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Point2D {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.x).into(),
            format!("{:?}", self.y).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["x".into(), "y".into()]
    }
}

#[doc = "A point in 3D space"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Point3D {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

impl std::fmt::Display for Point3D {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Point3D {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.x).into(),
            format!("{:?}", self.y).into(),
            format!("{:?}", self.z).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["x".into(), "y".into(), "z".into()]
    }
}

#[doc = "A point in homogeneous (4D) space"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Point4D {
    pub w: f64,
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

impl std::fmt::Display for Point4D {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Point4D {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.w).into(),
            format!("{:?}", self.x).into(),
            format!("{:?}", self.y).into(),
            format!("{:?}", self.z).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["w".into(), "x".into(), "y".into(), "z".into()]
    }
}

#[doc = "The response from the `/ping` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Pong {
    #[doc = "The pong response."]
    pub message: String,
}

impl std::fmt::Display for Pong {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Pong {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.message.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["message".into()]
    }
}

#[doc = "Post effect type"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum PostEffectType {
    #[serde(rename = "phosphor")]
    #[display("phosphor")]
    Phosphor,
    #[serde(rename = "ssao")]
    #[display("ssao")]
    Ssao,
    #[serde(rename = "noeffect")]
    #[display("noeffect")]
    Noeffect,
}

#[doc = "Privacy settings for an org or user."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct PrivacySettings {
    #[doc = "If we can train on the data. If the user is a member of an organization, the organization's setting will override this. The organization's setting takes priority."]
    pub can_train_on_data: bool,
}

impl std::fmt::Display for PrivacySettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for PrivacySettings {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.can_train_on_data).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["can_train_on_data".into()]
    }
}

#[doc = "The response from the `ProjectEntityToPlane` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectEntityToPlane {
    #[doc = "Projected points."]
    pub projected_points: Vec<Point3D>,
}

impl std::fmt::Display for ProjectEntityToPlane {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ProjectEntityToPlane {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.projected_points).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["projected_points".into()]
    }
}

#[doc = "The response from the `ProjectPointsToPlane` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectPointsToPlane {
    #[doc = "Projected points."]
    pub projected_points: Vec<Point3D>,
}

impl std::fmt::Display for ProjectPointsToPlane {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ProjectPointsToPlane {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.projected_points).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["projected_points".into()]
    }
}

#[doc = "A raw file with unencoded contents to be passed over binary websockets. When raw files come back for exports it is sent as binary/bson, not text/json."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RawFile {
    #[doc = "The contents of the file."]
    #[serde(
        serialize_with = "serde_bytes::serialize",
        deserialize_with = "serde_bytes::deserialize"
    )]
    pub contents: Vec<u8>,
    #[doc = "The name of the file."]
    pub name: String,
}

impl std::fmt::Display for RawFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RawFile {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.contents).into(),
            self.name.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["contents".into(), "name".into()]
    }
}

#[doc = "The response from the `ReconfigureStream` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ReconfigureStream {}

impl std::fmt::Display for ReconfigureStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ReconfigureStream {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "What is the given geometry relative to?"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum RelativeTo {
    #[doc = "Local/relative to a position centered within the plane being sketched on"]
    #[serde(rename = "sketch_plane")]
    #[display("sketch_plane")]
    SketchPlane,
    #[doc = "Local/relative to the trajectory curve"]
    #[serde(rename = "trajectory_curve")]
    #[display("trajectory_curve")]
    TrajectoryCurve,
}

#[doc = "The response from the `RemoveSceneObjects` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RemoveSceneObjects {}

impl std::fmt::Display for RemoveSceneObjects {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RemoveSceneObjects {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `Revolve` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Revolve {}

impl std::fmt::Display for Revolve {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Revolve {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `RevolveAboutEdge` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RevolveAboutEdge {}

impl std::fmt::Display for RevolveAboutEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RevolveAboutEdge {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "A rotation defined by an axis, origin of rotation, and an angle."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Rotation {
    #[doc = "Rotate this far about the rotation axis. Defaults to zero (i.e. no rotation)."]
    pub angle: Angle,
    #[doc = "Rotation axis. Defaults to (0, 0, 1) (i.e. the Z axis)."]
    pub axis: Point3D,
    #[doc = "Origin of the rotation. If one isn't provided, the object will rotate about its own bounding box center."]
    pub origin: OriginType,
}

impl std::fmt::Display for Rotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Rotation {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.angle).into(),
            format!("{:?}", self.axis).into(),
            format!("{:?}", self.origin).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["angle".into(), "axis".into(), "origin".into()]
    }
}

#[doc = "ICECandidateInit is used to serialize ice candidates"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RtcIceCandidateInit {
    #[doc = "The candidate string associated with the object."]
    pub candidate: String,
    #[doc = "The index (starting at zero) of the m-line in the SDP this candidate is associated with."]
    #[serde(
        rename = "sdpMLineIndex",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sdp_m_line_index: Option<u16>,
    #[doc = "The identifier of the \"media stream identification\" as defined in [RFC 8841](https://tools.ietf.org/html/rfc8841)."]
    #[serde(rename = "sdpMid", default, skip_serializing_if = "Option::is_none")]
    pub sdp_mid: Option<String>,
    #[doc = "The username fragment (as defined in [RFC 8445](https://tools.ietf.org/html/rfc8445#section-5.2.1)) associated with the object."]
    #[serde(
        rename = "usernameFragment",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub username_fragment: Option<String>,
}

impl std::fmt::Display for RtcIceCandidateInit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RtcIceCandidateInit {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.candidate.clone().into(),
            if let Some(sdp_m_line_index) = &self.sdp_m_line_index {
                format!("{:?}", sdp_m_line_index).into()
            } else {
                String::new().into()
            },
            if let Some(sdp_mid) = &self.sdp_mid {
                format!("{:?}", sdp_mid).into()
            } else {
                String::new().into()
            },
            if let Some(username_fragment) = &self.username_fragment {
                format!("{:?}", username_fragment).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "candidate".into(),
            "sdp_m_line_index".into(),
            "sdp_mid".into(),
            "username_fragment".into(),
        ]
    }
}

#[doc = "SDPType describes the type of an SessionDescription."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum RtcSdpType {
    #[doc = "Unspecified indicates that the type is unspecified."]
    #[serde(rename = "unspecified")]
    #[display("unspecified")]
    Unspecified,
    #[doc = "indicates that a description MUST be treated as an SDP offer."]
    #[serde(rename = "offer")]
    #[display("offer")]
    Offer,
    #[doc = "indicates that a description MUST be treated as an SDP answer, but not a final answer. A description used as an SDP pranswer may be applied as a response to an SDP offer, or an update to a previously sent SDP pranswer."]
    #[serde(rename = "pranswer")]
    #[display("pranswer")]
    Pranswer,
    #[doc = "indicates that a description MUST be treated as an SDP final answer, and the offer-answer exchange MUST be considered complete. A description used as an SDP answer may be applied as a response to an SDP offer or as an update to a previously sent SDP pranswer."]
    #[serde(rename = "answer")]
    #[display("answer")]
    Answer,
    #[doc = "indicates that a description MUST be treated as canceling the current SDP negotiation and moving the SDP offer and answer back to what it was in the previous stable state. Note the local or remote SDP descriptions in the previous stable state could be null if there has not yet been a successful offer-answer negotiation."]
    #[serde(rename = "rollback")]
    #[display("rollback")]
    Rollback,
}

#[doc = "SessionDescription is used to expose local and remote session descriptions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RtcSessionDescription {
    #[doc = "SDP string."]
    pub sdp: String,
    #[doc = "SDP type."]
    #[serde(rename = "type")]
    pub type_: RtcSdpType,
}

impl std::fmt::Display for RtcSessionDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RtcSessionDescription {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.sdp.clone().into(), format!("{:?}", self.type_).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["sdp".into(), "type_".into()]
    }
}

#[doc = "A SAML identity provider."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SamlIdentityProvider {
    #[doc = "The ACS (Assertion Consumer Service) url."]
    pub acs_url: String,
    #[doc = "The date and time the SAML identity provider was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The unique identifier for the SAML identity provider."]
    pub id: uuid::Uuid,
    #[doc = "The entity ID of the SAML identity provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub idp_entity_id: Option<String>,
    #[doc = "The metadata document as a string."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub idp_metadata_document_string: Option<String>,
    #[doc = "The organization ID the SAML identity provider belongs to."]
    pub org_id: uuid::Uuid,
    #[doc = "The private key for the SAML identity provider. This is the PEM corresponding to the X509 pair."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private_key: Option<base64::Base64Data>,
    #[doc = "The public certificate for the SAML identity provider. This is the PEM corresponding to the X509 pair."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_cert: Option<base64::Base64Data>,
    #[doc = "The SLO (Single Logout) url."]
    pub slo_url: String,
    #[doc = "The technical contact email address for the SAML identity provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub technical_contact_email: Option<String>,
    #[doc = "The date and time the SAML identity provider was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for SamlIdentityProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SamlIdentityProvider {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.acs_url.clone().into(),
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.id).into(),
            if let Some(idp_entity_id) = &self.idp_entity_id {
                format!("{:?}", idp_entity_id).into()
            } else {
                String::new().into()
            },
            if let Some(idp_metadata_document_string) = &self.idp_metadata_document_string {
                format!("{:?}", idp_metadata_document_string).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.org_id).into(),
            if let Some(private_key) = &self.private_key {
                format!("{:?}", private_key).into()
            } else {
                String::new().into()
            },
            if let Some(public_cert) = &self.public_cert {
                format!("{:?}", public_cert).into()
            } else {
                String::new().into()
            },
            self.slo_url.clone().into(),
            if let Some(technical_contact_email) = &self.technical_contact_email {
                format!("{:?}", technical_contact_email).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "acs_url".into(),
            "created_at".into(),
            "id".into(),
            "idp_entity_id".into(),
            "idp_metadata_document_string".into(),
            "org_id".into(),
            "private_key".into(),
            "public_cert".into(),
            "slo_url".into(),
            "technical_contact_email".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "Parameters for creating a SAML identity provider."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SamlIdentityProviderCreate {
    #[doc = "The entity ID of the SAML identity provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub idp_entity_id: Option<String>,
    #[doc = "The source of an identity provider metadata descriptor."]
    pub idp_metadata_source: IdpMetadataSource,
    #[doc = "The request signing key pair."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signing_keypair: Option<DerEncodedKeyPair>,
    #[doc = "The technical contact email address for the SAML identity provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub technical_contact_email: Option<String>,
}

impl std::fmt::Display for SamlIdentityProviderCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SamlIdentityProviderCreate {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(idp_entity_id) = &self.idp_entity_id {
                format!("{:?}", idp_entity_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.idp_metadata_source).into(),
            if let Some(signing_keypair) = &self.signing_keypair {
                format!("{:?}", signing_keypair).into()
            } else {
                String::new().into()
            },
            if let Some(technical_contact_email) = &self.technical_contact_email {
                format!("{:?}", technical_contact_email).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "idp_entity_id".into(),
            "idp_metadata_source".into(),
            "signing_keypair".into(),
            "technical_contact_email".into(),
        ]
    }
}

#[doc = "The response from the `SceneClearAll` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SceneClearAll {}

impl std::fmt::Display for SceneClearAll {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SceneClearAll {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The type of scene selection change"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum SceneSelectionType {
    #[doc = "Replaces the selection"]
    #[serde(rename = "replace")]
    #[display("replace")]
    Replace,
    #[doc = "Adds to the selection"]
    #[serde(rename = "add")]
    #[display("add")]
    Add,
    #[doc = "Removes from the selection"]
    #[serde(rename = "remove")]
    #[display("remove")]
    Remove,
}

#[doc = "The type of scene's active tool"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum SceneToolType {
    #[serde(rename = "camera_revolve")]
    #[display("camera_revolve")]
    CameraRevolve,
    #[serde(rename = "select")]
    #[display("select")]
    Select,
    #[serde(rename = "move")]
    #[display("move")]
    Move,
    #[serde(rename = "sketch_line")]
    #[display("sketch_line")]
    SketchLine,
    #[serde(rename = "sketch_tangential_arc")]
    #[display("sketch_tangential_arc")]
    SketchTangentialArc,
    #[serde(rename = "sketch_curve")]
    #[display("sketch_curve")]
    SketchCurve,
    #[serde(rename = "sketch_curve_mod")]
    #[display("sketch_curve_mod")]
    SketchCurveMod,
}

#[doc = "The response from the `SelectAdd` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SelectAdd {}

impl std::fmt::Display for SelectAdd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SelectAdd {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SelectClear` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SelectClear {}

impl std::fmt::Display for SelectClear {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SelectClear {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SelectGet` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SelectGet {
    #[doc = "The UUIDs of the selected entities."]
    pub entity_ids: Vec<uuid::Uuid>,
}

impl std::fmt::Display for SelectGet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SelectGet {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.entity_ids).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_ids".into()]
    }
}

#[doc = "The response from the `SelectRemove` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SelectRemove {}

impl std::fmt::Display for SelectRemove {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SelectRemove {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SelectReplace` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SelectReplace {}

impl std::fmt::Display for SelectReplace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SelectReplace {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SelectWithPoint` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SelectWithPoint {
    #[doc = "The UUID of the entity that was selected."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity_id: Option<uuid::Uuid>,
}

impl std::fmt::Display for SelectWithPoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SelectWithPoint {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(entity_id) = &self.entity_id {
            format!("{:?}", entity_id).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["entity_id".into()]
    }
}

#[doc = "Data item selection."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum Selection {
    #[doc = "Visit the default scene."]
    #[serde(rename = "default_scene")]
    DefaultScene {},
    #[doc = "Visit the indexed scene."]
    #[serde(rename = "scene_by_index")]
    SceneByIndex {
        #[doc = "The index."]
        index: u32,
    },
    #[doc = "Visit the first scene with the given name."]
    #[serde(rename = "scene_by_name")]
    SceneByName {
        #[doc = "The name."]
        name: String,
    },
    #[doc = "Visit the indexed mesh."]
    #[serde(rename = "mesh_by_index")]
    MeshByIndex {
        #[doc = "The index."]
        index: u32,
    },
    #[doc = "Visit the first mesh with the given name."]
    #[serde(rename = "mesh_by_name")]
    MeshByName {
        #[doc = "The name."]
        name: String,
    },
}

#[doc = "The response from the `SendObject` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SendObject {}

impl std::fmt::Display for SendObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SendObject {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "A service account.\n\nThese are used to authenticate orgs with Bearer authentication.\n\nThis works just like an API token, but it is tied to an organization versus an individual user."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ServiceAccount {
    #[doc = "The date and time the API token was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The unique identifier for the API token."]
    pub id: uuid::Uuid,
    #[doc = "If the token is valid. We never delete API tokens, but we can mark them as invalid. We save them for ever to preserve the history of the API token."]
    pub is_valid: bool,
    #[doc = "An optional label for the API token."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[doc = "The ID of the organization that owns the API token."]
    pub org_id: uuid::Uuid,
    #[doc = "The API token itself."]
    pub token: String,
    #[doc = "The date and time the API token was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for ServiceAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ServiceAccount {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.is_valid).into(),
            if let Some(label) = &self.label {
                format!("{:?}", label).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.org_id).into(),
            self.token.clone().into(),
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "id".into(),
            "is_valid".into(),
            "label".into(),
            "org_id".into(),
            "token".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ServiceAccountResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<ServiceAccount>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ServiceAccountResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ServiceAccountResultsPage {
    type Item = ServiceAccount;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ServiceAccountResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "An authentication session."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Session {
    #[doc = "The date and time the session was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The date and time the session expires."]
    pub expires: chrono::DateTime<chrono::Utc>,
    #[doc = "The unique identifier for the session."]
    pub id: uuid::Uuid,
    #[doc = "The session token."]
    pub session_token: String,
    #[doc = "The date and time the session was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user that the session belongs to."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for Session {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Session {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.expires).into(),
            format!("{:?}", self.id).into(),
            self.session_token.clone().into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "expires".into(),
            "id".into(),
            "session_token".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The response from the `SetBackgroundColor` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetBackgroundColor {}

impl std::fmt::Display for SetBackgroundColor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetBackgroundColor {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SetCurrentToolProperties` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetCurrentToolProperties {}

impl std::fmt::Display for SetCurrentToolProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetCurrentToolProperties {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SetDefaultSystemProperties` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetDefaultSystemProperties {}

impl std::fmt::Display for SetDefaultSystemProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetDefaultSystemProperties {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the 'SetGridScale'."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetGridAutoScale {}

impl std::fmt::Display for SetGridAutoScale {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetGridAutoScale {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the 'SetGridReferencePlane'."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetGridReferencePlane {}

impl std::fmt::Display for SetGridReferencePlane {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetGridReferencePlane {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the 'SetGridScale'."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetGridScale {}

impl std::fmt::Display for SetGridScale {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetGridScale {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SetObjectTransform` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetObjectTransform {}

impl std::fmt::Display for SetObjectTransform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetObjectTransform {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SetSceneUnits` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetSceneUnits {}

impl std::fmt::Display for SetSceneUnits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetSceneUnits {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SetSelectionFilter` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetSelectionFilter {}

impl std::fmt::Display for SetSelectionFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetSelectionFilter {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SetSelectionType` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetSelectionType {}

impl std::fmt::Display for SetSelectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetSelectionType {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `SetTool` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SetTool {}

impl std::fmt::Display for SetTool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SetTool {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "A short url."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Shortlink {
    #[doc = "The date and time the shortlink was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The unique identifier for the shortlink."]
    pub id: uuid::Uuid,
    #[doc = "The key of the shortlink. This is the short part of the URL."]
    pub key: String,
    #[doc = "The organization ID of the shortlink."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub org_id: Option<uuid::Uuid>,
    #[doc = "The hash of the password for the shortlink."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_hash: Option<String>,
    #[doc = "If the shortlink should be restricted to the organization. This only applies to org shortlinks. If you are creating a user shortlink and you are not a member of a team or enterprise and you try to set this to true, it will fail."]
    #[serde(default)]
    pub restrict_to_org: bool,
    #[doc = "The date and time the shortlink was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The ID of the user that made the shortlink."]
    pub user_id: uuid::Uuid,
    #[doc = "The URL the shortlink redirects to."]
    pub value: String,
}

impl std::fmt::Display for Shortlink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Shortlink {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.id).into(),
            self.key.clone().into(),
            if let Some(org_id) = &self.org_id {
                format!("{:?}", org_id).into()
            } else {
                String::new().into()
            },
            if let Some(password_hash) = &self.password_hash {
                format!("{:?}", password_hash).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.restrict_to_org).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
            self.value.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "id".into(),
            "key".into(),
            "org_id".into(),
            "password_hash".into(),
            "restrict_to_org".into(),
            "updated_at".into(),
            "user_id".into(),
            "value".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ShortlinkResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Shortlink>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ShortlinkResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ShortlinkResultsPage {
    type Item = Shortlink;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ShortlinkResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "IDs for a side face, extruded from the path of some sketch/2D shape."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SideFace {
    #[doc = "Desired ID for the resulting face."]
    pub face_id: uuid::Uuid,
    #[doc = "ID of the path this face is being extruded from."]
    pub path_id: uuid::Uuid,
}

impl std::fmt::Display for SideFace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SideFace {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.face_id).into(),
            format!("{:?}", self.path_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["face_id".into(), "path_id".into()]
    }
}

#[doc = "The response from the `SketchModeDisable` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SketchModeDisable {}

impl std::fmt::Display for SketchModeDisable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SketchModeDisable {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `Solid2dAddHole` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid2DAddHole {}

impl std::fmt::Display for Solid2DAddHole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid2DAddHole {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The response from the `Solid3dFilletEdge` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DFilletEdge {}

impl std::fmt::Display for Solid3DFilletEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DFilletEdge {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "Extrusion face info struct (useful for maintaining mappings between source path segment ids and extrusion faces) This includes the opposite and adjacent faces and edges."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetAdjacencyInfo {
    #[doc = "Details of each edge."]
    pub edges: Vec<AdjacencyInfo>,
}

impl std::fmt::Display for Solid3DGetAdjacencyInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetAdjacencyInfo {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.edges).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edges".into()]
    }
}

#[doc = "The response from the `Solid3dGetAllEdgeFaces` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetAllEdgeFaces {
    #[doc = "The UUIDs of the faces."]
    pub faces: Vec<uuid::Uuid>,
}

impl std::fmt::Display for Solid3DGetAllEdgeFaces {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetAllEdgeFaces {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.faces).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["faces".into()]
    }
}

#[doc = "The response from the `Solid3dGetAllOppositeEdges` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetAllOppositeEdges {
    #[doc = "The UUIDs of the edges."]
    pub edges: Vec<uuid::Uuid>,
}

impl std::fmt::Display for Solid3DGetAllOppositeEdges {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetAllOppositeEdges {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.edges).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edges".into()]
    }
}

#[doc = "The response from the `Solid3DGetCommonEdge` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetCommonEdge {
    #[doc = "The UUID of the common edge, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub edge: Option<uuid::Uuid>,
}

impl std::fmt::Display for Solid3DGetCommonEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetCommonEdge {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(edge) = &self.edge {
            format!("{:?}", edge).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edge".into()]
    }
}

#[doc = "Extrusion face info struct (useful for maintaining mappings between source path segment ids and extrusion faces)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetExtrusionFaceInfo {
    #[doc = "Details of each face."]
    pub faces: Vec<ExtrusionFaceInfo>,
}

impl std::fmt::Display for Solid3DGetExtrusionFaceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetExtrusionFaceInfo {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.faces).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["faces".into()]
    }
}

#[doc = "The response from the `Solid3dGetNextAdjacentEdge` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetNextAdjacentEdge {
    #[doc = "The UUID of the edge."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub edge: Option<uuid::Uuid>,
}

impl std::fmt::Display for Solid3DGetNextAdjacentEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetNextAdjacentEdge {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(edge) = &self.edge {
            format!("{:?}", edge).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edge".into()]
    }
}

#[doc = "The response from the `Solid3dGetOppositeEdge` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetOppositeEdge {
    #[doc = "The UUID of the edge."]
    pub edge: uuid::Uuid,
}

impl std::fmt::Display for Solid3DGetOppositeEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetOppositeEdge {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.edge).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edge".into()]
    }
}

#[doc = "The response from the `Solid3dGetPrevAdjacentEdge` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DGetPrevAdjacentEdge {
    #[doc = "The UUID of the edge."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub edge: Option<uuid::Uuid>,
}

impl std::fmt::Display for Solid3DGetPrevAdjacentEdge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DGetPrevAdjacentEdge {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![if let Some(edge) = &self.edge {
            format!("{:?}", edge).into()
        } else {
            String::new().into()
        }]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["edge".into()]
    }
}

#[doc = "The response from the `Solid3dShellFace` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Solid3DShellFace {}

impl std::fmt::Display for Solid3DShellFace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Solid3DShellFace {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "A position in the source code."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SourcePosition {
    #[doc = "The column number."]
    pub column: u32,
    #[doc = "The line number."]
    pub line: u32,
}

impl std::fmt::Display for SourcePosition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SourcePosition {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.column).into(),
            format!("{:?}", self.line).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["column".into(), "line".into()]
    }
}

#[doc = "A source range of code."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SourceRange {
    #[doc = "The end of the range."]
    pub end: SourcePosition,
    #[doc = "The start of the range."]
    pub start: SourcePosition,
}

impl std::fmt::Display for SourceRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SourceRange {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.end).into(),
            format!("{:?}", self.start).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["end".into(), "start".into()]
    }
}

#[doc = "A source range and prompt for a text to CAD iteration."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SourceRangePrompt {
    #[doc = "The name of the file the source range applies to. This is the relative path to the file from the root of the project. This only applies to multi-file iterations."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub file: Option<String>,
    #[doc = "The prompt for the changes."]
    pub prompt: String,
    #[doc = "The range of the source code to change. If you want to apply the prompt to the whole file, set the start to 0 and the end to the end of the file."]
    pub range: SourceRange,
}

impl std::fmt::Display for SourceRangePrompt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SourceRangePrompt {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(file) = &self.file {
                format!("{:?}", file).into()
            } else {
                String::new().into()
            },
            self.prompt.clone().into(),
            format!("{:?}", self.range).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["file".into(), "prompt".into(), "range".into()]
    }
}

#[doc = "The response from the `StartPath` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct StartPath {}

impl std::fmt::Display for StartPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for StartPath {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "Export storage."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum StlStorage {
    #[doc = "Plaintext encoding."]
    #[serde(rename = "ascii")]
    #[display("ascii")]
    Ascii,
    #[doc = "Binary STL encoding.\n\nThis is the default setting."]
    #[serde(rename = "binary")]
    #[display("binary")]
    Binary,
}

#[doc = "The parameters for a new store coupon."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct StoreCouponParams {
    #[doc = "The percentage off."]
    pub percent_off: u32,
}

impl std::fmt::Display for StoreCouponParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for StoreCouponParams {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.percent_off).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["percent_off".into()]
    }
}

#[doc = "The data for subscribing a user to the newsletter."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Subscribe {
    #[doc = "The email"]
    pub email: String,
}

impl std::fmt::Display for Subscribe {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Subscribe {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.email.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["email".into()]
    }
}

#[doc = "A subscription tier feature."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SubscriptionTierFeature {
    #[doc = "Information about the feature."]
    pub info: String,
}

impl std::fmt::Display for SubscriptionTierFeature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SubscriptionTierFeature {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.info.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["info".into()]
    }
}

#[doc = "The price for a subscription tier."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum SubscriptionTierPrice {
    #[doc = "A flat price that we publicly list."]
    #[serde(rename = "flat")]
    Flat {
        #[doc = "The interval the price is charged."]
        interval: PlanInterval,
        #[doc = "The price."]
        price: f64,
    },
    #[doc = "A per user price that we publicly list."]
    #[serde(rename = "per_user")]
    PerUser {
        #[doc = "The interval the price is charged."]
        interval: PlanInterval,
        #[doc = "The price."]
        price: f64,
    },
    #[doc = "Enterprise: The price is not listed and the user needs to contact sales."]
    #[serde(rename = "enterprise")]
    Enterprise {},
}

#[doc = "An enum representing a subscription tier type."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum SubscriptionTierType {
    #[doc = "A subscription tier that can be applied to individuals only."]
    #[serde(rename = "individual")]
    Individual {},
    #[doc = "An subscription tier that can be applied to organizations only."]
    #[serde(rename = "organization")]
    Organization {
        #[doc = "Whether or not the subscription type supports SAML SSO."]
        saml_sso: bool,
    },
}

#[doc = "An enum representing a subscription training data behavior."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum SubscriptionTrainingDataBehavior {
    #[doc = "The data is always used for training and cannot be turned off."]
    #[serde(rename = "always")]
    #[display("always")]
    Always,
    #[doc = "The data is used for training by default, but can be turned off."]
    #[serde(rename = "default_on")]
    #[display("default_on")]
    DefaultOn,
    #[doc = "The data is not used for training by default, but can be turned on."]
    #[serde(rename = "default_off")]
    #[display("default_off")]
    DefaultOff,
}

#[doc = "Successful Websocket response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SuccessWebSocketResponse {
    #[doc = "Which request this is a response to. If the request was a modeling command, this is the modeling command ID. If no request ID was sent, this will be null."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<uuid::Uuid>,
    #[doc = "The data sent with a successful response. This will be flattened into a 'type' and 'data' field."]
    pub resp: OkWebSocketResponseData,
    #[doc = "Always true"]
    pub success: bool,
}

impl std::fmt::Display for SuccessWebSocketResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SuccessWebSocketResponse {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(request_id) = &self.request_id {
                format!("{:?}", request_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.resp).into(),
            format!("{:?}", self.success).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["request_id".into(), "resp".into(), "success".into()]
    }
}

#[doc = "The support tier the subscription provides."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum SupportTier {
    #[doc = "Community support."]
    #[serde(rename = "community")]
    #[display("community")]
    Community,
    #[doc = "Standard email support."]
    #[serde(rename = "standard_email")]
    #[display("standard_email")]
    StandardEmail,
    #[doc = "Priority email support."]
    #[serde(rename = "priority_email")]
    #[display("priority_email")]
    PriorityEmail,
    #[doc = "Premium support."]
    #[serde(rename = "premium")]
    #[display("premium")]
    Premium,
}

#[doc = "The surface area response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SurfaceArea {
    #[doc = "The output unit for the surface area."]
    pub output_unit: UnitArea,
    #[doc = "The surface area."]
    pub surface_area: f64,
}

impl std::fmt::Display for SurfaceArea {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SurfaceArea {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.surface_area).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["output_unit".into(), "surface_area".into()]
    }
}

#[doc = "The response from the `Sweep` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Sweep {}

impl std::fmt::Display for Sweep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Sweep {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "Co-ordinate system definition.\n\nThe `up` axis must be orthogonal to the `forward` axis.\n\nSee [cglearn.eu] for background reading.\n\n[cglearn.eu](https://cglearn.eu/pub/computer-graphics/introduction-to-geometry#material-coordinate-systems-1)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct System {
    #[doc = "Axis the front face of a model looks along."]
    pub forward: AxisDirectionPair,
    #[doc = "Axis pointing up and away from a model."]
    pub up: AxisDirectionPair,
}

impl std::fmt::Display for System {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for System {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.forward).into(),
            format!("{:?}", self.up).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["forward".into(), "up".into()]
    }
}

#[doc = "The response from the `TakeSnapshot` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TakeSnapshot {
    #[doc = "Contents of the image."]
    pub contents: base64::Base64Data,
}

impl std::fmt::Display for TakeSnapshot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TakeSnapshot {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.contents).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["contents".into()]
    }
}

#[doc = "A response from a text to CAD prompt."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCad {
    #[doc = "The code for the model. This is optional but will be required in the future once we are at v1."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "Feedback from the user, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub feedback: Option<MlFeedback>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The version of kcl requested."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kcl_version: Option<String>,
    #[doc = "The model being used."]
    pub model: TextToCadModel,
    #[doc = "The version of the model."]
    pub model_version: String,
    #[doc = "The output format of the model."]
    pub output_format: FileExportFormat,
    #[doc = "The output of the model in the given file format the user requested, base64 encoded. The key of the map is the path of the output file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub outputs: Option<std::collections::HashMap<String, base64::Base64Data>>,
    #[doc = "The prompt."]
    pub prompt: String,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for TextToCad {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCad {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(code) = &self.code {
                format!("{:?}", code).into()
            } else {
                String::new().into()
            },
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            if let Some(feedback) = &self.feedback {
                format!("{:?}", feedback).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(kcl_version) = &self.kcl_version {
                format!("{:?}", kcl_version).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.model).into(),
            self.model_version.clone().into(),
            format!("{:?}", self.output_format).into(),
            if let Some(outputs) = &self.outputs {
                format!("{:?}", outputs).into()
            } else {
                String::new().into()
            },
            self.prompt.clone().into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "code".into(),
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "feedback".into(),
            "id".into(),
            "kcl_version".into(),
            "model".into(),
            "model_version".into(),
            "output_format".into(),
            "outputs".into(),
            "prompt".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "Body for generating models from text."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCadCreateBody {
    #[doc = "The version of kcl to use. If empty, the latest version will be used."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kcl_version: Option<String>,
    #[doc = "The project name. This is used to tie the prompt to a project. Which helps us make our models better over time."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_name: Option<String>,
    #[doc = "The prompt for the model."]
    pub prompt: String,
}

impl std::fmt::Display for TextToCadCreateBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCadCreateBody {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(kcl_version) = &self.kcl_version {
                format!("{:?}", kcl_version).into()
            } else {
                String::new().into()
            },
            if let Some(project_name) = &self.project_name {
                format!("{:?}", project_name).into()
            } else {
                String::new().into()
            },
            self.prompt.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["kcl_version".into(), "project_name".into(), "prompt".into()]
    }
}

#[doc = "A response from a text to CAD iteration."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCadIteration {
    #[doc = "The code for the new model."]
    pub code: String,
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "Feedback from the user, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub feedback: Option<MlFeedback>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The model being used."]
    pub model: TextToCadModel,
    #[doc = "The version of the model."]
    pub model_version: String,
    #[doc = "The original source code for the model, previous to the changes."]
    pub original_source_code: String,
    #[doc = "The prompt for the overall changes. This is optional if you only want changes on specific source ranges."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prompt: Option<String>,
    #[doc = "The source ranges the user suggested to change."]
    pub source_ranges: Vec<SourceRangePrompt>,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for TextToCadIteration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCadIteration {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.code.clone().into(),
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            if let Some(feedback) = &self.feedback {
                format!("{:?}", feedback).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            format!("{:?}", self.model).into(),
            self.model_version.clone().into(),
            self.original_source_code.clone().into(),
            if let Some(prompt) = &self.prompt {
                format!("{:?}", prompt).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.source_ranges).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "code".into(),
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "feedback".into(),
            "id".into(),
            "model".into(),
            "model_version".into(),
            "original_source_code".into(),
            "prompt".into(),
            "source_ranges".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "Body for generating models from text."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCadIterationBody {
    #[doc = "The version of kcl to use. If empty, the latest version will be used."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kcl_version: Option<String>,
    #[doc = "The source code for the model (in kcl) that is to be edited."]
    pub original_source_code: String,
    #[doc = "The project name. This is used to tie the prompt to a project. Which helps us make our models better over time."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_name: Option<String>,
    #[doc = "The prompt for the model, if not using source ranges."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prompt: Option<String>,
    #[doc = "The source ranges the user suggested to change. If empty, the prompt will be used and is required."]
    pub source_ranges: Vec<SourceRangePrompt>,
}

impl std::fmt::Display for TextToCadIterationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCadIterationBody {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(kcl_version) = &self.kcl_version {
                format!("{:?}", kcl_version).into()
            } else {
                String::new().into()
            },
            self.original_source_code.clone().into(),
            if let Some(project_name) = &self.project_name {
                format!("{:?}", project_name).into()
            } else {
                String::new().into()
            },
            if let Some(prompt) = &self.prompt {
                format!("{:?}", prompt).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.source_ranges).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "kcl_version".into(),
            "original_source_code".into(),
            "project_name".into(),
            "prompt".into(),
            "source_ranges".into(),
        ]
    }
}

#[doc = "A type of Text-to-CAD model."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum TextToCadModel {
    #[doc = "CAD."]
    #[serde(rename = "cad")]
    #[display("cad")]
    Cad,
    #[doc = "KCL."]
    #[serde(rename = "kcl")]
    #[display("kcl")]
    Kcl,
    #[doc = "KCL iteration."]
    #[serde(rename = "kcl_iteration")]
    #[display("kcl_iteration")]
    KclIteration,
}

#[doc = "A response from a text to CAD multi-file iteration."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCadMultiFileIteration {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The conversation ID Conversations group different prompts together."]
    pub conversation_id: uuid::Uuid,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "Feedback from the user, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub feedback: Option<MlFeedback>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The version of kcl to use. If empty, the latest version will be used."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kcl_version: Option<String>,
    #[doc = "The model being used."]
    pub model: TextToCadModel,
    #[doc = "The version of the model."]
    pub model_version: String,
    #[doc = "The output files. Returns a map of the file name to the file contents. The file contents are not encoded since kcl files are not binary."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub outputs: Option<std::collections::HashMap<String, String>>,
    #[doc = "The project name. This is used to tie the prompt to a project. Which helps us make our models better over time."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_name: Option<String>,
    #[doc = "The prompt for the overall changes. This is optional if you only want changes on specific source ranges. This will apply to all the files."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prompt: Option<String>,
    #[doc = "The source ranges the user suggested to change."]
    pub source_ranges: Vec<SourceRangePrompt>,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for TextToCadMultiFileIteration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCadMultiFileIteration {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.conversation_id).into(),
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            if let Some(feedback) = &self.feedback {
                format!("{:?}", feedback).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(kcl_version) = &self.kcl_version {
                format!("{:?}", kcl_version).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.model).into(),
            self.model_version.clone().into(),
            if let Some(outputs) = &self.outputs {
                format!("{:?}", outputs).into()
            } else {
                String::new().into()
            },
            if let Some(project_name) = &self.project_name {
                format!("{:?}", project_name).into()
            } else {
                String::new().into()
            },
            if let Some(prompt) = &self.prompt {
                format!("{:?}", prompt).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.source_ranges).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "conversation_id".into(),
            "created_at".into(),
            "error".into(),
            "feedback".into(),
            "id".into(),
            "kcl_version".into(),
            "model".into(),
            "model_version".into(),
            "outputs".into(),
            "project_name".into(),
            "prompt".into(),
            "source_ranges".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "Body for iterating on models from text prompts."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCadMultiFileIterationBody {
    #[doc = "The conversation ID Conversations group different prompts together. This should be omitted when starting a new conversation. The conversation_id returned in the response should be used to link future messages in the same conversation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conversation_id: Option<uuid::Uuid>,
    #[doc = "The version of kcl to use. If empty, the latest version will be used."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kcl_version: Option<String>,
    #[doc = "The project name. This is used to tie the prompt to a project. Which helps us make our models better over time."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_name: Option<String>,
    #[doc = "The prompt for the overall changes. This is optional if you only want changes on specific source ranges. This will apply to all the files. If you want to apply a prompt to just a single file, use the source_ranges field and you can leave this empty."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prompt: Option<String>,
    #[doc = "The source ranges the user suggested to change. If empty, the prompt will be used and is required."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source_ranges: Option<Vec<SourceRangePrompt>>,
}

impl std::fmt::Display for TextToCadMultiFileIterationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCadMultiFileIterationBody {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(conversation_id) = &self.conversation_id {
                format!("{:?}", conversation_id).into()
            } else {
                String::new().into()
            },
            if let Some(kcl_version) = &self.kcl_version {
                format!("{:?}", kcl_version).into()
            } else {
                String::new().into()
            },
            if let Some(project_name) = &self.project_name {
                format!("{:?}", project_name).into()
            } else {
                String::new().into()
            },
            if let Some(prompt) = &self.prompt {
                format!("{:?}", prompt).into()
            } else {
                String::new().into()
            },
            if let Some(source_ranges) = &self.source_ranges {
                format!("{:?}", source_ranges).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "conversation_id".into(),
            "kcl_version".into(),
            "project_name".into(),
            "prompt".into(),
            "source_ranges".into(),
        ]
    }
}

#[doc = "Type that encompasses all Text-to-CAD response types, including iteration and multi-file iteration."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCadResponse {
    #[doc = "The code for the new model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "Feedback from the user, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub feedback: Option<MlFeedback>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<uuid::Uuid>,
    #[doc = "The version of kcl to use. If empty, the latest version will be used."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kcl_version: Option<String>,
    #[doc = "The model being used."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub model: Option<TextToCadModel>,
    #[doc = "The version of the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub model_version: Option<String>,
    #[doc = "The output format of the model."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output_format: Option<FileExportFormat>,
    #[doc = "The output files. Returns a map of the file name to the file contents. The file contents are not encoded since kcl files are not binary."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub outputs: Option<std::collections::HashMap<String, String>>,
    #[doc = "The prompt for the overall changes. This is optional if you only want changes on specific source ranges. This will apply to all the files."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prompt: Option<String>,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<ApiCallStatus>,
    #[doc = "The time and date the API call was last updated."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The user ID of the user who created the API call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<uuid::Uuid>,
    #[doc = "The original source code for the model, previous to the changes."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub original_source_code: Option<String>,
    #[doc = "The source ranges the user suggested to change."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source_ranges: Option<Vec<SourceRangePrompt>>,
    #[doc = "The conversation ID Conversations group different prompts together."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conversation_id: Option<uuid::Uuid>,
    #[doc = "The project name. This is used to tie the prompt to a project. Which helps us make our models better over time."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_name: Option<String>,
}

impl std::fmt::Display for TextToCadResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCadResponse {
    const LENGTH: usize = 20;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(code) = &self.code {
                format!("{:?}", code).into()
            } else {
                String::new().into()
            },
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            if let Some(created_at) = &self.created_at {
                format!("{:?}", created_at).into()
            } else {
                String::new().into()
            },
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            if let Some(feedback) = &self.feedback {
                format!("{:?}", feedback).into()
            } else {
                String::new().into()
            },
            if let Some(id) = &self.id {
                format!("{:?}", id).into()
            } else {
                String::new().into()
            },
            if let Some(kcl_version) = &self.kcl_version {
                format!("{:?}", kcl_version).into()
            } else {
                String::new().into()
            },
            if let Some(model) = &self.model {
                format!("{:?}", model).into()
            } else {
                String::new().into()
            },
            if let Some(model_version) = &self.model_version {
                format!("{:?}", model_version).into()
            } else {
                String::new().into()
            },
            if let Some(output_format) = &self.output_format {
                format!("{:?}", output_format).into()
            } else {
                String::new().into()
            },
            if let Some(outputs) = &self.outputs {
                format!("{:?}", outputs).into()
            } else {
                String::new().into()
            },
            if let Some(prompt) = &self.prompt {
                format!("{:?}", prompt).into()
            } else {
                String::new().into()
            },
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            if let Some(status) = &self.status {
                format!("{:?}", status).into()
            } else {
                String::new().into()
            },
            if let Some(updated_at) = &self.updated_at {
                format!("{:?}", updated_at).into()
            } else {
                String::new().into()
            },
            if let Some(user_id) = &self.user_id {
                format!("{:?}", user_id).into()
            } else {
                String::new().into()
            },
            if let Some(original_source_code) = &self.original_source_code {
                format!("{:?}", original_source_code).into()
            } else {
                String::new().into()
            },
            if let Some(source_ranges) = &self.source_ranges {
                format!("{:?}", source_ranges).into()
            } else {
                String::new().into()
            },
            if let Some(conversation_id) = &self.conversation_id {
                format!("{:?}", conversation_id).into()
            } else {
                String::new().into()
            },
            if let Some(project_name) = &self.project_name {
                format!("{:?}", project_name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "code".into(),
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "feedback".into(),
            "id".into(),
            "kcl_version".into(),
            "model".into(),
            "model_version".into(),
            "output_format".into(),
            "outputs".into(),
            "prompt".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
            "original_source_code".into(),
            "source_ranges".into(),
            "conversation_id".into(),
            "project_name".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TextToCadResponseResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<TextToCadResponse>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for TextToCadResponseResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for TextToCadResponseResultsPage {
    type Item = TextToCadResponse;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TextToCadResponseResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "The request parameters for the OAuth 2.0 token revocation flow."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TokenRevokeRequestForm {
    #[doc = "The client ID."]
    pub client_id: uuid::Uuid,
    #[doc = "The client secret."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<String>,
    #[doc = "The token to revoke."]
    pub token: String,
}

impl std::fmt::Display for TokenRevokeRequestForm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TokenRevokeRequestForm {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.client_id).into(),
            if let Some(client_secret) = &self.client_secret {
                format!("{:?}", client_secret).into()
            } else {
                String::new().into()
            },
            self.token.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["client_id".into(), "client_secret".into(), "token".into()]
    }
}

#[doc = "Ways to transform each solid being replicated in a repeating pattern."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Transform {
    #[doc = "Whether to replicate the original solid in this instance."]
    #[serde(default)]
    pub replicate: bool,
    #[doc = "Rotate the replica about the specified rotation axis and origin. Defaults to no rotation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rotation: Option<Rotation>,
    #[doc = "Scale the replica's size along each axis. Defaults to (1, 1, 1) (i.e. the same size as the original)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<Point3D>,
    #[doc = "Translate the replica this far along each dimension. Defaults to zero vector (i.e. same position as the original)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<Point3D>,
}

impl std::fmt::Display for Transform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Transform {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.replicate).into(),
            if let Some(rotation) = &self.rotation {
                format!("{:?}", rotation).into()
            } else {
                String::new().into()
            },
            if let Some(scale) = &self.scale {
                format!("{:?}", scale).into()
            } else {
                String::new().into()
            },
            if let Some(translate) = &self.translate {
                format!("{:?}", translate).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "replicate".into(),
            "rotation".into(),
            "scale".into(),
            "translate".into(),
        ]
    }
}

#[doc = "How a property of an object should be transformed."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TransformByForPoint3D {
    #[doc = "If true, the transform is applied in local space. If false, the transform is applied in global space."]
    #[deprecated]
    pub is_local: bool,
    #[doc = "What to use as the origin for the transformation. If not provided, will fall back to local or global origin, depending on whatever the `is_local` field was set to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<OriginType>,
    #[doc = "The scale, or rotation, or translation."]
    pub property: Point3D,
    #[doc = "If true, overwrite the previous value with this. If false, the previous value will be modified. E.g. when translating, `set=true` will set a new location, and `set=false` will translate the current location by the given X/Y/Z."]
    pub set: bool,
}

impl std::fmt::Display for TransformByForPoint3D {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TransformByForPoint3D {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.is_local).into(),
            if let Some(origin) = &self.origin {
                format!("{:?}", origin).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.property).into(),
            format!("{:?}", self.set).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "is_local".into(),
            "origin".into(),
            "property".into(),
            "set".into(),
        ]
    }
}

#[doc = "How a property of an object should be transformed."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TransformByForPoint4D {
    #[doc = "If true, the transform is applied in local space. If false, the transform is applied in global space."]
    #[deprecated]
    pub is_local: bool,
    #[doc = "What to use as the origin for the transformation. If not provided, will fall back to local or global origin, depending on whatever the `is_local` field was set to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<OriginType>,
    #[doc = "The scale, or rotation, or translation."]
    pub property: Point4D,
    #[doc = "If true, overwrite the previous value with this. If false, the previous value will be modified. E.g. when translating, `set=true` will set a new location, and `set=false` will translate the current location by the given X/Y/Z."]
    pub set: bool,
}

impl std::fmt::Display for TransformByForPoint4D {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TransformByForPoint4D {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.is_local).into(),
            if let Some(origin) = &self.origin {
                format!("{:?}", origin).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.property).into(),
            format!("{:?}", self.set).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "is_local".into(),
            "origin".into(),
            "property".into(),
            "set".into(),
        ]
    }
}

#[doc = "The response from the `TwistExtrude` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TwistExtrude {}

impl std::fmt::Display for TwistExtrude {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TwistExtrude {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "The valid types of angle formats."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitAngle {
    #[doc = "Degrees <https://en.wikipedia.org/wiki/Degree_(angle)>"]
    #[serde(rename = "degrees")]
    #[display("degrees")]
    Degrees,
    #[doc = "Radians <https://en.wikipedia.org/wiki/Radian>"]
    #[serde(rename = "radians")]
    #[display("radians")]
    Radians,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitAngleConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitAngle,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitAngle,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitAngleConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitAngleConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of area units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitArea {
    #[doc = "Square centimeters <https://en.wikipedia.org/wiki/Square_centimeter>"]
    #[serde(rename = "cm2")]
    #[display("cm2")]
    Cm2,
    #[doc = "Square decimeters <https://en.wikipedia.org/wiki/Square_decimeter>"]
    #[serde(rename = "dm2")]
    #[display("dm2")]
    Dm2,
    #[doc = "Square feet <https://en.wikipedia.org/wiki/Square_foot>"]
    #[serde(rename = "ft2")]
    #[display("ft2")]
    Ft2,
    #[doc = "Square inches <https://en.wikipedia.org/wiki/Square_inch>"]
    #[serde(rename = "in2")]
    #[display("in2")]
    In2,
    #[doc = "Square kilometers <https://en.wikipedia.org/wiki/Square_kilometer>"]
    #[serde(rename = "km2")]
    #[display("km2")]
    Km2,
    #[doc = "Square meters <https://en.wikipedia.org/wiki/Square_meter>"]
    #[serde(rename = "m2")]
    #[display("m2")]
    M2,
    #[doc = "Square millimeters <https://en.wikipedia.org/wiki/Square_millimeter>"]
    #[serde(rename = "mm2")]
    #[display("mm2")]
    Mm2,
    #[doc = "Square yards <https://en.wikipedia.org/wiki/Square_mile>"]
    #[serde(rename = "yd2")]
    #[display("yd2")]
    Yd2,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitAreaConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitArea,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitArea,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitAreaConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitAreaConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of current units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitCurrent {
    #[doc = "Amperes <https://en.wikipedia.org/wiki/Ampere>"]
    #[serde(rename = "amperes")]
    #[display("amperes")]
    Amperes,
    #[doc = "Microamperes <https://en.wikipedia.org/wiki/Microampere>"]
    #[serde(rename = "microamperes")]
    #[display("microamperes")]
    Microamperes,
    #[doc = "Milliamperes <https://en.wikipedia.org/wiki/Milliampere>"]
    #[serde(rename = "milliamperes")]
    #[display("milliamperes")]
    Milliamperes,
    #[doc = "Nanoamperes <https://en.wikipedia.org/wiki/Nanoampere>"]
    #[serde(rename = "nanoamperes")]
    #[display("nanoamperes")]
    Nanoamperes,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitCurrentConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitCurrent,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitCurrent,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitCurrentConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitCurrentConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types for density units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitDensity {
    #[doc = "Pounds per cubic feet."]
    #[serde(rename = "lb:ft3")]
    #[display("lb:ft3")]
    LbFt3,
    #[doc = "Kilograms per cubic meter."]
    #[serde(rename = "kg:m3")]
    #[display("kg:m3")]
    KgM3,
}

#[doc = "The valid types of energy units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitEnergy {
    #[doc = "British Thermal Unit (BTU) <https://en.wikipedia.org/wiki/British_thermal_unit>"]
    #[serde(rename = "btu")]
    #[display("btu")]
    Btu,
    #[doc = "Electron Volts (eV) <https://en.wikipedia.org/wiki/Electronvolt>"]
    #[serde(rename = "electronvolts")]
    #[display("electronvolts")]
    Electronvolts,
    #[doc = "Joules (or watt-seconds) <https://en.wikipedia.org/wiki/Joule>"]
    #[serde(rename = "joules")]
    #[display("joules")]
    Joules,
    #[doc = "Kilocalories (often just called calories) <https://en.wikipedia.org/wiki/Kilocalorie>"]
    #[serde(rename = "kilocalories")]
    #[display("kilocalories")]
    Kilocalories,
    #[doc = "Kilowatt hours (kWh) <https://en.wikipedia.org/wiki/Kilowatt-hour>"]
    #[serde(rename = "kilowatt_hours")]
    #[display("kilowatt_hours")]
    KilowattHours,
    #[doc = "Watt hours (Wh) <https://en.wikipedia.org/wiki/Kilowatt-hour>"]
    #[serde(rename = "watt_hours")]
    #[display("watt_hours")]
    WattHours,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitEnergyConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitEnergy,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitEnergy,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitEnergyConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitEnergyConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of force units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitForce {
    #[doc = "Dynes <https://en.wikipedia.org/wiki/Dyne>"]
    #[serde(rename = "dynes")]
    #[display("dynes")]
    Dynes,
    #[doc = "Kiloponds <https://en.wikipedia.org/wiki/Kilopond>"]
    #[serde(rename = "kiloponds")]
    #[display("kiloponds")]
    Kiloponds,
    #[doc = "Micronewtons <https://en.wikipedia.org/wiki/Newton_(unit)>"]
    #[serde(rename = "micronewtons")]
    #[display("micronewtons")]
    Micronewtons,
    #[doc = "Millinewtons <https://en.wikipedia.org/wiki/Newton_(unit)>"]
    #[serde(rename = "millinewtons")]
    #[display("millinewtons")]
    Millinewtons,
    #[doc = "Newtons <https://en.wikipedia.org/wiki/Newton_(unit)>"]
    #[serde(rename = "newtons")]
    #[display("newtons")]
    Newtons,
    #[doc = "Poundals <https://en.wikipedia.org/wiki/Poundal>"]
    #[serde(rename = "poundals")]
    #[display("poundals")]
    Poundals,
    #[doc = "Pounds <https://en.wikipedia.org/wiki/Pound_(force)>"]
    #[serde(rename = "pounds")]
    #[display("pounds")]
    Pounds,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitForceConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitForce,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitForce,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitForceConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitForceConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of frequency units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitFrequency {
    #[doc = "Gigahertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "gigahertz")]
    #[display("gigahertz")]
    Gigahertz,
    #[doc = "Hertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "hertz")]
    #[display("hertz")]
    Hertz,
    #[doc = "Kilohertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "kilohertz")]
    #[display("kilohertz")]
    Kilohertz,
    #[doc = "Megahertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "megahertz")]
    #[display("megahertz")]
    Megahertz,
    #[doc = "Microhertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "microhertz")]
    #[display("microhertz")]
    Microhertz,
    #[doc = "Millihertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "millihertz")]
    #[display("millihertz")]
    Millihertz,
    #[doc = "Nanohertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "nanohertz")]
    #[display("nanohertz")]
    Nanohertz,
    #[doc = "Terahertz <https://en.wikipedia.org/wiki/Hertz>"]
    #[serde(rename = "terahertz")]
    #[display("terahertz")]
    Terahertz,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitFrequencyConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitFrequency,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitFrequency,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitFrequencyConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitFrequencyConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of length units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitLength {
    #[doc = "Centimeters <https://en.wikipedia.org/wiki/Centimeter>"]
    #[serde(rename = "cm")]
    #[display("cm")]
    Cm,
    #[doc = "Feet <https://en.wikipedia.org/wiki/Foot_(unit)>"]
    #[serde(rename = "ft")]
    #[display("ft")]
    Ft,
    #[doc = "Inches <https://en.wikipedia.org/wiki/Inch>"]
    #[serde(rename = "in")]
    #[display("in")]
    In,
    #[doc = "Meters <https://en.wikipedia.org/wiki/Meter>"]
    #[serde(rename = "m")]
    #[display("m")]
    M,
    #[doc = "Millimeters <https://en.wikipedia.org/wiki/Millimeter>"]
    #[serde(rename = "mm")]
    #[display("mm")]
    Mm,
    #[doc = "Yards <https://en.wikipedia.org/wiki/Yard>"]
    #[serde(rename = "yd")]
    #[display("yd")]
    Yd,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitLengthConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitLength,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitLength,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitLengthConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitLengthConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of mass units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitMass {
    #[doc = "Grams <https://en.wikipedia.org/wiki/Gram>"]
    #[serde(rename = "g")]
    #[display("g")]
    G,
    #[doc = "Kilograms <https://en.wikipedia.org/wiki/Kilogram>"]
    #[serde(rename = "kg")]
    #[display("kg")]
    Kg,
    #[doc = "Pounds <https://en.wikipedia.org/wiki/Pound_(mass)>"]
    #[serde(rename = "lb")]
    #[display("lb")]
    Lb,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitMassConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitMass,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitMass,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitMassConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitMassConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of power units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitPower {
    #[doc = "British thermal units (BTU) per minute <https://en.wikipedia.org/wiki/British_thermal_unit>"]
    #[serde(rename = "btu_per_minute")]
    #[display("btu_per_minute")]
    BtuPerMinute,
    #[doc = "Horsepower (hp) <https://en.wikipedia.org/wiki/Horsepower>"]
    #[serde(rename = "horsepower")]
    #[display("horsepower")]
    Horsepower,
    #[doc = "Kilowatts <https://en.wikipedia.org/wiki/Kilowatt>"]
    #[serde(rename = "kilowatts")]
    #[display("kilowatts")]
    Kilowatts,
    #[doc = "Metric horsepower (PS) <https://en.wikipedia.org/wiki/Horsepower#Metric_horsepower>"]
    #[serde(rename = "metric_horsepower")]
    #[display("metric_horsepower")]
    MetricHorsepower,
    #[doc = "Microwatts <https://en.wikipedia.org/wiki/Microwatt>"]
    #[serde(rename = "microwatts")]
    #[display("microwatts")]
    Microwatts,
    #[doc = "Millwatts <https://en.wikipedia.org/wiki/Milliwatt>"]
    #[serde(rename = "milliwatts")]
    #[display("milliwatts")]
    Milliwatts,
    #[doc = "Watts <https://en.wikipedia.org/wiki/Watt>"]
    #[serde(rename = "watts")]
    #[display("watts")]
    Watts,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitPowerConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitPower,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitPower,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitPowerConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitPowerConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of pressure units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitPressure {
    #[doc = "Atmospheres <https://en.wikipedia.org/wiki/Standard_atmosphere_(unit)>"]
    #[serde(rename = "atmospheres")]
    #[display("atmospheres")]
    Atmospheres,
    #[doc = "Bars <https://en.wikipedia.org/wiki/Bar_(unit)>"]
    #[serde(rename = "bars")]
    #[display("bars")]
    Bars,
    #[doc = "Hectopascals <https://en.wikipedia.org/wiki/Hectopascal>"]
    #[serde(rename = "hectopascals")]
    #[display("hectopascals")]
    Hectopascals,
    #[doc = "Kilopascals <https://en.wikipedia.org/wiki/Kilopascal>"]
    #[serde(rename = "kilopascals")]
    #[display("kilopascals")]
    Kilopascals,
    #[doc = "Millibars <https://en.wikipedia.org/wiki/Bar_(unit)>"]
    #[serde(rename = "millibars")]
    #[display("millibars")]
    Millibars,
    #[doc = "Pascals <https://en.wikipedia.org/wiki/Pascal_(unit)>"]
    #[serde(rename = "pascals")]
    #[display("pascals")]
    Pascals,
    #[doc = "Pounds per square inch (PSI) - <https://en.wikipedia.org/wiki/Pound_per_square_inch>"]
    #[serde(rename = "psi")]
    #[display("psi")]
    Psi,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitPressureConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitPressure,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitPressure,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitPressureConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitPressureConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of temperature units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitTemperature {
    #[doc = "Celsius <https://en.wikipedia.org/wiki/Celsius>"]
    #[serde(rename = "celsius")]
    #[display("celsius")]
    Celsius,
    #[doc = "Fahrenheit <https://en.wikipedia.org/wiki/Fahrenheit>"]
    #[serde(rename = "fahrenheit")]
    #[display("fahrenheit")]
    Fahrenheit,
    #[doc = "Kelvin <https://en.wikipedia.org/wiki/Kelvin>"]
    #[serde(rename = "kelvin")]
    #[display("kelvin")]
    Kelvin,
    #[doc = "Rankine <https://en.wikipedia.org/wiki/Rankine_scale>"]
    #[serde(rename = "rankine")]
    #[display("rankine")]
    Rankine,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitTemperatureConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitTemperature,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitTemperature,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitTemperatureConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitTemperatureConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of torque units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitTorque {
    #[doc = "Newton metres <https://en.wikipedia.org/wiki/Newton_metre>"]
    #[serde(rename = "newton_metres")]
    #[display("newton_metres")]
    NewtonMetres,
    #[doc = "Pound foot <https://en.wikipedia.org/wiki/Pound-foot_(torque)>"]
    #[serde(rename = "pound_foot")]
    #[display("pound_foot")]
    PoundFoot,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitTorqueConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitTorque,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitTorque,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitTorqueConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitTorqueConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The valid types of volume units."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UnitVolume {
    #[doc = "Cubic centimeters (cc or cm) <https://en.wikipedia.org/wiki/Cubic_centimeter>"]
    #[serde(rename = "cm3")]
    #[display("cm3")]
    Cm3,
    #[doc = "Cubic feet (ft) <https://en.wikipedia.org/wiki/Cubic_foot>"]
    #[serde(rename = "ft3")]
    #[display("ft3")]
    Ft3,
    #[doc = "Cubic inches (cu in or in) <https://en.wikipedia.org/wiki/Cubic_inch>"]
    #[serde(rename = "in3")]
    #[display("in3")]
    In3,
    #[doc = "Cubic meters (m) <https://en.wikipedia.org/wiki/Cubic_meter>"]
    #[serde(rename = "m3")]
    #[display("m3")]
    M3,
    #[doc = "Cubic yards (yd) <https://en.wikipedia.org/wiki/Cubic_yard>"]
    #[serde(rename = "yd3")]
    #[display("yd3")]
    Yd3,
    #[doc = "US Fluid Ounces (fl oz) <https://en.wikipedia.org/wiki/Fluid_ounce>"]
    #[serde(rename = "usfloz")]
    #[display("usfloz")]
    Usfloz,
    #[doc = "US Gallons (gal US) <https://en.wikipedia.org/wiki/Gallon>"]
    #[serde(rename = "usgal")]
    #[display("usgal")]
    Usgal,
    #[doc = "Liters (l) <https://en.wikipedia.org/wiki/Litre>"]
    #[serde(rename = "l")]
    #[display("l")]
    L,
    #[doc = "Milliliters (ml) <https://en.wikipedia.org/wiki/Litre>"]
    #[serde(rename = "ml")]
    #[display("ml")]
    Ml,
}

#[doc = "Result of converting between units."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UnitVolumeConversion {
    #[doc = "The time and date the API call was completed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time and date the API call was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The error the function returned, if any."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[doc = "The unique identifier of the API call.\n\nThis is the same as the API call ID."]
    pub id: uuid::Uuid,
    #[doc = "The input value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<f64>,
    #[doc = "The source format of the unit conversion."]
    pub input_unit: UnitVolume,
    #[doc = "The resulting value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<f64>,
    #[doc = "The output format of the unit conversion."]
    pub output_unit: UnitVolume,
    #[doc = "The time and date the API call was started."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The status of the API call."]
    pub status: ApiCallStatus,
    #[doc = "The time and date the API call was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The user ID of the user who created the API call."]
    pub user_id: uuid::Uuid,
}

impl std::fmt::Display for UnitVolumeConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UnitVolumeConversion {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(completed_at) = &self.completed_at {
                format!("{:?}", completed_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(error) = &self.error {
                format!("{:?}", error).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(input) = &self.input {
                format!("{:?}", input).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.input_unit).into(),
            if let Some(output) = &self.output {
                format!("{:?}", output).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.output_unit).into(),
            if let Some(started_at) = &self.started_at {
                format!("{:?}", started_at).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.status).into(),
            format!("{:?}", self.updated_at).into(),
            format!("{:?}", self.user_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "completed_at".into(),
            "created_at".into(),
            "error".into(),
            "id".into(),
            "input".into(),
            "input_unit".into(),
            "output".into(),
            "output_unit".into(),
            "started_at".into(),
            "status".into(),
            "updated_at".into(),
            "user_id".into(),
        ]
    }
}

#[doc = "The response from the `UpdateAnnotation` endpoint."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateAnnotation {}

impl std::fmt::Display for UpdateAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UpdateAnnotation {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![]
    }
}

#[doc = "Data for updating a member of an org."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateMemberToOrgBody {
    #[doc = "The organization role to give the user."]
    pub role: UserOrgRole,
}

impl std::fmt::Display for UpdateMemberToOrgBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UpdateMemberToOrgBody {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.role).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["role".into()]
    }
}

#[doc = "The data for updating a balance."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdatePaymentBalance {
    #[doc = "The monetary value of the monthy API credits remaining in the balance. This gets re-upped every month,"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monthly_api_credits_remaining_monetary_value: Option<f64>,
    #[doc = "The monetary value of stable API credits remaining in the balance. These do not get reset or re-upped every month. This is separate from the monthly credits. Credits will first pull from the monthly credits, then the stable credits. Stable just means that they do not get reset every month. A user will have stable credits if a Zoo employee granted them credits."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stable_api_credits_remaining_monetary_value: Option<f64>,
}

impl std::fmt::Display for UpdatePaymentBalance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UpdatePaymentBalance {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(monthly_api_credits_remaining_monetary_value) =
                &self.monthly_api_credits_remaining_monetary_value
            {
                format!("{:?}", monthly_api_credits_remaining_monetary_value).into()
            } else {
                String::new().into()
            },
            if let Some(stable_api_credits_remaining_monetary_value) =
                &self.stable_api_credits_remaining_monetary_value
            {
                format!("{:?}", stable_api_credits_remaining_monetary_value).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "monthly_api_credits_remaining_monetary_value".into(),
            "stable_api_credits_remaining_monetary_value".into(),
        ]
    }
}

#[doc = "Request to update a shortlink."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateShortlinkRequest {
    #[doc = "The password for the shortlink, if you want to restrict access to it. This can only be set if your subscription allows for it. Otherwise, it will return an error. When you access the link it will be required to enter this password through basic auth. The username will be `{anything}` and the password will be the password you set here."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    #[doc = "If the shortlink should be restricted to the user's organization to view. This only applies to org shortlinks. If you are creating a user shortlink and you are not a member of a team or enterprise and you try to set this to true, it will fail."]
    pub restrict_to_org: bool,
}

impl std::fmt::Display for UpdateShortlinkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UpdateShortlinkRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(password) = &self.password {
                format!("{:?}", password).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.restrict_to_org).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["password".into(), "restrict_to_org".into()]
    }
}

#[doc = "The user-modifiable parts of a User."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateUser {
    #[doc = "The user's company."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[doc = "The user's Discord handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord: Option<String>,
    #[doc = "The user's first name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[doc = "The user's GitHub handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub github: Option<String>,
    #[doc = "The image URL for the user. NOTE: If the user uses an OAuth2 provider, this will be overwritten by the provider's image URL when the user logs in next."]
    pub image: String,
    #[doc = "If the user is now onboarded."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_onboarded: Option<bool>,
    #[doc = "The user's last name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    #[doc = "The user's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
}

impl std::fmt::Display for UpdateUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UpdateUser {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(company) = &self.company {
                format!("{:?}", company).into()
            } else {
                String::new().into()
            },
            if let Some(discord) = &self.discord {
                format!("{:?}", discord).into()
            } else {
                String::new().into()
            },
            if let Some(first_name) = &self.first_name {
                format!("{:?}", first_name).into()
            } else {
                String::new().into()
            },
            if let Some(github) = &self.github {
                format!("{:?}", github).into()
            } else {
                String::new().into()
            },
            self.image.clone().into(),
            if let Some(is_onboarded) = &self.is_onboarded {
                format!("{:?}", is_onboarded).into()
            } else {
                String::new().into()
            },
            if let Some(last_name) = &self.last_name {
                format!("{:?}", last_name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "company".into(),
            "discord".into(),
            "first_name".into(),
            "github".into(),
            "image".into(),
            "is_onboarded".into(),
            "last_name".into(),
            "phone".into(),
        ]
    }
}

#[doc = "A user."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct User {
    #[doc = "If the user should be blocked and the reason why."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block: Option<BlockReason>,
    #[doc = "If we can train on the user's data. If the user is a member of an organization, the organization's setting will override this."]
    #[serde(default)]
    pub can_train_on_data: bool,
    #[doc = "The user's company."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company: Option<String>,
    #[doc = "The date and time the user was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "If the user is scheduled for deletion."]
    #[serde(default)]
    pub deletion_scheduled: bool,
    #[doc = "The user's Discord handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord: Option<String>,
    #[doc = "The email address of the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = "The date and time the email address was verified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email_verified: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The user's first name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[doc = "The user's GitHub handle."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub github: Option<String>,
    #[doc = "The unique identifier for the user."]
    pub id: uuid::Uuid,
    #[doc = "The image avatar for the user. This is a URL."]
    pub image: String,
    #[doc = "If the user has finished onboarding."]
    #[serde(default)]
    pub is_onboarded: bool,
    #[doc = "If the user is tied to a service account."]
    #[serde(default)]
    pub is_service_account: bool,
    #[doc = "The user's last name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    #[doc = "The name of the user. This is auto populated at first from the authentication provider (if there was a name). It can be updated by the user by updating their `first_name` and `last_name` fields."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The user's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
    #[doc = "The date and time the user was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for User {
    const LENGTH: usize = 18;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(block) = &self.block {
                format!("{:?}", block).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.can_train_on_data).into(),
            if let Some(company) = &self.company {
                format!("{:?}", company).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.deletion_scheduled).into(),
            if let Some(discord) = &self.discord {
                format!("{:?}", discord).into()
            } else {
                String::new().into()
            },
            if let Some(email) = &self.email {
                format!("{:?}", email).into()
            } else {
                String::new().into()
            },
            if let Some(email_verified) = &self.email_verified {
                format!("{:?}", email_verified).into()
            } else {
                String::new().into()
            },
            if let Some(first_name) = &self.first_name {
                format!("{:?}", first_name).into()
            } else {
                String::new().into()
            },
            if let Some(github) = &self.github {
                format!("{:?}", github).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            self.image.clone().into(),
            format!("{:?}", self.is_onboarded).into(),
            format!("{:?}", self.is_service_account).into(),
            if let Some(last_name) = &self.last_name {
                format!("{:?}", last_name).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "block".into(),
            "can_train_on_data".into(),
            "company".into(),
            "created_at".into(),
            "deletion_scheduled".into(),
            "discord".into(),
            "email".into(),
            "email_verified".into(),
            "first_name".into(),
            "github".into(),
            "id".into(),
            "image".into(),
            "is_onboarded".into(),
            "is_service_account".into(),
            "last_name".into(),
            "name".into(),
            "phone".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "A user's information about an org, including their role."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UserOrgInfo {
    #[doc = "If we should allow all future users who are created with email addresses from this domain to join the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_users_in_domain_to_auto_join: Option<bool>,
    #[doc = "The billing email address of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub billing_email: Option<String>,
    #[doc = "The date and time the billing email address was verified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub billing_email_verified: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "If the org should be blocked and the reason why."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block: Option<BlockReason>,
    #[doc = "The date and time the org was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The org's domain."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    #[doc = "The unique identifier for the org."]
    pub id: uuid::Uuid,
    #[doc = "The image for the org. This is a URL."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[doc = "The name of the org."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The org's phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone: phone_number::PhoneNumber,
    #[doc = "The user's role in the org."]
    pub role: OrgRole,
    #[doc = "The org's stripe id."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stripe_id: Option<String>,
    #[doc = "The date and time the org was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for UserOrgInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UserOrgInfo {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(allow_users_in_domain_to_auto_join) =
                &self.allow_users_in_domain_to_auto_join
            {
                format!("{:?}", allow_users_in_domain_to_auto_join).into()
            } else {
                String::new().into()
            },
            if let Some(billing_email) = &self.billing_email {
                format!("{:?}", billing_email).into()
            } else {
                String::new().into()
            },
            if let Some(billing_email_verified) = &self.billing_email_verified {
                format!("{:?}", billing_email_verified).into()
            } else {
                String::new().into()
            },
            if let Some(block) = &self.block {
                format!("{:?}", block).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.created_at).into(),
            if let Some(domain) = &self.domain {
                format!("{:?}", domain).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            if let Some(image) = &self.image {
                format!("{:?}", image).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.phone).into(),
            format!("{:?}", self.role).into(),
            if let Some(stripe_id) = &self.stripe_id {
                format!("{:?}", stripe_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "allow_users_in_domain_to_auto_join".into(),
            "billing_email".into(),
            "billing_email_verified".into(),
            "block".into(),
            "created_at".into(),
            "domain".into(),
            "id".into(),
            "image".into(),
            "name".into(),
            "phone".into(),
            "role".into(),
            "stripe_id".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "The roles for users in an organization."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UserOrgRole {
    #[doc = "Admins can do anything in the org."]
    #[serde(rename = "admin")]
    #[display("admin")]
    Admin,
    #[doc = "Members of an org can not modify an org, but they belong in the org."]
    #[serde(rename = "member")]
    #[display("member")]
    Member,
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UserResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<User>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for UserResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for UserResultsPage {
    type Item = User;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UserResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "A verification token response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VerificationTokenResponse {
    #[doc = "The date and time the verification token was created."]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[doc = "The date and time the verification token expires."]
    pub expires: chrono::DateTime<chrono::Utc>,
    #[doc = "The token used for verification. This is used as the id for the table since it is unique per record."]
    pub id: uuid::Uuid,
    #[doc = "The identifier for the user. This is typically the user's email address since that is what we are verifying."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
    #[doc = "The URL to redirect to if the user requires SAML authentication."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub saml_redirect_url: Option<String>,
    #[doc = "The date and time the verification token was last updated."]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for VerificationTokenResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VerificationTokenResponse {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created_at).into(),
            format!("{:?}", self.expires).into(),
            format!("{:?}", self.id).into(),
            if let Some(identifier) = &self.identifier {
                format!("{:?}", identifier).into()
            } else {
                String::new().into()
            },
            if let Some(saml_redirect_url) = &self.saml_redirect_url {
                format!("{:?}", saml_redirect_url).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.updated_at).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created_at".into(),
            "expires".into(),
            "id".into(),
            "identifier".into(),
            "saml_redirect_url".into(),
            "updated_at".into(),
        ]
    }
}

#[doc = "The response from the `ViewIsometric` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ViewIsometric {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for ViewIsometric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ViewIsometric {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}

#[doc = "The volume response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Volume {
    #[doc = "The output unit for the volume."]
    pub output_unit: UnitVolume,
    #[doc = "The volume."]
    pub volume: f64,
}

impl std::fmt::Display for Volume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Volume {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.output_unit).into(),
            format!("{:?}", self.volume).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["output_unit".into(), "volume".into()]
    }
}

#[doc = "The websocket messages the server receives."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum WebSocketRequest {
    #[doc = "The trickle ICE candidate request."]
    #[serde(rename = "trickle_ice")]
    TrickleIce {
        #[doc = "Information about the ICE candidate."]
        candidate: RtcIceCandidateInit,
    },
    #[doc = "The SDP offer request."]
    #[serde(rename = "sdp_offer")]
    SdpOffer {
        #[doc = "The session description."]
        offer: RtcSessionDescription,
    },
    #[doc = "The modeling command request."]
    #[serde(rename = "modeling_cmd_req")]
    ModelingCmdReq {
        #[doc = "Which command to submit to the Kittycad engine."]
        cmd: ModelingCmd,
        #[doc = "ID of command being submitted."]
        cmd_id: uuid::Uuid,
    },
    #[doc = "A sequence of modeling requests. If any request fails, following requests will not be tried."]
    #[serde(rename = "modeling_cmd_batch_req")]
    ModelingCmdBatchReq {
        #[doc = "ID of batch being submitted. Each request has their own individual ModelingCmdId, but this is the ID of the overall batch."]
        batch_id: uuid::Uuid,
        #[doc = "A sequence of modeling requests. If any request fails, following requests will not be tried."]
        requests: Vec<ModelingCmdReq>,
        #[doc = "If false or omitted, responses to each batch command will just be Ok(()). If true, responses will be the actual response data for that modeling command."]
        #[serde(default)]
        responses: bool,
    },
    #[doc = "The client-to-server Ping to ensure the WebSocket stays alive."]
    #[serde(rename = "ping")]
    Ping {},
    #[doc = "The response to a metrics collection request from the server."]
    #[serde(rename = "metrics_response")]
    MetricsResponse {
        #[doc = "Collected metrics from the Client's end of the engine connection."]
        metrics: ClientMetrics,
    },
    #[doc = "Return information about the connected instance"]
    #[serde(rename = "debug")]
    Debug {},
    #[doc = "Authentication header request."]
    #[serde(rename = "headers")]
    Headers {
        #[doc = "The authentication header."]
        headers: std::collections::HashMap<String, String>,
    },
}

#[doc = "Websocket responses can either be successful or unsuccessful. Slightly different schemas in either case."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct WebSocketResponse {
    #[doc = "Which request this is a response to. If the request was a modeling command, this is the modeling command ID. If no request ID was sent, this will be null."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<uuid::Uuid>,
    #[doc = "The data sent with a successful response. This will be flattened into a 'type' and 'data' field."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resp: Option<OkWebSocketResponseData>,
    #[doc = "Always false"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub success: Option<bool>,
    #[doc = "The errors that occurred."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<ApiError>>,
}

impl std::fmt::Display for WebSocketResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for WebSocketResponse {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(request_id) = &self.request_id {
                format!("{:?}", request_id).into()
            } else {
                String::new().into()
            },
            if let Some(resp) = &self.resp {
                format!("{:?}", resp).into()
            } else {
                String::new().into()
            },
            if let Some(success) = &self.success {
                format!("{:?}", success).into()
            } else {
                String::new().into()
            },
            if let Some(errors) = &self.errors {
                format!("{:?}", errors).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "request_id".into(),
            "resp".into(),
            "success".into(),
            "errors".into(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum WorldCoordinateSystem {
    #[serde(rename = "right_handed_up_z")]
    #[display("right_handed_up_z")]
    RightHandedUpZ,
    #[serde(rename = "right_handed_up_y")]
    #[display("right_handed_up_y")]
    RightHandedUpY,
}

#[doc = "A subscription to the modeling app."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ZooProductSubscription {
    #[doc = "Annual discount. The percentage off the monthly price if the user pays annually."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annual_discount: Option<f64>,
    #[doc = "A description of the tier."]
    pub description: String,
    #[doc = "The Zoo API endpoints that are included when through an approved zoo tool."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints_included: Option<Vec<ApiEndpoint>>,
    #[doc = "Features that are included in the subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub features: Option<Vec<SubscriptionTierFeature>>,
    #[doc = "The amount of pay-as-you-go API credits the individual or org gets outside the modeling app per month. This re-ups on the 1st of each month. This is equivalent to the monetary value divided by the price of an API credit."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monthly_pay_as_you_go_api_credits: Option<u64>,
    #[doc = "The monetary value of pay-as-you-go API credits the individual or org gets outside the modeling app per month. This re-ups on the 1st of each month."]
    pub monthly_pay_as_you_go_api_credits_monetary_value: f64,
    #[doc = "The name of the tier."]
    pub name: ModelingAppSubscriptionTierName,
    #[doc = "The price of an API credit (meaning 1 credit = 1 minute of API usage)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pay_as_you_go_api_credit_price: Option<f64>,
    #[doc = "The price of the tier per month. If this is for an individual, this is the price they pay. If this is for an organization, this is the price the organization pays per member in the org. This is in USD."]
    pub price: SubscriptionTierPrice,
    #[doc = "The options for sharable links through the modeling app."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub share_links: Option<Vec<ModelingAppShareLinks>>,
    #[doc = "The support tier the subscription provides."]
    pub support_tier: SupportTier,
    #[doc = "The behavior of the users data (can it be used for training, etc)."]
    pub training_data_behavior: SubscriptionTrainingDataBehavior,
    #[doc = "If the tier is offered for an individual or an org."]
    #[serde(rename = "type")]
    pub type_: SubscriptionTierType,
    #[doc = "The Zoo tools that you can call unlimited times with this tier."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zoo_tools_included: Option<Vec<ZooTool>>,
}

impl std::fmt::Display for ZooProductSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ZooProductSubscription {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(annual_discount) = &self.annual_discount {
                format!("{:?}", annual_discount).into()
            } else {
                String::new().into()
            },
            self.description.clone().into(),
            if let Some(endpoints_included) = &self.endpoints_included {
                format!("{:?}", endpoints_included).into()
            } else {
                String::new().into()
            },
            if let Some(features) = &self.features {
                format!("{:?}", features).into()
            } else {
                String::new().into()
            },
            if let Some(monthly_pay_as_you_go_api_credits) = &self.monthly_pay_as_you_go_api_credits
            {
                format!("{:?}", monthly_pay_as_you_go_api_credits).into()
            } else {
                String::new().into()
            },
            format!(
                "{:?}",
                self.monthly_pay_as_you_go_api_credits_monetary_value
            )
            .into(),
            format!("{:?}", self.name).into(),
            if let Some(pay_as_you_go_api_credit_price) = &self.pay_as_you_go_api_credit_price {
                format!("{:?}", pay_as_you_go_api_credit_price).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.price).into(),
            if let Some(share_links) = &self.share_links {
                format!("{:?}", share_links).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.support_tier).into(),
            format!("{:?}", self.training_data_behavior).into(),
            format!("{:?}", self.type_).into(),
            if let Some(zoo_tools_included) = &self.zoo_tools_included {
                format!("{:?}", zoo_tools_included).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "annual_discount".into(),
            "description".into(),
            "endpoints_included".into(),
            "features".into(),
            "monthly_pay_as_you_go_api_credits".into(),
            "monthly_pay_as_you_go_api_credits_monetary_value".into(),
            "name".into(),
            "pay_as_you_go_api_credit_price".into(),
            "price".into(),
            "share_links".into(),
            "support_tier".into(),
            "training_data_behavior".into(),
            "type_".into(),
            "zoo_tools_included".into(),
        ]
    }
}

#[doc = "A struct of Zoo product subscriptions."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ZooProductSubscriptions {
    #[doc = "A modeling app subscription."]
    pub modeling_app: ModelingAppSubscriptionTier,
}

impl std::fmt::Display for ZooProductSubscriptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ZooProductSubscriptions {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.modeling_app).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["modeling_app".into()]
    }
}

#[doc = "A struct of Zoo product subscriptions an organization can request."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ZooProductSubscriptionsOrgRequest {
    #[doc = "A modeling app subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modeling_app: Option<ModelingAppOrganizationSubscriptionTier>,
    #[doc = "If the customer chooses to pay annually or monthly, we can add that here. The annual discount will apply if there is a discount for the subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pay_annually: Option<bool>,
}

impl std::fmt::Display for ZooProductSubscriptionsOrgRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ZooProductSubscriptionsOrgRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(modeling_app) = &self.modeling_app {
                format!("{:?}", modeling_app).into()
            } else {
                String::new().into()
            },
            if let Some(pay_annually) = &self.pay_annually {
                format!("{:?}", pay_annually).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["modeling_app".into(), "pay_annually".into()]
    }
}

#[doc = "A struct of Zoo product subscriptions a user can request."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ZooProductSubscriptionsUserRequest {
    #[doc = "A modeling app subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modeling_app: Option<ModelingAppIndividualSubscriptionTier>,
    #[doc = "If the customer chooses to pay annually or monthly, we can add that here. The annual discount will apply if there is a discount for the subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pay_annually: Option<bool>,
}

impl std::fmt::Display for ZooProductSubscriptionsUserRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ZooProductSubscriptionsUserRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(modeling_app) = &self.modeling_app {
                format!("{:?}", modeling_app).into()
            } else {
                String::new().into()
            },
            if let Some(pay_annually) = &self.pay_annually {
                format!("{:?}", pay_annually).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["modeling_app".into(), "pay_annually".into()]
    }
}

#[doc = "The Zoo tools that can make API calls."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ZooTool {
    #[doc = "The modeling app."]
    #[serde(rename = "modeling_app")]
    #[display("modeling_app")]
    ModelingApp,
    #[doc = "The Diff Chrome Extension."]
    #[serde(rename = "diff_chrome_extension")]
    #[display("diff_chrome_extension")]
    DiffChromeExtension,
    #[doc = "The Text-to-CAD UI."]
    #[serde(rename = "text_to_cad")]
    #[display("text_to_cad")]
    TextToCad,
}

#[doc = "The response from the `ZoomToFit` command."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ZoomToFit {
    #[doc = "Camera settings"]
    pub settings: CameraSettings,
}

impl std::fmt::Display for ZoomToFit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ZoomToFit {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.settings).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["settings".into()]
    }
}
