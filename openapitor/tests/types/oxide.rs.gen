#![doc = r" This module contains the generated types for the library."]
#[cfg(feature = "tabled")]
use tabled::Tabled;
pub mod base64 {
    #![doc = " Base64 data that encodes to url safe base64, but can decode from multiple"]
    #![doc = " base64 implementations to account for various clients and libraries. Compatible"]
    #![doc = " with serde and JsonSchema."]
    use serde::{
        de::{Error, Unexpected, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    };
    use std::{convert::TryFrom, fmt};
    static ALLOWED_DECODING_FORMATS: &[data_encoding::Encoding] = &[
        data_encoding::BASE64,
        data_encoding::BASE64URL,
        data_encoding::BASE64URL_NOPAD,
        data_encoding::BASE64_MIME,
        data_encoding::BASE64_NOPAD,
    ];
    #[derive(Debug, Clone, PartialEq, Eq)]
    #[doc = " A container for binary that should be base64 encoded in serialisation. In reverse"]
    #[doc = " when deserializing, will decode from many different types of base64 possible."]
    pub struct Base64Data(pub Vec<u8>);
    impl Base64Data {
        #[doc = " Return is the data is empty."]
        pub fn is_empty(&self) -> bool {
            self.0.is_empty()
        }
    }

    impl fmt::Display for Base64Data {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", data_encoding::BASE64URL_NOPAD.encode(&self.0))
        }
    }

    impl From<Base64Data> for Vec<u8> {
        fn from(data: Base64Data) -> Vec<u8> {
            data.0
        }
    }

    impl From<Vec<u8>> for Base64Data {
        fn from(data: Vec<u8>) -> Base64Data {
            Base64Data(data)
        }
    }

    impl AsRef<[u8]> for Base64Data {
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    }

    impl TryFrom<&str> for Base64Data {
        type Error = anyhow::Error;
        fn try_from(v: &str) -> Result<Self, Self::Error> {
            for config in ALLOWED_DECODING_FORMATS {
                if let Ok(data) = config.decode(v.as_bytes()) {
                    return Ok(Base64Data(data));
                }
            }
            anyhow::bail!("Could not decode base64 data: {}", v);
        }
    }

    struct Base64DataVisitor;
    impl<'de> Visitor<'de> for Base64DataVisitor {
        type Value = Base64Data;
        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            write!(formatter, "a base64 encoded string")
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: Error,
        {
            for config in ALLOWED_DECODING_FORMATS {
                if let Ok(data) = config.decode(v.as_bytes()) {
                    return Ok(Base64Data(data));
                }
            }
            Err(serde::de::Error::invalid_value(Unexpected::Str(v), &self))
        }
    }

    impl<'de> Deserialize<'de> for Base64Data {
        fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
        where
            D: Deserializer<'de>,
        {
            deserializer.deserialize_str(Base64DataVisitor)
        }
    }

    impl Serialize for Base64Data {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            let encoded = data_encoding::BASE64URL_NOPAD.encode(&self.0);
            serializer.serialize_str(&encoded)
        }
    }

    impl schemars::JsonSchema for Base64Data {
        fn schema_name() -> String {
            "Base64Data".to_string()
        }

        fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
            let mut obj = gen.root_schema_for::<String>().schema;
            obj.format = Some("byte".to_string());
            schemars::schema::Schema::Object(obj)
        }

        fn is_referenceable() -> bool {
            false
        }
    }

    #[cfg(test)]
    mod tests {
        use super::Base64Data;
        use std::convert::TryFrom;
        #[test]
        fn test_base64_try_from() {
            assert!(Base64Data::try_from("aGVsbG8=").is_ok());
            assert!(Base64Data::try_from("abcdefghij").is_err());
        }
    }
}

#[cfg(feature = "requests")]
pub mod multipart {
    #![doc = " Multipart form data types."]
    #[doc = " An attachement to a multipart form."]
    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    pub struct Attachment {
        #[doc = " The name of the field."]
        pub name: String,
        #[doc = " The filename of the attachment."]
        pub filename: Option<String>,
        #[doc = " The content type of the attachment."]
        pub content_type: Option<String>,
        #[doc = " The data of the attachment."]
        pub data: Vec<u8>,
    }

    impl std::convert::TryFrom<Attachment> for reqwest::multipart::Part {
        type Error = reqwest::Error;
        fn try_from(attachment: Attachment) -> Result<Self, Self::Error> {
            let mut part = reqwest::multipart::Part::bytes(attachment.data);
            if let Some(filename) = attachment.filename {
                part = part.file_name(filename);
            }
            if let Some(content_type) = attachment.content_type {
                part = part.mime_str(&content_type)?;
            }
            Ok(part)
        }
    }

    impl std::convert::TryFrom<std::path::PathBuf> for Attachment {
        type Error = std::io::Error;
        fn try_from(path: std::path::PathBuf) -> Result<Self, Self::Error> {
            let filename = path
                .file_name()
                .ok_or_else(|| {
                    std::io::Error::new(std::io::ErrorKind::InvalidData, "invalid filename")
                })?
                .to_str()
                .ok_or_else(|| {
                    std::io::Error::new(std::io::ErrorKind::InvalidData, "invalid filename")
                })?
                .to_string();
            let content_type = mime_guess::from_path(&path).first_raw();
            let data = std::fs::read(path)?;
            Ok(Attachment {
                name: "file".to_string(),
                filename: Some(filename),
                content_type: content_type.map(|s| s.to_string()),
                data,
            })
        }
    }
}

#[cfg(feature = "requests")]
pub mod paginate {
    #![doc = " Utility functions used for pagination."]
    use anyhow::Result;
    #[doc = " A trait for types that allow pagination."]
    pub trait Pagination {
        #[doc = " The item that is paginated."]
        type Item: serde::de::DeserializeOwned;
        #[doc = " Returns true if the response has more pages."]
        fn has_more_pages(&self) -> bool;
        #[doc = " Returns the next page token."]
        fn next_page_token(&self) -> Option<String>;
        #[doc = " Modify a request to get the next page."]
        fn next_page(
            &self,
            req: reqwest::Request,
        ) -> Result<reqwest::Request, crate::types::error::Error>;
        #[doc = " Get the items from a page."]
        fn items(&self) -> Vec<Self::Item>;
    }
}

pub mod phone_number {
    #![doc = " A library to implement phone numbers for our database and JSON serialization and deserialization."]
    use schemars::JsonSchema;
    use std::str::FromStr;
    #[doc = " A phone number."]
    #[derive(Debug, Default, Clone, PartialEq, Hash, Eq)]
    pub struct PhoneNumber(pub Option<phonenumber::PhoneNumber>);
    impl From<phonenumber::PhoneNumber> for PhoneNumber {
        fn from(id: phonenumber::PhoneNumber) -> PhoneNumber {
            PhoneNumber(Some(id))
        }
    }

    impl AsRef<Option<phonenumber::PhoneNumber>> for PhoneNumber {
        fn as_ref(&self) -> &Option<phonenumber::PhoneNumber> {
            &self.0
        }
    }

    impl std::ops::Deref for PhoneNumber {
        type Target = Option<phonenumber::PhoneNumber>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl serde::ser::Serialize for PhoneNumber {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            serializer.serialize_str(&self.to_string())
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PhoneNumber {
        fn deserialize<D>(deserializer: D) -> Result<PhoneNumber, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let s = String::deserialize(deserializer).unwrap_or_default();
            PhoneNumber::from_str(&s).map_err(serde::de::Error::custom)
        }
    }

    impl std::str::FromStr for PhoneNumber {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            if s.trim().is_empty() {
                return Ok(PhoneNumber(None));
            }
            let s = if !s.trim().starts_with('+') {
                format!("+1{s}")
            } else {
                s.to_string()
            }
            .replace(['-', '(', ')', ' '], "");
            Ok(PhoneNumber(Some(phonenumber::parse(None, &s).map_err(
                |e| anyhow::anyhow!("invalid phone number `{}`: {}", s, e),
            )?)))
        }
    }

    impl std::fmt::Display for PhoneNumber {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let s = if let Some(phone) = &self.0 {
                phone
                    .format()
                    .mode(phonenumber::Mode::International)
                    .to_string()
            } else {
                String::new()
            };
            write!(f, "{}", s)
        }
    }

    impl JsonSchema for PhoneNumber {
        fn schema_name() -> String {
            "PhoneNumber".to_string()
        }

        fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
            let mut obj = gen.root_schema_for::<String>().schema;
            obj.format = Some("phone".to_string());
            schemars::schema::Schema::Object(obj)
        }

        fn is_referenceable() -> bool {
            false
        }
    }

    #[cfg(test)]
    mod test {
        use super::PhoneNumber;
        use pretty_assertions::assert_eq;
        #[test]
        fn test_parse_phone_number() {
            let mut phone = "+1-555-555-5555";
            let mut phone_parsed: PhoneNumber =
                serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            let mut expected = PhoneNumber(Some(phonenumber::parse(None, phone).unwrap()));
            assert_eq!(phone_parsed, expected);
            let mut expected_str = "+1 555-555-5555";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "555-555-5555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "+1 555-555-5555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "5555555555";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "(510) 864-1234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            expected = PhoneNumber(Some(phonenumber::parse(None, "+15108641234").unwrap()));
            assert_eq!(phone_parsed, expected);
            expected_str = "+1 510-864-1234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "(510)8641234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, expected);
            expected_str = "+1 510-864-1234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            assert_eq!(phone_parsed, PhoneNumber(None));
            assert_eq!("", serde_json::json!(phone_parsed));
            phone = "+49 30  1234 1234";
            phone_parsed = serde_json::from_str(&format!(r#""{}""#, phone)).unwrap();
            expected = PhoneNumber(Some(phonenumber::parse(None, phone).unwrap()));
            assert_eq!(phone_parsed, expected);
            expected_str = "+49 30 12341234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
        }
    }
}

#[cfg(feature = "requests")]
pub mod error {
    #![doc = " Error methods."]
    #[doc = " Error produced by generated client methods."]
    pub enum Error {
        #[doc = " The request did not conform to API requirements."]
        InvalidRequest(String),
        #[cfg(feature = "retry")]
        #[doc = " A server error either due to the data, or with the connection."]
        CommunicationError(reqwest_middleware::Error),
        #[doc = " A request error, caused when building the request."]
        RequestError(reqwest::Error),
        #[doc = " An expected response whose deserialization failed."]
        SerdeError {
            #[doc = " The error."]
            error: format_serde_error::SerdeError,
            #[doc = " The response status."]
            status: reqwest::StatusCode,
        },
        #[doc = " An expected error response."]
        InvalidResponsePayload {
            #[cfg(feature = "retry")]
            #[doc = " The error."]
            error: reqwest_middleware::Error,
            #[cfg(not(feature = "retry"))]
            #[doc = " The error."]
            error: reqwest::Error,
            #[doc = " The full response."]
            response: reqwest::Response,
        },
        #[doc = " An error from the server."]
        Server {
            #[doc = " The text from the body."]
            body: String,
            #[doc = " The response status."]
            status: reqwest::StatusCode,
        },
        #[doc = " A response not listed in the API description. This may represent a"]
        #[doc = " success or failure response; check `status().is_success()`."]
        UnexpectedResponse(reqwest::Response),
    }

    impl Error {
        #[doc = " Returns the status code, if the error was generated from a response."]
        pub fn status(&self) -> Option<reqwest::StatusCode> {
            match self {
                Error::InvalidRequest(_) => None,
                Error::RequestError(e) => e.status(),
                #[cfg(feature = "retry")]
                Error::CommunicationError(reqwest_middleware::Error::Reqwest(e)) => e.status(),
                #[cfg(feature = "retry")]
                Error::CommunicationError(reqwest_middleware::Error::Middleware(_)) => None,
                Error::SerdeError { error: _, status } => Some(*status),
                Error::InvalidResponsePayload { error: _, response } => Some(response.status()),
                Error::Server { body: _, status } => Some(*status),
                Error::UnexpectedResponse(r) => Some(r.status()),
            }
        }

        #[doc = " Creates a new error from a response status and a serde error."]
        pub fn from_serde_error(
            e: format_serde_error::SerdeError,
            status: reqwest::StatusCode,
        ) -> Self {
            Self::SerdeError { error: e, status }
        }
    }

    #[cfg(feature = "retry")]
    impl From<reqwest_middleware::Error> for Error {
        fn from(e: reqwest_middleware::Error) -> Self {
            Self::CommunicationError(e)
        }
    }

    impl From<reqwest::Error> for Error {
        fn from(e: reqwest::Error) -> Self {
            Self::RequestError(e)
        }
    }

    impl From<serde_json::Error> for Error {
        fn from(e: serde_json::Error) -> Self {
            Self::SerdeError {
                error: format_serde_error::SerdeError::new(String::new(), e),
                status: reqwest::StatusCode::INTERNAL_SERVER_ERROR,
            }
        }
    }

    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Error::InvalidRequest(s) => {
                    write!(f, "Invalid Request: {}", s)
                }
                #[cfg(feature = "retry")]
                Error::CommunicationError(e) => {
                    write!(f, "Communication Error: {}", e)
                }
                Error::RequestError(e) => {
                    write!(f, "Request Error: {}", e)
                }
                Error::SerdeError { error, status: _ } => {
                    write!(f, "Serde Error: {}", error)
                }
                Error::InvalidResponsePayload { error, response: _ } => {
                    write!(f, "Invalid Response Payload: {}", error)
                }
                Error::Server { body, status } => {
                    write!(f, "Server Error: {} {}", status, body)
                }
                Error::UnexpectedResponse(r) => {
                    write!(f, "Unexpected Response: {:?}", r)
                }
            }
        }
    }

    impl std::fmt::Debug for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            std::fmt::Display::fmt(self, f)
        }
    }

    impl std::error::Error for Error {
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            match self {
                #[cfg(feature = "retry")]
                Error::CommunicationError(e) => Some(e),
                Error::SerdeError { error, status: _ } => Some(error),
                Error::InvalidResponsePayload { error, response: _ } => Some(error),
                _ => None,
            }
        }
    }
}

#[doc = "The type of an individual datum of a metric."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum DatumType {
    #[serde(rename = "bool")]
    #[display("bool")]
    Bool,
    #[serde(rename = "i64")]
    #[display("i64")]
    I64,
    #[serde(rename = "f64")]
    #[display("f64")]
    F64,
    #[serde(rename = "string")]
    #[display("string")]
    String,
    #[serde(rename = "bytes")]
    #[display("bytes")]
    Bytes,
    #[serde(rename = "cumulative_i64")]
    #[display("cumulative_i64")]
    CumulativeI64,
    #[serde(rename = "cumulative_f64")]
    #[display("cumulative_f64")]
    CumulativeF64,
    #[serde(rename = "histogram_i64")]
    #[display("histogram_i64")]
    HistogramI64,
    #[serde(rename = "histogram_f64")]
    #[display("histogram_f64")]
    HistogramF64,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DerEncodedKeyPair {
    #[doc = "request signing private key (base64 encoded der file)"]
    pub private_key: String,
    #[doc = "request signing public certificate (base64 encoded der file)"]
    pub public_cert: String,
}

impl std::fmt::Display for DerEncodedKeyPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DerEncodedKeyPair {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.private_key.clone().into(),
            self.public_cert.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["private_key".into(), "public_cert".into()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeviceAccessTokenRequest {
    pub client_id: uuid::Uuid,
    pub device_code: String,
    pub grant_type: String,
}

impl std::fmt::Display for DeviceAccessTokenRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DeviceAccessTokenRequest {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.client_id).into(),
            self.device_code.clone().into(),
            self.grant_type.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "client_id".into(),
            "device_code".into(),
            "grant_type".into(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeviceAuthRequest {
    pub client_id: uuid::Uuid,
}

impl std::fmt::Display for DeviceAuthRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DeviceAuthRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.client_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["client_id".into()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DeviceAuthVerify {
    pub user_code: String,
}

impl std::fmt::Display for DeviceAuthVerify {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DeviceAuthVerify {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.user_code.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["user_code".into()]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum Type {
    #[serde(rename = "sha256")]
    #[display("sha256")]
    Sha256,
}

impl std::default::Default for Type {
    fn default() -> Self {
        Type::Sha256
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Digest {
    #[serde(rename = "type")]
    pub type_: Type,
    pub value: String,
}

impl std::fmt::Display for Digest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Digest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.type_).into(),
            self.value.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["type_".into(), "value".into()]
    }
}

#[doc = "Client view of a [`Disk`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Disk {
    #[doc = "A count of bytes, typically used either for memory or storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].  This makes it somewhat inconvenient to define constructors: a u32 constructor can be infallible, but an i64 constructor can fail (if the value is negative) and a u64 constructor can fail (if the value is larger than i64::MAX).  We provide all of these for consumers' convenience."]
    pub block_size: u64,
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    pub device_path: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_id: Option<uuid::Uuid>,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    pub project_id: uuid::Uuid,
    #[doc = "A count of bytes, typically used either for memory or storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].  This makes it somewhat inconvenient to define constructors: a u32 constructor can be infallible, but an i64 constructor can fail (if the value is negative) and a u64 constructor can fail (if the value is larger than i64::MAX).  We provide all of these for consumers' convenience."]
    pub size: u64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub snapshot_id: Option<uuid::Uuid>,
    #[doc = "State of a Disk (primarily: attached or not)"]
    pub state: DiskState,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Disk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Disk {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.block_size).into(),
            self.description.clone().into(),
            self.device_path.clone().into(),
            format!("{:?}", self.id).into(),
            if let Some(image_id) = &self.image_id {
                format!("{:?}", image_id).into()
            } else {
                String::new().into()
            },
            self.name.clone().into(),
            format!("{:?}", self.project_id).into(),
            format!("{:?}", self.size).into(),
            if let Some(snapshot_id) = &self.snapshot_id {
                format!("{:?}", snapshot_id).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.state).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "block_size".into(),
            "description".into(),
            "device_path".into(),
            "id".into(),
            "image_id".into(),
            "name".into(),
            "project_id".into(),
            "size".into(),
            "snapshot_id".into(),
            "state".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "Create-time parameters for a [`Disk`](omicron_common::api::external::Disk)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiskCreate {
    pub description: String,
    #[doc = "initial source for this disk"]
    pub disk_source: DiskSource,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
    #[doc = "total size of the Disk in bytes"]
    pub size: u64,
}

impl std::fmt::Display for DiskCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DiskCreate {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.disk_source).into(),
            self.name.clone().into(),
            format!("{:?}", self.size).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "disk_source".into(),
            "name".into(),
            "size".into(),
        ]
    }
}

#[doc = "Parameters for the [`Disk`](omicron_common::api::external::Disk) to be attached or detached to an instance"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiskIdentifier {
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
}

impl std::fmt::Display for DiskIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DiskIdentifier {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.name.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["name".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct DiskResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Disk>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for DiskResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for DiskResultsPage {
    type Item = Disk;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for DiskResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Different sources for a disk"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum DiskSource {
    #[doc = "Create a blank disk"]
    #[serde(rename = "blank")]
    Blank {
        #[doc = "size of blocks for this Disk. valid values are: 512, 2048, or 4096"]
        block_size: i64,
    },
    #[doc = "Create a disk from a disk snapshot"]
    #[serde(rename = "snapshot")]
    Snapshot { snapshot_id: uuid::Uuid },
    #[doc = "Create a disk from a project image"]
    #[serde(rename = "image")]
    Image { image_id: uuid::Uuid },
    #[doc = "Create a disk from a global image"]
    #[serde(rename = "global_image")]
    GlobalImage { image_id: uuid::Uuid },
}

#[doc = "State of a Disk (primarily: attached or not)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "state")]
pub enum DiskState {
    #[doc = "Disk is being initialized"]
    #[serde(rename = "creating")]
    Creating {},
    #[doc = "Disk is ready but detached from any Instance"]
    #[serde(rename = "detached")]
    Detached {},
    #[doc = "Disk is being attached to the given Instance"]
    #[serde(rename = "attaching")]
    Attaching { instance: uuid::Uuid },
    #[doc = "Disk is attached to the given Instance"]
    #[serde(rename = "attached")]
    Attached { instance: uuid::Uuid },
    #[doc = "Disk is being detached from the given Instance"]
    #[serde(rename = "detaching")]
    Detaching { instance: uuid::Uuid },
    #[doc = "Disk has been destroyed"]
    #[serde(rename = "destroyed")]
    Destroyed {},
    #[doc = "Disk is unavailable"]
    #[serde(rename = "faulted")]
    Faulted {},
}

#[doc = "OS image distribution"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Distribution {
    #[doc = "The name of the distribution (e.g. \"alpine\" or \"ubuntu\")"]
    pub name: String,
    #[doc = "The version of the distribution (e.g. \"3.10\" or \"18.04\")"]
    pub version: String,
}

impl std::fmt::Display for Distribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Distribution {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.name.clone().into(), self.version.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["name".into(), "version".into()]
    }
}

#[doc = "Error information from a response."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Error {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    pub message: String,
    pub request_id: String,
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Error {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(error_code) = &self.error_code {
                format!("{:?}", error_code).into()
            } else {
                String::new().into()
            },
            self.message.clone().into(),
            self.request_id.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["error_code".into(), "message".into(), "request_id".into()]
    }
}

#[doc = "The name and type information for a field of a timeseries schema."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FieldSchema {
    pub name: String,
    #[doc = "The source from which a field is derived, the target or metric."]
    pub source: FieldSource,
    #[doc = "The `FieldType` identifies the data type of a target or metric field."]
    pub ty: FieldType,
}

impl std::fmt::Display for FieldSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FieldSchema {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.name.clone().into(),
            format!("{:?}", self.source).into(),
            format!("{:?}", self.ty).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["name".into(), "source".into(), "ty".into()]
    }
}

#[doc = "The source from which a field is derived, the target or metric."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum FieldSource {
    #[serde(rename = "target")]
    #[display("target")]
    Target,
    #[serde(rename = "metric")]
    #[display("metric")]
    Metric,
}

#[doc = "The `FieldType` identifies the data type of a target or metric field."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum FieldType {
    #[serde(rename = "string")]
    #[display("string")]
    String,
    #[serde(rename = "i64")]
    #[display("i64")]
    I64,
    #[serde(rename = "ip_addr")]
    #[display("ip_addr")]
    IpAddr,
    #[serde(rename = "uuid")]
    #[display("uuid")]
    Uuid,
    #[serde(rename = "bool")]
    #[display("bool")]
    Bool,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum FleetRole {
    #[serde(rename = "admin")]
    #[display("admin")]
    Admin,
    #[serde(rename = "collaborator")]
    #[display("collaborator")]
    Collaborator,
    #[serde(rename = "viewer")]
    #[display("viewer")]
    Viewer,
}

#[doc = "Client view of a [`Policy`], which describes how this resource may be accessed\n\nNote that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FleetRolePolicy {
    #[doc = "Roles directly assigned on this resource"]
    pub role_assignments: Vec<FleetRoleRoleAssignment>,
}

impl std::fmt::Display for FleetRolePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FleetRolePolicy {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.role_assignments).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["role_assignments".into()]
    }
}

#[doc = "Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)\n\nThe resource is not part of this structure.  Rather, [`RoleAssignment`]s are put into a [`Policy`] and that Policy is applied to a particular resource."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct FleetRoleRoleAssignment {
    pub identity_id: uuid::Uuid,
    #[doc = "Describes what kind of identity is described by an id"]
    pub identity_type: IdentityType,
    pub role_name: FleetRole,
}

impl std::fmt::Display for FleetRoleRoleAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for FleetRoleRoleAssignment {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.identity_id).into(),
            format!("{:?}", self.identity_type).into(),
            format!("{:?}", self.role_name).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "identity_id".into(),
            "identity_type".into(),
            "role_name".into(),
        ]
    }
}

#[doc = "Client view of global Images"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GlobalImage {
    #[doc = "size of blocks in bytes"]
    pub block_size: u64,
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "Hash of the image contents, if applicable"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub digest: Option<Digest>,
    #[doc = "Image distribution"]
    pub distribution: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "total size in bytes"]
    pub size: u64,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
    #[doc = "URL source of this image, if any"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[doc = "Image version"]
    pub version: String,
}

impl std::fmt::Display for GlobalImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for GlobalImage {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.block_size).into(),
            self.description.clone().into(),
            if let Some(digest) = &self.digest {
                format!("{:?}", digest).into()
            } else {
                String::new().into()
            },
            self.distribution.clone().into(),
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            format!("{:?}", self.size).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
            if let Some(url) = &self.url {
                format!("{:?}", url).into()
            } else {
                String::new().into()
            },
            self.version.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "block_size".into(),
            "description".into(),
            "digest".into(),
            "distribution".into(),
            "id".into(),
            "name".into(),
            "size".into(),
            "time_created".into(),
            "time_modified".into(),
            "url".into(),
            "version".into(),
        ]
    }
}

#[doc = "Create-time parameters for an [`GlobalImage`](omicron_common::api::external::GlobalImage)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GlobalImageCreate {
    #[doc = "block size in bytes"]
    pub block_size: i64,
    pub description: String,
    #[doc = "OS image distribution"]
    pub distribution: Distribution,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
    #[doc = "The source of the image's contents."]
    pub source: ImageSource,
}

impl std::fmt::Display for GlobalImageCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for GlobalImageCreate {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.block_size).into(),
            self.description.clone().into(),
            format!("{:?}", self.distribution).into(),
            self.name.clone().into(),
            format!("{:?}", self.source).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "block_size".into(),
            "description".into(),
            "distribution".into(),
            "name".into(),
            "source".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct GlobalImageResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<GlobalImage>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for GlobalImageResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for GlobalImageResultsPage {
    type Item = GlobalImage;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for GlobalImageResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Client view of an [`IdentityProvider`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IdentityProvider {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "Identity provider type"]
    pub provider_type: IdentityProviderType,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for IdentityProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IdentityProvider {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            format!("{:?}", self.provider_type).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "id".into(),
            "name".into(),
            "provider_type".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IdentityProviderResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<IdentityProvider>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for IdentityProviderResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for IdentityProviderResultsPage {
    type Item = IdentityProvider;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IdentityProviderResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum IdentityProviderType {
    #[serde(rename = "saml")]
    #[display("saml")]
    Saml,
}

impl std::default::Default for IdentityProviderType {
    fn default() -> Self {
        IdentityProviderType::Saml
    }
}

#[doc = "Describes what kind of identity is described by an id"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum IdentityType {
    #[serde(rename = "silo_user")]
    #[display("silo_user")]
    SiloUser,
}

impl std::default::Default for IdentityType {
    fn default() -> Self {
        IdentityType::SiloUser
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum IdpMetadataSource {
    #[serde(rename = "url")]
    Url { url: String },
    #[serde(rename = "base64_encoded_xml")]
    Base64EncodedXml { data: String },
}

#[doc = "Client view of project Images"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Image {
    #[doc = "size of blocks in bytes"]
    pub block_size: u64,
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "Hash of the image contents, if applicable"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub digest: Option<Digest>,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "The project the disk belongs to"]
    pub project_id: uuid::Uuid,
    #[doc = "total size in bytes"]
    pub size: u64,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
    #[doc = "URL source of this image, if any"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[doc = "Version of this, if any"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

impl std::fmt::Display for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Image {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.block_size).into(),
            self.description.clone().into(),
            if let Some(digest) = &self.digest {
                format!("{:?}", digest).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            format!("{:?}", self.project_id).into(),
            format!("{:?}", self.size).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
            if let Some(url) = &self.url {
                format!("{:?}", url).into()
            } else {
                String::new().into()
            },
            if let Some(version) = &self.version {
                format!("{:?}", version).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "block_size".into(),
            "description".into(),
            "digest".into(),
            "id".into(),
            "name".into(),
            "project_id".into(),
            "size".into(),
            "time_created".into(),
            "time_modified".into(),
            "url".into(),
            "version".into(),
        ]
    }
}

#[doc = "Create-time parameters for an [`Image`](omicron_common::api::external::Image)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ImageCreate {
    #[doc = "block size in bytes"]
    pub block_size: i64,
    pub description: String,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
    #[doc = "The source of the image's contents."]
    pub source: ImageSource,
}

impl std::fmt::Display for ImageCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ImageCreate {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.block_size).into(),
            self.description.clone().into(),
            self.name.clone().into(),
            format!("{:?}", self.source).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "block_size".into(),
            "description".into(),
            "name".into(),
            "source".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ImageResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Image>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ImageResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ImageResultsPage {
    type Item = Image;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ImageResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "The source of the underlying image."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum ImageSource {
    #[serde(rename = "url")]
    Url { url: String },
    #[serde(rename = "snapshot")]
    Snapshot { id: uuid::Uuid },
    #[doc = "Boot the Alpine ISO that ships with the Propolis zone. Intended for development purposes only."]
    #[serde(rename = "you_can_boot_anything_as_long_as_its_alpine")]
    YouCanBootAnythingAsLongAsItsAlpine {},
}

#[doc = "Client view of an [`Instance`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Instance {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "RFC1035-compliant hostname for the Instance."]
    pub hostname: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "memory allocated for this Instance"]
    pub memory: u64,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "number of CPUs allocated for this Instance"]
    pub ncpus: u16,
    #[doc = "id for the project containing this Instance"]
    pub project_id: uuid::Uuid,
    #[doc = "Running state of an Instance (primarily: booted or stopped)\n\nThis typically reflects whether it's starting, running, stopping, or stopped, but also includes states related to the Instance's lifecycle"]
    pub run_state: InstanceState,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
    pub time_run_state_updated: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Instance {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            self.hostname.clone().into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.memory).into(),
            self.name.clone().into(),
            format!("{:?}", self.ncpus).into(),
            format!("{:?}", self.project_id).into(),
            format!("{:?}", self.run_state).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
            format!("{:?}", self.time_run_state_updated).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "hostname".into(),
            "id".into(),
            "memory".into(),
            "name".into(),
            "ncpus".into(),
            "project_id".into(),
            "run_state".into(),
            "time_created".into(),
            "time_modified".into(),
            "time_run_state_updated".into(),
        ]
    }
}

#[doc = "Create-time parameters for an [`Instance`](omicron_common::api::external::Instance)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstanceCreate {
    pub description: String,
    #[doc = "The disks to be created or attached for this instance."]
    #[serde(default)]
    pub disks: Vec<InstanceDiskAttachment>,
    pub hostname: String,
    #[doc = "A count of bytes, typically used either for memory or storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].  This makes it somewhat inconvenient to define constructors: a u32 constructor can be infallible, but an i64 constructor can fail (if the value is negative) and a u64 constructor can fail (if the value is larger than i64::MAX).  We provide all of these for consumers' convenience."]
    pub memory: u64,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
    #[doc = "The number of CPUs in an Instance"]
    pub ncpus: u16,
    #[doc = "The network interfaces to be created for this instance."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network_interfaces: Option<InstanceNetworkInterfaceAttachment>,
    #[doc = "User data for instance initialization systems (such as cloud-init). Must be a Base64-encoded string, as specified in RFC 4648 § 4 (+ and / characters with padding). Maximum 32 KiB unencoded data."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user_data: Option<base64::Base64Data>,
}

impl std::fmt::Display for InstanceCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for InstanceCreate {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.disks).into(),
            self.hostname.clone().into(),
            format!("{:?}", self.memory).into(),
            self.name.clone().into(),
            format!("{:?}", self.ncpus).into(),
            if let Some(network_interfaces) = &self.network_interfaces {
                format!("{:?}", network_interfaces).into()
            } else {
                String::new().into()
            },
            if let Some(user_data) = &self.user_data {
                format!("{:?}", user_data).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "disks".into(),
            "hostname".into(),
            "memory".into(),
            "name".into(),
            "ncpus".into(),
            "network_interfaces".into(),
            "user_data".into(),
        ]
    }
}

#[doc = "Describe the instance's disks at creation time"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum InstanceDiskAttachment {
    #[doc = "During instance creation, create and attach disks"]
    #[serde(rename = "create")]
    Create {
        description: String,
        #[doc = "initial source for this disk"]
        disk_source: DiskSource,
        #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
        name: String,
        #[doc = "total size of the Disk in bytes"]
        size: u64,
    },
    #[doc = "During instance creation, attach this disk"]
    #[serde(rename = "attach")]
    Attach {
        #[doc = "A disk name to attach"]
        name: String,
    },
}

#[doc = "Migration parameters for an [`Instance`](omicron_common::api::external::Instance)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstanceMigrate {
    pub dst_sled_id: uuid::Uuid,
}

impl std::fmt::Display for InstanceMigrate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for InstanceMigrate {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.dst_sled_id).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["dst_sled_id".into()]
    }
}

#[doc = "Describes an attachment of a `NetworkInterface` to an `Instance`, at the time the instance is created."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type")]
pub enum InstanceNetworkInterfaceAttachment {
    #[doc = "Create one or more `NetworkInterface`s for the `Instance`.\n\nIf more than one interface is provided, then the first will be designated the primary interface for the instance."]
    #[serde(rename = "create")]
    Create { params: Vec<NetworkInterfaceCreate> },
    #[doc = "The default networking configuration for an instance is to create a single primary interface with an automatically-assigned IP address. The IP will be pulled from the Project's default VPC / VPC Subnet."]
    #[serde(rename = "default")]
    Default {},
    #[doc = "No network interfaces at all will be created for the instance."]
    #[serde(rename = "none")]
    None {},
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstanceResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Instance>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for InstanceResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for InstanceResultsPage {
    type Item = Instance;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for InstanceResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Contents of an Instance's serial console buffer."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct InstanceSerialConsoleData {
    #[doc = "The bytes starting from the requested offset up to either the end of the buffer or the request's `max_bytes`. Provided as a u8 array rather than a string, as it may not be UTF-8."]
    #[serde(
        serialize_with = "serde_bytes::serialize",
        deserialize_with = "serde_bytes::deserialize"
    )]
    pub data: Vec<u8>,
    #[doc = "The absolute offset since boot (suitable for use as `byte_offset` in a subsequent request) of the last byte returned in `data`."]
    pub last_byte_offset: u64,
}

impl std::fmt::Display for InstanceSerialConsoleData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for InstanceSerialConsoleData {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.data).into(),
            format!("{:?}", self.last_byte_offset).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["data".into(), "last_byte_offset".into()]
    }
}

#[doc = "Running state of an Instance (primarily: booted or stopped)\n\nThis typically reflects whether it's starting, running, stopping, or stopped, but also includes states related to the Instance's lifecycle"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum InstanceState {
    #[serde(rename = "creating")]
    #[display("creating")]
    Creating,
    #[serde(rename = "starting")]
    #[display("starting")]
    Starting,
    #[serde(rename = "running")]
    #[display("running")]
    Running,
    #[serde(rename = "stopping")]
    #[display("stopping")]
    Stopping,
    #[serde(rename = "stopped")]
    #[display("stopped")]
    Stopped,
    #[serde(rename = "rebooting")]
    #[display("rebooting")]
    Rebooting,
    #[serde(rename = "migrating")]
    #[display("migrating")]
    Migrating,
    #[serde(rename = "repairing")]
    #[display("repairing")]
    Repairing,
    #[serde(rename = "failed")]
    #[display("failed")]
    Failed,
    #[serde(rename = "destroyed")]
    #[display("destroyed")]
    Destroyed,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum IpNet {
    V4(String),
    V6(String),
}

#[doc = "Identity-related metadata that's included in nearly all public API objects"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IpPool {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for IpPool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IpPool {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "id".into(),
            "name".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "Create-time parameters for an IP Pool.\n\nSee [`IpPool`](omicron_nexus::external_api::views::IpPool)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IpPoolCreate {
    pub description: String,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
}

impl std::fmt::Display for IpPoolCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IpPoolCreate {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.description.clone().into(), self.name.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IpPoolRange {
    pub id: uuid::Uuid,
    pub range: IpRange,
    pub time_created: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for IpPoolRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IpPoolRange {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.id).into(),
            format!("{:?}", self.range).into(),
            format!("{:?}", self.time_created).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["id".into(), "range".into(), "time_created".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IpPoolRangeResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<IpPoolRange>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for IpPoolRangeResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for IpPoolRangeResultsPage {
    type Item = IpPoolRange;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IpPoolRangeResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IpPoolResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<IpPool>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for IpPoolResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for IpPoolResultsPage {
    type Item = IpPool;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IpPoolResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Parameters for updating an IP Pool"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IpPoolUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for IpPoolUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for IpPoolUpdate {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum IpRange {
    V4(Ipv4Range),
    V6(Ipv6Range),
}

#[doc = "A non-decreasing IPv4 address range, inclusive of both ends.\n\nThe first address must be less than or equal to the last address."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Ipv4Range {
    pub first: std::net::Ipv4Addr,
    pub last: std::net::Ipv4Addr,
}

impl std::fmt::Display for Ipv4Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Ipv4Range {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.first).into(),
            format!("{:?}", self.last).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["first".into(), "last".into()]
    }
}

#[doc = "A non-decreasing IPv6 address range, inclusive of both ends.\n\nThe first address must be less than or equal to the last address."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Ipv6Range {
    pub first: std::net::Ipv6Addr,
    pub last: std::net::Ipv6Addr,
}

impl std::fmt::Display for Ipv6Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Ipv6Range {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.first).into(),
            format!("{:?}", self.last).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["first".into(), "last".into()]
    }
}

#[doc = "A `NetworkInterface` represents a virtual network interface device."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NetworkInterface {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "The Instance to which the interface belongs."]
    pub instance_id: uuid::Uuid,
    #[doc = "The IP address assigned to this interface."]
    pub ip: std::net::IpAddr,
    #[doc = "The MAC address assigned to this interface."]
    pub mac: String,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "True if this interface is the primary for the instance to which it's attached."]
    pub primary: bool,
    #[doc = "The subnet to which the interface belongs."]
    pub subnet_id: uuid::Uuid,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
    #[doc = "The VPC to which the interface belongs."]
    pub vpc_id: uuid::Uuid,
}

impl std::fmt::Display for NetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for NetworkInterface {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.instance_id).into(),
            format!("{:?}", self.ip).into(),
            self.mac.clone().into(),
            self.name.clone().into(),
            format!("{:?}", self.primary).into(),
            format!("{:?}", self.subnet_id).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
            format!("{:?}", self.vpc_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "id".into(),
            "instance_id".into(),
            "ip".into(),
            "mac".into(),
            "name".into(),
            "primary".into(),
            "subnet_id".into(),
            "time_created".into(),
            "time_modified".into(),
            "vpc_id".into(),
        ]
    }
}

#[doc = "Create-time parameters for a [`NetworkInterface`](omicron_common::api::external::NetworkInterface)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NetworkInterfaceCreate {
    pub description: String,
    #[doc = "The IP address for the interface. One will be auto-assigned if not provided."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<std::net::IpAddr>,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
    #[doc = "The VPC Subnet in which to create the interface."]
    pub subnet_name: String,
    #[doc = "The VPC in which to create the interface."]
    pub vpc_name: String,
}

impl std::fmt::Display for NetworkInterfaceCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for NetworkInterfaceCreate {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            if let Some(ip) = &self.ip {
                format!("{:?}", ip).into()
            } else {
                String::new().into()
            },
            self.name.clone().into(),
            self.subnet_name.clone().into(),
            self.vpc_name.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "ip".into(),
            "name".into(),
            "subnet_name".into(),
            "vpc_name".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NetworkInterfaceResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<NetworkInterface>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for NetworkInterfaceResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for NetworkInterfaceResultsPage {
    type Item = NetworkInterface;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for NetworkInterfaceResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Parameters for updating a [`NetworkInterface`](omicron_common::api::external::NetworkInterface).\n\nNote that modifying IP addresses for an interface is not yet supported, a new interface must be created instead."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct NetworkInterfaceUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "Make a secondary interface the instance's primary interface.\n\nIf applied to a secondary interface, that interface will become the primary on the next reboot of the instance. Note that this may have implications for routing between instances, as the new primary interface will be on a distinct subnet from the previous primary interface.\n\nNote that this can only be used to select a new primary interface for an instance. Requests to change the primary interface into a secondary will return an error."]
    #[serde(default)]
    pub make_primary: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for NetworkInterfaceUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for NetworkInterfaceUpdate {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.make_primary).into(),
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "make_primary".into(), "name".into()]
    }
}

#[doc = "Client view of an [`Organization`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Organization {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Organization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Organization {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "id".into(),
            "name".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "Create-time parameters for an [`Organization`](crate::external_api::views::Organization)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationCreate {
    pub description: String,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
}

impl std::fmt::Display for OrganizationCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrganizationCreate {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.description.clone().into(), self.name.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Organization>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for OrganizationResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for OrganizationResultsPage {
    type Item = Organization;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrganizationResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum OrganizationRole {
    #[serde(rename = "admin")]
    #[display("admin")]
    Admin,
    #[serde(rename = "collaborator")]
    #[display("collaborator")]
    Collaborator,
    #[serde(rename = "viewer")]
    #[display("viewer")]
    Viewer,
}

#[doc = "Client view of a [`Policy`], which describes how this resource may be accessed\n\nNote that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationRolePolicy {
    #[doc = "Roles directly assigned on this resource"]
    pub role_assignments: Vec<OrganizationRoleRoleAssignment>,
}

impl std::fmt::Display for OrganizationRolePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrganizationRolePolicy {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.role_assignments).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["role_assignments".into()]
    }
}

#[doc = "Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)\n\nThe resource is not part of this structure.  Rather, [`RoleAssignment`]s are put into a [`Policy`] and that Policy is applied to a particular resource."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationRoleRoleAssignment {
    pub identity_id: uuid::Uuid,
    #[doc = "Describes what kind of identity is described by an id"]
    pub identity_type: IdentityType,
    pub role_name: OrganizationRole,
}

impl std::fmt::Display for OrganizationRoleRoleAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrganizationRoleRoleAssignment {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.identity_id).into(),
            format!("{:?}", self.identity_type).into(),
            format!("{:?}", self.role_name).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "identity_id".into(),
            "identity_type".into(),
            "role_name".into(),
        ]
    }
}

#[doc = "Updateable properties of an [`Organization`](crate::external_api::views::Organization)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct OrganizationUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for OrganizationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for OrganizationUpdate {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into()]
    }
}

#[doc = "Client view of a [`Project`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Project {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    pub organization_id: uuid::Uuid,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Project {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Project {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            format!("{:?}", self.organization_id).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "id".into(),
            "name".into(),
            "organization_id".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "Create-time parameters for a [`Project`](crate::external_api::views::Project)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectCreate {
    pub description: String,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
}

impl std::fmt::Display for ProjectCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ProjectCreate {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.description.clone().into(), self.name.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Project>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for ProjectResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for ProjectResultsPage {
    type Item = Project;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ProjectResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum ProjectRole {
    #[serde(rename = "admin")]
    #[display("admin")]
    Admin,
    #[serde(rename = "collaborator")]
    #[display("collaborator")]
    Collaborator,
    #[serde(rename = "viewer")]
    #[display("viewer")]
    Viewer,
}

#[doc = "Client view of a [`Policy`], which describes how this resource may be accessed\n\nNote that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectRolePolicy {
    #[doc = "Roles directly assigned on this resource"]
    pub role_assignments: Vec<ProjectRoleRoleAssignment>,
}

impl std::fmt::Display for ProjectRolePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ProjectRolePolicy {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.role_assignments).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["role_assignments".into()]
    }
}

#[doc = "Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)\n\nThe resource is not part of this structure.  Rather, [`RoleAssignment`]s are put into a [`Policy`] and that Policy is applied to a particular resource."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectRoleRoleAssignment {
    pub identity_id: uuid::Uuid,
    #[doc = "Describes what kind of identity is described by an id"]
    pub identity_type: IdentityType,
    pub role_name: ProjectRole,
}

impl std::fmt::Display for ProjectRoleRoleAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ProjectRoleRoleAssignment {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.identity_id).into(),
            format!("{:?}", self.identity_type).into(),
            format!("{:?}", self.role_name).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "identity_id".into(),
            "identity_type".into(),
            "role_name".into(),
        ]
    }
}

#[doc = "Updateable properties of a [`Project`](crate::external_api::views::Project)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ProjectUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for ProjectUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for ProjectUpdate {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into()]
    }
}

#[doc = "Client view of an [`Rack`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Rack {
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Rack {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Rack {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.id).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["id".into(), "time_created".into(), "time_modified".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RackResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Rack>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for RackResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for RackResultsPage {
    type Item = Rack;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RackResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Client view of a [`Role`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Role {
    pub description: String,
    #[doc = "Role names consist of two string components separated by dot (\".\")."]
    pub name: String,
}

impl std::fmt::Display for Role {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Role {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.description.clone().into(), self.name.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RoleResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Role>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for RoleResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for RoleResultsPage {
    type Item = Role;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RoleResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "A `RouteDestination` is used to match traffic with a routing rule, on the destination of that traffic.\n\nWhen traffic is to be sent to a destination that is within a given `RouteDestination`, the corresponding [`RouterRoute`] applies, and traffic will be forward to the [`RouteTarget`] for that rule."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type", content = "value")]
pub enum RouteDestination {
    #[doc = "Route applies to traffic destined for a specific IP address"]
    #[serde(rename = "ip")]
    Ip(std::net::IpAddr),
    #[doc = "Route applies to traffic destined for a specific IP subnet"]
    #[serde(rename = "ip_net")]
    IpNet(IpNet),
    #[doc = "Route applies to traffic destined for the given VPC."]
    #[serde(rename = "vpc")]
    Vpc(String),
    #[doc = "Route applies to traffic"]
    #[serde(rename = "subnet")]
    Subnet(String),
}

#[doc = "A `RouteTarget` describes the possible locations that traffic matching a route destination can be sent."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type", content = "value")]
pub enum RouteTarget {
    #[doc = "Forward traffic to a particular IP address."]
    #[serde(rename = "ip")]
    Ip(std::net::IpAddr),
    #[doc = "Forward traffic to a VPC"]
    #[serde(rename = "vpc")]
    Vpc(String),
    #[doc = "Forward traffic to a VPC Subnet"]
    #[serde(rename = "subnet")]
    Subnet(String),
    #[doc = "Forward traffic to a specific instance"]
    #[serde(rename = "instance")]
    Instance(String),
    #[doc = "Forward traffic to an internet gateway"]
    #[serde(rename = "internet_gateway")]
    InternetGateway(String),
}

#[doc = "A route defines a rule that governs where traffic should be sent based on its destination."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RouterRoute {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "A `RouteDestination` is used to match traffic with a routing rule, on the destination of that traffic.\n\nWhen traffic is to be sent to a destination that is within a given `RouteDestination`, the corresponding [`RouterRoute`] applies, and traffic will be forward to the [`RouteTarget`] for that rule."]
    pub destination: RouteDestination,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "Describes the kind of router. Set at creation. `read-only`"]
    pub kind: RouterRouteKind,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "A `RouteTarget` describes the possible locations that traffic matching a route destination can be sent."]
    pub target: RouteTarget,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
    #[doc = "The VPC Router to which the route belongs."]
    pub vpc_router_id: uuid::Uuid,
}

impl std::fmt::Display for RouterRoute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RouterRoute {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.destination).into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.kind).into(),
            self.name.clone().into(),
            format!("{:?}", self.target).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
            format!("{:?}", self.vpc_router_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "destination".into(),
            "id".into(),
            "kind".into(),
            "name".into(),
            "target".into(),
            "time_created".into(),
            "time_modified".into(),
            "vpc_router_id".into(),
        ]
    }
}

#[doc = "Create-time parameters for a [`RouterRoute`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RouterRouteCreateParams {
    pub description: String,
    #[doc = "A `RouteDestination` is used to match traffic with a routing rule, on the destination of that traffic.\n\nWhen traffic is to be sent to a destination that is within a given `RouteDestination`, the corresponding [`RouterRoute`] applies, and traffic will be forward to the [`RouteTarget`] for that rule."]
    pub destination: RouteDestination,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
    #[doc = "A `RouteTarget` describes the possible locations that traffic matching a route destination can be sent."]
    pub target: RouteTarget,
}

impl std::fmt::Display for RouterRouteCreateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RouterRouteCreateParams {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.destination).into(),
            self.name.clone().into(),
            format!("{:?}", self.target).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "destination".into(),
            "name".into(),
            "target".into(),
        ]
    }
}

#[doc = "The classification of a [`RouterRoute`] as defined by the system. The kind determines certain attributes such as if the route is modifiable and describes how or where the route was created.\n\nSee [RFD-21](https://rfd.shared.oxide.computer/rfd/0021#concept-router) for more context"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum RouterRouteKind {
    #[serde(rename = "default")]
    #[display("default")]
    Default,
    #[serde(rename = "vpc_subnet")]
    #[display("vpc_subnet")]
    VpcSubnet,
    #[serde(rename = "vpc_peering")]
    #[display("vpc_peering")]
    VpcPeering,
    #[serde(rename = "custom")]
    #[display("custom")]
    Custom,
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RouterRouteResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<RouterRoute>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for RouterRouteResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for RouterRouteResultsPage {
    type Item = RouterRoute;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RouterRouteResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Updateable properties of a [`RouterRoute`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct RouterRouteUpdateParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "A `RouteDestination` is used to match traffic with a routing rule, on the destination of that traffic.\n\nWhen traffic is to be sent to a destination that is within a given `RouteDestination`, the corresponding [`RouterRoute`] applies, and traffic will be forward to the [`RouteTarget`] for that rule."]
    pub destination: RouteDestination,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "A `RouteTarget` describes the possible locations that traffic matching a route destination can be sent."]
    pub target: RouteTarget,
}

impl std::fmt::Display for RouterRouteUpdateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for RouterRouteUpdateParams {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.destination).into(),
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
            format!("{:?}", self.target).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "destination".into(),
            "name".into(),
            "target".into(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Saga {
    pub id: uuid::Uuid,
    pub state: SagaState,
}

impl std::fmt::Display for Saga {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Saga {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.id).into(),
            format!("{:?}", self.state).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["id".into(), "state".into()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "error")]
pub enum SagaErrorInfo {
    #[serde(rename = "action_failed")]
    ActionFailed { source_error: serde_json::Value },
    #[serde(rename = "deserialize_failed")]
    DeserializeFailed { message: String },
    #[serde(rename = "injected_error")]
    InjectedError {},
    #[serde(rename = "serialize_failed")]
    SerializeFailed { message: String },
    #[serde(rename = "subsaga_create_failed")]
    SubsagaCreateFailed { message: String },
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SagaResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Saga>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for SagaResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for SagaResultsPage {
    type Item = Saga;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SagaResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "state")]
pub enum SagaState {
    #[serde(rename = "running")]
    Running {},
    #[serde(rename = "succeeded")]
    Succeeded {},
    #[serde(rename = "failed")]
    Failed {
        error_info: SagaErrorInfo,
        error_node_name: String,
    },
}

#[doc = "Identity-related metadata that's included in nearly all public API objects"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SamlIdentityProvider {
    #[doc = "service provider endpoint where the response will be sent"]
    pub acs_url: String,
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "idp's entity id"]
    pub idp_entity_id: String,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "optional request signing public certificate (base64 encoded der file)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_cert: Option<String>,
    #[doc = "service provider endpoint where the idp should send log out requests"]
    pub slo_url: String,
    #[doc = "sp's client id"]
    pub sp_client_id: String,
    #[doc = "customer's technical contact for saml configuration"]
    pub technical_contact_email: String,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for SamlIdentityProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SamlIdentityProvider {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.acs_url.clone().into(),
            self.description.clone().into(),
            format!("{:?}", self.id).into(),
            self.idp_entity_id.clone().into(),
            self.name.clone().into(),
            if let Some(public_cert) = &self.public_cert {
                format!("{:?}", public_cert).into()
            } else {
                String::new().into()
            },
            self.slo_url.clone().into(),
            self.sp_client_id.clone().into(),
            self.technical_contact_email.clone().into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "acs_url".into(),
            "description".into(),
            "id".into(),
            "idp_entity_id".into(),
            "name".into(),
            "public_cert".into(),
            "slo_url".into(),
            "sp_client_id".into(),
            "technical_contact_email".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "Create-time identity-related parameters"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SamlIdentityProviderCreate {
    #[doc = "service provider endpoint where the response will be sent"]
    pub acs_url: String,
    pub description: String,
    #[doc = "idp's entity id"]
    pub idp_entity_id: String,
    #[doc = "the source of an identity provider metadata descriptor"]
    pub idp_metadata_source: IdpMetadataSource,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
    #[doc = "optional request signing key pair"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signing_keypair: Option<DerEncodedKeyPair>,
    #[doc = "service provider endpoint where the idp should send log out requests"]
    pub slo_url: String,
    #[doc = "sp's client id"]
    pub sp_client_id: String,
    #[doc = "customer's technical contact for saml configuration"]
    pub technical_contact_email: String,
}

impl std::fmt::Display for SamlIdentityProviderCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SamlIdentityProviderCreate {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.acs_url.clone().into(),
            self.description.clone().into(),
            self.idp_entity_id.clone().into(),
            format!("{:?}", self.idp_metadata_source).into(),
            self.name.clone().into(),
            if let Some(signing_keypair) = &self.signing_keypair {
                format!("{:?}", signing_keypair).into()
            } else {
                String::new().into()
            },
            self.slo_url.clone().into(),
            self.sp_client_id.clone().into(),
            self.technical_contact_email.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "acs_url".into(),
            "description".into(),
            "idp_entity_id".into(),
            "idp_metadata_source".into(),
            "name".into(),
            "signing_keypair".into(),
            "slo_url".into(),
            "sp_client_id".into(),
            "technical_contact_email".into(),
        ]
    }
}

#[doc = "Client view of a ['Silo']"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Silo {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "A silo where discoverable is false can be retrieved only by its id - it will not be part of the \"list all silos\" output."]
    pub discoverable: bool,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
    #[doc = "User provision type"]
    pub user_provision_type: UserProvisionType,
}

impl std::fmt::Display for Silo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Silo {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.discoverable).into(),
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
            format!("{:?}", self.user_provision_type).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "discoverable".into(),
            "id".into(),
            "name".into(),
            "time_created".into(),
            "time_modified".into(),
            "user_provision_type".into(),
        ]
    }
}

#[doc = "Create-time parameters for a [`Silo`](crate::external_api::views::Silo)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SiloCreate {
    pub description: String,
    pub discoverable: bool,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
    #[doc = "How users will be provisioned in a silo during authentication."]
    pub user_provision_type: UserProvisionType,
}

impl std::fmt::Display for SiloCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SiloCreate {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.discoverable).into(),
            self.name.clone().into(),
            format!("{:?}", self.user_provision_type).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "discoverable".into(),
            "name".into(),
            "user_provision_type".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SiloResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Silo>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for SiloResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for SiloResultsPage {
    type Item = Silo;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SiloResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum SiloRole {
    #[serde(rename = "admin")]
    #[display("admin")]
    Admin,
    #[serde(rename = "collaborator")]
    #[display("collaborator")]
    Collaborator,
    #[serde(rename = "viewer")]
    #[display("viewer")]
    Viewer,
}

#[doc = "Client view of a [`Policy`], which describes how this resource may be accessed\n\nNote that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SiloRolePolicy {
    #[doc = "Roles directly assigned on this resource"]
    pub role_assignments: Vec<SiloRoleRoleAssignment>,
}

impl std::fmt::Display for SiloRolePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SiloRolePolicy {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.role_assignments).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["role_assignments".into()]
    }
}

#[doc = "Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)\n\nThe resource is not part of this structure.  Rather, [`RoleAssignment`]s are put into a [`Policy`] and that Policy is applied to a particular resource."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SiloRoleRoleAssignment {
    pub identity_id: uuid::Uuid,
    #[doc = "Describes what kind of identity is described by an id"]
    pub identity_type: IdentityType,
    pub role_name: SiloRole,
}

impl std::fmt::Display for SiloRoleRoleAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SiloRoleRoleAssignment {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.identity_id).into(),
            format!("{:?}", self.identity_type).into(),
            format!("{:?}", self.role_name).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "identity_id".into(),
            "identity_type".into(),
            "role_name".into(),
        ]
    }
}

#[doc = "Client view of an [`Sled`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Sled {
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    pub service_address: String,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Sled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Sled {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.id).into(),
            self.service_address.clone().into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "id".into(),
            "service_address".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SledResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Sled>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for SledResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for SledResultsPage {
    type Item = Sled;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SledResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Client view of a Snapshot"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Snapshot {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    pub disk_id: uuid::Uuid,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    pub project_id: uuid::Uuid,
    #[doc = "A count of bytes, typically used either for memory or storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].  This makes it somewhat inconvenient to define constructors: a u32 constructor can be infallible, but an i64 constructor can fail (if the value is negative) and a u64 constructor can fail (if the value is larger than i64::MAX).  We provide all of these for consumers' convenience."]
    pub size: u64,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Snapshot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Snapshot {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.disk_id).into(),
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            format!("{:?}", self.project_id).into(),
            format!("{:?}", self.size).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "disk_id".into(),
            "id".into(),
            "name".into(),
            "project_id".into(),
            "size".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "Create-time parameters for a [`Snapshot`](omicron_common::api::external::Snapshot)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SnapshotCreate {
    pub description: String,
    #[doc = "The name of the disk to be snapshotted"]
    pub disk: String,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
}

impl std::fmt::Display for SnapshotCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SnapshotCreate {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            self.disk.clone().into(),
            self.name.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "disk".into(), "name".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SnapshotResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Snapshot>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for SnapshotResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for SnapshotResultsPage {
    type Item = Snapshot;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SnapshotResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SpoofLoginBody {
    pub username: String,
}

impl std::fmt::Display for SpoofLoginBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SpoofLoginBody {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.username.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["username".into()]
    }
}

#[doc = "Client view of a [`SshKey`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SshKey {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "SSH public key, e.g., `\"ssh-ed25519 AAAAC3NzaC...\"`"]
    pub public_key: String,
    #[doc = "The user to whom this key belongs"]
    pub silo_user_id: uuid::Uuid,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for SshKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SshKey {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            self.public_key.clone().into(),
            format!("{:?}", self.silo_user_id).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "id".into(),
            "name".into(),
            "public_key".into(),
            "silo_user_id".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "Create-time parameters for an [`SshKey`](crate::external_api::views::SshKey)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SshKeyCreate {
    pub description: String,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
    #[doc = "SSH public key, e.g., `\"ssh-ed25519 AAAAC3NzaC...\"`"]
    pub public_key: String,
}

impl std::fmt::Display for SshKeyCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SshKeyCreate {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            self.name.clone().into(),
            self.public_key.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into(), "public_key".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SshKeyResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<SshKey>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for SshKeyResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for SshKeyResultsPage {
    type Item = SshKey;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for SshKeyResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "The schema for a timeseries.\n\nThis includes the name of the timeseries, as well as the datum type of its metric and the schema for each field."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimeseriesSchema {
    pub created: chrono::DateTime<chrono::Utc>,
    #[doc = "The type of an individual datum of a metric."]
    pub datum_type: DatumType,
    pub field_schema: Vec<FieldSchema>,
    #[doc = "Names are constructed by concatenating the target and metric names with ':'. Target and metric names must be lowercase alphanumeric characters with '_' separating words."]
    pub timeseries_name: String,
}

impl std::fmt::Display for TimeseriesSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TimeseriesSchema {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.created).into(),
            format!("{:?}", self.datum_type).into(),
            format!("{:?}", self.field_schema).into(),
            self.timeseries_name.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "created".into(),
            "datum_type".into(),
            "field_schema".into(),
            "timeseries_name".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct TimeseriesSchemaResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<TimeseriesSchema>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for TimeseriesSchemaResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for TimeseriesSchemaResultsPage {
    type Item = TimeseriesSchema;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for TimeseriesSchemaResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Client view of a [`User`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct User {
    #[doc = "Human-readable name that can identify the user"]
    pub display_name: String,
    pub id: uuid::Uuid,
}

impl std::fmt::Display for User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for User {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.display_name.clone().into(),
            format!("{:?}", self.id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["display_name".into(), "id".into()]
    }
}

#[doc = "Client view of a [`UserBuiltin`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UserBuiltin {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for UserBuiltin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UserBuiltin {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "id".into(),
            "name".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UserBuiltinResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<UserBuiltin>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for UserBuiltinResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for UserBuiltinResultsPage {
    type Item = UserBuiltin;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UserBuiltinResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "How users will be provisioned in a silo during authentication."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum UserProvisionType {
    #[serde(rename = "fixed")]
    #[display("fixed")]
    Fixed,
    #[serde(rename = "jit")]
    #[display("jit")]
    Jit,
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UserResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<User>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for UserResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for UserResultsPage {
    type Item = User;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for UserResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Client view of a [`Vpc`]"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Vpc {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "The name used for the VPC in DNS."]
    pub dns_name: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "The unique local IPv6 address range for subnets in this VPC"]
    #[serde(rename = "ipv6_prefix")]
    pub ipv_6_prefix: String,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "id for the project containing this VPC"]
    pub project_id: uuid::Uuid,
    #[doc = "id for the system router where subnet default routes are registered"]
    pub system_router_id: uuid::Uuid,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
}

impl std::fmt::Display for Vpc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for Vpc {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            self.dns_name.clone().into(),
            format!("{:?}", self.id).into(),
            self.ipv_6_prefix.clone().into(),
            self.name.clone().into(),
            format!("{:?}", self.project_id).into(),
            format!("{:?}", self.system_router_id).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "dns_name".into(),
            "id".into(),
            "ipv_6_prefix".into(),
            "name".into(),
            "project_id".into(),
            "system_router_id".into(),
            "time_created".into(),
            "time_modified".into(),
        ]
    }
}

#[doc = "Create-time parameters for a [`Vpc`](crate::external_api::views::Vpc)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcCreate {
    pub description: String,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub dns_name: String,
    #[doc = "The IPv6 prefix for this VPC.\n\nAll IPv6 subnets created from this VPC must be taken from this range, which sould be a Unique Local Address in the range `fd00::/48`. The default VPC Subnet will have the first `/64` range from this prefix."]
    #[serde(
        rename = "ipv6_prefix",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub ipv_6_prefix: Option<String>,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
}

impl std::fmt::Display for VpcCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcCreate {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            self.dns_name.clone().into(),
            if let Some(ipv_6_prefix) = &self.ipv_6_prefix {
                format!("{:?}", ipv_6_prefix).into()
            } else {
                String::new().into()
            },
            self.name.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "dns_name".into(),
            "ipv_6_prefix".into(),
            "name".into(),
        ]
    }
}

#[doc = "A single rule in a VPC firewall"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcFirewallRule {
    #[doc = "whether traffic matching the rule should be allowed or dropped"]
    pub action: VpcFirewallRuleAction,
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "whether this rule is for incoming or outgoing traffic"]
    pub direction: VpcFirewallRuleDirection,
    #[doc = "reductions on the scope of the rule"]
    pub filters: VpcFirewallRuleFilter,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "the relative priority of this rule"]
    pub priority: u16,
    #[doc = "whether this rule is in effect"]
    pub status: VpcFirewallRuleStatus,
    #[doc = "list of sets of instances that the rule applies to"]
    pub targets: Vec<VpcFirewallRuleTarget>,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
    #[doc = "the VPC to which this rule belongs"]
    pub vpc_id: uuid::Uuid,
}

impl std::fmt::Display for VpcFirewallRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcFirewallRule {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.action).into(),
            self.description.clone().into(),
            format!("{:?}", self.direction).into(),
            format!("{:?}", self.filters).into(),
            format!("{:?}", self.id).into(),
            self.name.clone().into(),
            format!("{:?}", self.priority).into(),
            format!("{:?}", self.status).into(),
            format!("{:?}", self.targets).into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
            format!("{:?}", self.vpc_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "action".into(),
            "description".into(),
            "direction".into(),
            "filters".into(),
            "id".into(),
            "name".into(),
            "priority".into(),
            "status".into(),
            "targets".into(),
            "time_created".into(),
            "time_modified".into(),
            "vpc_id".into(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum VpcFirewallRuleAction {
    #[serde(rename = "allow")]
    #[display("allow")]
    Allow,
    #[serde(rename = "deny")]
    #[display("deny")]
    Deny,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum VpcFirewallRuleDirection {
    #[serde(rename = "inbound")]
    #[display("inbound")]
    Inbound,
    #[serde(rename = "outbound")]
    #[display("outbound")]
    Outbound,
}

#[doc = "Filter for a firewall rule. A given packet must match every field that is present for the rule to apply to it. A packet matches a field if any entry in that field matches the packet."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcFirewallRuleFilter {
    #[doc = "If present, the sources (if incoming) or destinations (if outgoing) this rule applies to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<VpcFirewallRuleHostFilter>>,
    #[doc = "If present, the destination ports this rule applies to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<String>>,
    #[doc = "If present, the networking protocols this rule applies to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocols: Option<Vec<VpcFirewallRuleProtocol>>,
}

impl std::fmt::Display for VpcFirewallRuleFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcFirewallRuleFilter {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(hosts) = &self.hosts {
                format!("{:?}", hosts).into()
            } else {
                String::new().into()
            },
            if let Some(ports) = &self.ports {
                format!("{:?}", ports).into()
            } else {
                String::new().into()
            },
            if let Some(protocols) = &self.protocols {
                format!("{:?}", protocols).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["hosts".into(), "ports".into(), "protocols".into()]
    }
}

#[doc = "The `VpcFirewallRuleHostFilter` is used to filter traffic on the basis of its source or destination host."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type", content = "value")]
pub enum VpcFirewallRuleHostFilter {
    #[doc = "The rule applies to traffic from/to all instances in the VPC"]
    #[serde(rename = "vpc")]
    Vpc(String),
    #[doc = "The rule applies to traffic from/to all instances in the VPC Subnet"]
    #[serde(rename = "subnet")]
    Subnet(String),
    #[doc = "The rule applies to traffic from/to this specific instance"]
    #[serde(rename = "instance")]
    Instance(String),
    #[doc = "The rule applies to traffic from/to a specific IP address"]
    #[serde(rename = "ip")]
    Ip(std::net::IpAddr),
    #[doc = "The rule applies to traffic from/to a specific IP subnet"]
    #[serde(rename = "ip_net")]
    IpNet(IpNet),
}

#[doc = "The protocols that may be specified in a firewall rule's filter"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum VpcFirewallRuleProtocol {
    #[serde(rename = "TCP")]
    #[display("TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    #[display("UDP")]
    Udp,
    #[serde(rename = "ICMP")]
    #[display("ICMP")]
    Icmp,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum VpcFirewallRuleStatus {
    #[serde(rename = "disabled")]
    #[display("disabled")]
    Disabled,
    #[serde(rename = "enabled")]
    #[display("enabled")]
    Enabled,
}

#[doc = "A `VpcFirewallRuleTarget` is used to specify the set of [`Instance`]s to which a firewall rule applies."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
#[serde(tag = "type", content = "value")]
pub enum VpcFirewallRuleTarget {
    #[doc = "The rule applies to all instances in the VPC"]
    #[serde(rename = "vpc")]
    Vpc(String),
    #[doc = "The rule applies to all instances in the VPC Subnet"]
    #[serde(rename = "subnet")]
    Subnet(String),
    #[doc = "The rule applies to this specific instance"]
    #[serde(rename = "instance")]
    Instance(String),
    #[doc = "The rule applies to a specific IP address"]
    #[serde(rename = "ip")]
    Ip(std::net::IpAddr),
    #[doc = "The rule applies to a specific IP subnet"]
    #[serde(rename = "ip_net")]
    IpNet(IpNet),
}

#[doc = "A single rule in a VPC firewall"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcFirewallRuleUpdate {
    #[doc = "whether traffic matching the rule should be allowed or dropped"]
    pub action: VpcFirewallRuleAction,
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "whether this rule is for incoming or outgoing traffic"]
    pub direction: VpcFirewallRuleDirection,
    #[doc = "reductions on the scope of the rule"]
    pub filters: VpcFirewallRuleFilter,
    #[doc = "name of the rule, unique to this VPC"]
    pub name: String,
    #[doc = "the relative priority of this rule"]
    pub priority: u16,
    #[doc = "whether this rule is in effect"]
    pub status: VpcFirewallRuleStatus,
    #[doc = "list of sets of instances that the rule applies to"]
    pub targets: Vec<VpcFirewallRuleTarget>,
}

impl std::fmt::Display for VpcFirewallRuleUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcFirewallRuleUpdate {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.action).into(),
            self.description.clone().into(),
            format!("{:?}", self.direction).into(),
            format!("{:?}", self.filters).into(),
            self.name.clone().into(),
            format!("{:?}", self.priority).into(),
            format!("{:?}", self.status).into(),
            format!("{:?}", self.targets).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "action".into(),
            "description".into(),
            "direction".into(),
            "filters".into(),
            "name".into(),
            "priority".into(),
            "status".into(),
            "targets".into(),
        ]
    }
}

#[doc = "Updateable properties of a `Vpc`'s firewall Note that VpcFirewallRules are implicitly created along with a Vpc, so there is no explicit creation."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcFirewallRuleUpdateParams {
    pub rules: Vec<VpcFirewallRuleUpdate>,
}

impl std::fmt::Display for VpcFirewallRuleUpdateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcFirewallRuleUpdateParams {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.rules).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["rules".into()]
    }
}

#[doc = "Collection of a [`Vpc`]'s firewall rules"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcFirewallRules {
    pub rules: Vec<VpcFirewallRule>,
}

impl std::fmt::Display for VpcFirewallRules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcFirewallRules {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![format!("{:?}", self.rules).into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["rules".into()]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<Vpc>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for VpcResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for VpcResultsPage {
    type Item = Vpc;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "A VPC router defines a series of rules that indicate where traffic should be sent depending on its destination."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcRouter {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    pub kind: VpcRouterKind,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
    #[doc = "The VPC to which the router belongs."]
    pub vpc_id: uuid::Uuid,
}

impl std::fmt::Display for VpcRouter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcRouter {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.id).into(),
            format!("{:?}", self.kind).into(),
            self.name.clone().into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
            format!("{:?}", self.vpc_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "id".into(),
            "kind".into(),
            "name".into(),
            "time_created".into(),
            "time_modified".into(),
            "vpc_id".into(),
        ]
    }
}

#[doc = "Create-time parameters for a [`VpcRouter`](crate::external_api::views::VpcRouter)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcRouterCreate {
    pub description: String,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
}

impl std::fmt::Display for VpcRouterCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcRouterCreate {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![self.description.clone().into(), self.name.clone().into()]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into()]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum VpcRouterKind {
    #[serde(rename = "system")]
    #[display("system")]
    System,
    #[serde(rename = "custom")]
    #[display("custom")]
    Custom,
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcRouterResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<VpcRouter>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for VpcRouterResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for VpcRouterResultsPage {
    type Item = VpcRouter;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcRouterResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Updateable properties of a [`VpcRouter`](crate::external_api::views::VpcRouter)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcRouterUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for VpcRouterUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcRouterUpdate {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into()]
    }
}

#[doc = "A VPC subnet represents a logical grouping for instances that allows network traffic between them, within a IPv4 subnetwork or optionall an IPv6 subnetwork."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcSubnet {
    #[doc = "human-readable free-form text about a resource"]
    pub description: String,
    #[doc = "unique, immutable, system-controlled identifier for each resource"]
    pub id: uuid::Uuid,
    #[doc = "The IPv4 subnet CIDR block."]
    #[serde(rename = "ipv4_block")]
    pub ipv_4_block: String,
    #[doc = "The IPv6 subnet CIDR block."]
    #[serde(rename = "ipv6_block")]
    pub ipv_6_block: String,
    #[doc = "unique, mutable, user-controlled identifier for each resource"]
    pub name: String,
    #[doc = "timestamp when this resource was created"]
    pub time_created: chrono::DateTime<chrono::Utc>,
    #[doc = "timestamp when this resource was last modified"]
    pub time_modified: chrono::DateTime<chrono::Utc>,
    #[doc = "The VPC to which the subnet belongs."]
    pub vpc_id: uuid::Uuid,
}

impl std::fmt::Display for VpcSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcSubnet {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            format!("{:?}", self.id).into(),
            self.ipv_4_block.clone().into(),
            self.ipv_6_block.clone().into(),
            self.name.clone().into(),
            format!("{:?}", self.time_created).into(),
            format!("{:?}", self.time_modified).into(),
            format!("{:?}", self.vpc_id).into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "id".into(),
            "ipv_4_block".into(),
            "ipv_6_block".into(),
            "name".into(),
            "time_created".into(),
            "time_modified".into(),
            "vpc_id".into(),
        ]
    }
}

#[doc = "Create-time parameters for a [`VpcSubnet`](crate::external_api::views::VpcSubnet)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcSubnetCreate {
    pub description: String,
    #[doc = "The IPv4 address range for this subnet.\n\nIt must be allocated from an RFC 1918 private address range, and must not overlap with any other existing subnet in the VPC."]
    #[serde(rename = "ipv4_block")]
    pub ipv_4_block: String,
    #[doc = "The IPv6 address range for this subnet.\n\nIt must be allocated from the RFC 4193 Unique Local Address range, with the prefix equal to the parent VPC's prefix. A random `/64` block will be assigned if one is not provided. It must not overlap with any existing subnet in the VPC."]
    #[serde(
        rename = "ipv6_block",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub ipv_6_block: Option<String>,
    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    pub name: String,
}

impl std::fmt::Display for VpcSubnetCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcSubnetCreate {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            self.description.clone().into(),
            self.ipv_4_block.clone().into(),
            if let Some(ipv_6_block) = &self.ipv_6_block {
                format!("{:?}", ipv_6_block).into()
            } else {
                String::new().into()
            },
            self.name.clone().into(),
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            "description".into(),
            "ipv_4_block".into(),
            "ipv_6_block".into(),
            "name".into(),
        ]
    }
}

#[doc = "A single page of results"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcSubnetResultsPage {
    #[doc = "list of items on this page of results"]
    pub items: Vec<VpcSubnet>,
    #[doc = "token used to fetch the next page of results (if any)"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page: Option<String>,
}

impl std::fmt::Display for VpcSubnetResultsPage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "requests")]
impl crate::types::paginate::Pagination for VpcSubnetResultsPage {
    type Item = VpcSubnet;
    fn has_more_pages(&self) -> bool {
        self.next_page.is_some()
    }

    fn next_page_token(&self) -> Option<String> {
        self.next_page.clone()
    }

    fn next_page(
        &self,
        req: reqwest::Request,
    ) -> anyhow::Result<reqwest::Request, crate::types::error::Error> {
        let mut req = req.try_clone().ok_or_else(|| {
            crate::types::error::Error::InvalidRequest(format!(
                "failed to clone request: {:?}",
                req
            ))
        })?;
        req.url_mut()
            .query_pairs_mut()
            .append_pair("next_page", self.next_page.as_deref().unwrap_or(""));
        Ok(req)
    }

    fn items(&self) -> Vec<Self::Item> {
        self.items.clone()
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcSubnetResultsPage {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            format!("{:?}", self.items).into(),
            if let Some(next_page) = &self.next_page {
                format!("{:?}", next_page).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["items".into(), "next_page".into()]
    }
}

#[doc = "Updateable properties of a [`VpcSubnet`](crate::external_api::views::VpcSubnet)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcSubnetUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for VpcSubnetUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcSubnetUpdate {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "name".into()]
    }
}

#[doc = "Updateable properties of a [`Vpc`](crate::external_api::views::Vpc)"]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct VpcUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl std::fmt::Display for VpcUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

#[cfg(feature = "tabled")]
impl tabled::Tabled for VpcUpdate {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<std::borrow::Cow<'static, str>> {
        vec![
            if let Some(description) = &self.description {
                format!("{:?}", description).into()
            } else {
                String::new().into()
            },
            if let Some(dns_name) = &self.dns_name {
                format!("{:?}", dns_name).into()
            } else {
                String::new().into()
            },
            if let Some(name) = &self.name {
                format!("{:?}", name).into()
            } else {
                String::new().into()
            },
        ]
    }

    fn headers() -> Vec<std::borrow::Cow<'static, str>> {
        vec!["description".into(), "dns_name".into(), "name".into()]
    }
}

#[doc = "Supported set of sort modes for scanning by id only.\n\nCurrently, we only support scanning in ascending order."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum IdSortMode {
    #[serde(rename = "id_ascending")]
    #[display("id_ascending")]
    IdAscending,
}

impl std::default::Default for IdSortMode {
    fn default() -> Self {
        IdSortMode::IdAscending
    }
}

#[doc = "Supported set of sort modes for scanning by name only\n\nCurrently, we only support scanning in ascending order."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum NameSortMode {
    #[serde(rename = "name_ascending")]
    #[display("name_ascending")]
    NameAscending,
}

impl std::default::Default for NameSortMode {
    fn default() -> Self {
        NameSortMode::NameAscending
    }
}

#[doc = "Supported set of sort modes for scanning by name or id"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    parse_display :: FromStr,
    parse_display :: Display,
)]
#[cfg_attr(feature = "clap", derive(clap::ValueEnum))]
#[cfg_attr(feature = "tabled", derive(tabled::Tabled))]
pub enum NameOrIdSortMode {
    #[serde(rename = "name_ascending")]
    #[display("name_ascending")]
    NameAscending,
    #[serde(rename = "name_descending")]
    #[display("name_descending")]
    NameDescending,
    #[serde(rename = "id_ascending")]
    #[display("id_ascending")]
    IdAscending,
}
